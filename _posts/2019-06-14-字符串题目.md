---
categories: problems
layout: post
---

- Table
{:toc}

# BZOJ3098

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=3098](https://www.lydsy.com/JudgeOnline/problem.php?id=3098)

**题解**

随机生成长度为n的字符串。要求计算有多少种不同的长度为m的字符串。设Hash时模去的素数为p。

对于两个不同的字符串，发生误判的概率应该为$\frac{m}{p}$，总共有$n-m$种不同的字符串。而根据生日悖论知道，需要$\sqrt{p/m}$种字符串才能保证发生至少一次误判。


$$
\sqrt{\frac{p}{m}} < n\Rightarrow p<mn^2
$$


我们知道增大m的价值不大，而减少m可以有效的提高$n^2$，因此让m尽可能小，只要保证哈希值足够超出p就可以了。

# POJ2774

**题意**

[http://poj.org/problem?id=2774](http://poj.org/problem?id=2774)

**题解**

神级模板题。还有更裸的吗，后缀数组、后缀自动机、后缀树啥的，都来一波。

# BZOJ1031

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1031](https://www.lydsy.com/JudgeOnline/problem.php?id=1031)

**题解**

很显然，问题要我们对所有可能的序列进行排序。想到对子串进行排序，应该能想到后缀数组吧。但是问题中是对序列进行排序，而非后缀，我们可以将输入字符串s变为s+s。之后如果两个后缀的第一个字符下标均小于\|s\|，那么此时二者的顺序取决于第一个不同的字符，如果这个字符离第一个字符距离超过\|s\|，那么二者顺序不影响结果，否则这个字符将决定二者的正确顺序。

之后直接用height数组，搞搞最长公共前缀就可以了。

# BZOJ1014

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1014](https://www.lydsy.com/JudgeOnline/problem.php?id=1014)

**题解**

判断最长公共前缀，可以用二分加哈希的方法快速计算。但是我们发现字符串是会改变的，因此不能提前算哈希值。我们可以将字符串放在平衡树上维护，pushUp时重新计算哈希值，这样不仅支持修改新增操作，而且每次查询某段区间的哈希值的时间复杂度都被优化到了$O(\log_2n)$。

# Codeforces1207G

**题意**

[https://codeforces.com/contest/1207/problem/G](https://codeforces.com/contest/1207/problem/G)

**题解**

首先理解问题，我们有n个字符串和m个匹配串，希望能找到m个匹配串的出现次数。非常明显的一点就是我们要将m个匹配串建立AC自动机。之后可以发现n个字符串实际上对应了大小为n的一棵前缀树。

之后我们遍历前缀树，每遍历一个顶点，就处理与顶点关联的所有匹配串。需要注意的是我们需要实时统计某个匹配串出现次数，我们可以将AC自动机的fail链条建树，之后一个匹配串的出现次数实际是这个匹配串对应的AC自动机结点及其下所有结点匹配次数之和。

还有一点需要注意的是前缀树会发生回溯，因此每次处理完一个顶点并返回时需要回退所做的所有操作。

时间复杂度为$O(20(n+m))$

# LUOGU4555

**题意**

[https://www.luogu.org/problem/P4555](https://www.luogu.org/problem/P4555)

**题解**

定义函数$f(i)$表示以i为最后一个字符的最长回文长度，定义$g(i)$表示以i为第一个字符的最长回文长度。因此最终结果就是$f(i)+g(i+1)$，枚举所有的切分点i即可。

$f$和$g$都可以通过最长尾回文算法得出，比如哈希，manacher或者回文树都可以。

# Hash算法

考虑有一个字符串$s=s_0s_1\ldots s_{n-1}$，要求快速判断字符串的某两个子串$\[l,r\]$和$\[a,b\]$是否完全相同。

我们可以用哈希算法来进行快速判断。

称$f_s(x)=\sum_{i=0}^{n-1}s_ix^{n-1-i}$是字符串$S$的哈希多项式。而对于某个选定的$x_0$，称$f_S(x_0)$为字符串$S$在$x_0$上的哈希值。

考虑两个字符串$a=a_0a_1\ldots a_{n-1}$和$b=b_0b_1\ldots b_{n-1}$。考虑$H(x)=f_a(x)-f_b(x)=\sum_{i=0}^{n-1}(a_i-b_i)x^{n-1-i}$。很显然当$A$和$B$相同的时候，$H(x)=0$，换言之，当两个字符串相同，无论$x_0$怎么选择，$H(x)$都为0，这代表着始终有$f_a(x_0)=f_b(x_0)$。

现在我们来估计误判率，即对于两个不同的字符串，两者有着相同的哈希值的概率。下面假设$a\neq b$。这时候我们会发现$H(x)\neq 0$，且阶数不超过$n-1$。

我们要证明误判率，首先需要聊聊如何防止精度溢出，一般的方法就是让其自然溢出（等价于模$2^{32}$），但是这样并不好，因为模合数的剩余类环不支持乘法逆运算，如果我们选择一个素数$p$，这样我们让结果模$p$，这时候由于模素数的剩余类环支持乘法逆运算（实际上就是域）。

一个定义在某个域上的非0多项式，其最多有和其阶数相同的零点。因此我们可以判断出$H$在模$p$的剩余类中最多有$n-1$个零点。因此假如我们随机选择$0$到$p-1$中的数作为$x_0$，那么可以推测出$P(H(x_0)=0)\leq \frac{n-1}{p}$。即误判率不超过$\frac{n}{p}$。

有时候由于生日悖论的缘故，导致哈希失败，有一种简单的方法解决，那就是独立选择多个可能的$x_1,\ldots,x_k$，只有当两个字符在任意$x_i$上取到相同的哈希值时才认为二者相同。由于选择是独立的，因此误判概率为$(\frac{n}{p})^k$。

我们可以用差分法来维护整个字符串的哈希值，这样查询某段区间字符串的哈希值时的时间复杂度为$O(1)$，在末尾增加或删除一个字符的时间复杂度为$O(1)$。

我们也可以用BIT或平衡树来维护哈希值，这样可以支持在前部增加和删除字符的操作，但是所有的操作的时间复杂度都会提高到$O(\log_2n)$。

要算二维数组的哈希，我们可以将每一行构建一个差分哈希，之后用滚动哈希的方式结合多行即可。

# 字符串的一些周期、border性质

对于字符串$s=s_0s_1\ldots s_{n-1}$，记$s(i..j)$表示字符串$s_is_{i+1}\ldots s_j$，记$pre(s,l)$表示$s(0..l-1)$，$suf(s,l)$表示$s(n-l..n-1)$。

如果存在整数$p$，满足$\forall i+p<n$，有$s_{p+i}=s_{i}$，那么称$p$是$s$的一个周期。

如果存在整数$b$，满足$pre(s,b)=suf(s,b$，那么称$b$是$s$的一个border。

**弱周期定理：若$p$和$q$都是字符串$s$的周期，且$p+q\leq \|s\|$，那么$gcd(p,q)$也是字符串$s$的周期**

**命题1：若字符串$u$、$v$满足$2\|u\|\geq \|v\|$，则$u$在$v$中的所有匹配位置形成一个等差数列。**

**命题2：若字符串$u$、$v$满足$2\|u\|\geq \|v\|$，且$u$在$v$中有两个以上匹配位置，则形成的等差数列的公差为$u$的最小周期$per(u)$**

**命题3：字符串$s$的所有border按长度排序后可以分成$O(\log_2\|s\|)$段，每一段都是一个等差数列**。

# Atcoder Combination Lock

**题意**

[https://atcoder.jp/contests/cf17-final/tasks/cf17_final_e](https://atcoder.jp/contests/cf17-final/tasks/cf17_final_e)

**题解**

首先将字符串s中的每个字符减去'a'，这样字符的取值范围被限定到了0~25。

在字符串的前面加上一个字符0，尾部加上最后的一个字符。

比如序列`[1,2,3,4]`，修改后为`[0,1,2,3,4,4]`。

之后我们建立序列的差分形式d，即`d[i]=s[i]-s[i-1]`（`d[0]=0`）。

之后我们会发现区间`[l,r]`增加值操作变成了`d[l]`加上1和`d[r+1]`减去1。

现在考虑一个回文，假设i和j是沿着回文中心对称的两个坐标，那么必定有`d[i+1]=-d[j]`。

```
[...,a,b,...,b,a...]
[...,x,b-a,...,y,a-b,...]
```

现在我们会发现，我们希望通过在差分数组一些下标上加1，一些下标上减1，最后使得对于任意i，以及沿着中心对称的坐标j，满足`d[i+1]+d[j]=0`。

之后对于对称坐标对(i,j)，我们在二者之间连表。同时对于任意操作`[l,r]`，我们在坐标对(l,r+1)之间连边。这样对于任意连通块，连通块中顶点之间的值是共享的，我们需要平衡它们的值，使得对称坐标代表的顶点的值为0。这能成立当且仅当连通块中值之和为0。

这样问题就解决了。时间复杂度为$O(n)$。

# Z algorithm

最近做了[这道题](https://codeforces.com/contest/1051/problem/E)，一开始直接用哈希+二分来比较大数，这样时间复杂度为$O(n\log_2n)$，但是java死活跑步过去。之后发现可以通过LCP来快速定位不同的字符出现位置来加速比较，于是用了SAIS线性处理LCP，终于在900+ms内跑过了。

看了下正解，好像用的是Z algorithm，之前听过 但是一直没学，所以现在补一下。

Z algorithm用于在给定的序列$S\[1..n\]$上建立一个Z函数，其中$Z(i)$表示字符串$S\[1..n\]$和字符串$S\[i..n\]$的最长公共前缀长度。

下面我们来考虑如何实现线性时间处理Z函数。对于每个$i$，我们始终维护一个区间$\[l,r\]$，区间满足$r$最大，且$l\leq i\leq r$，且$S\[l..r\]$是$S\[1..n\]$的前缀。

我们始终设置$Z(1)=n$。接下来我们计算$Z(2),\ldots, Z(n)$。假设我们处理完了$i-1$后，接下来开始处理$i$。有几种情况：

1. 如果此时$i=2$，那么我们就设置$l=i$，暴力计算$r$。
2. 如果此时$r<i$，这说明不存在左边界小于$i$的包含$i$的区间（假如存在，那么就我们在处理$i-1$的时候就会有$r\geq i$）。因此我们重新设置$l=i$，并暴力计算$r$。
3. 此时一定有$l\leq i\leq r$。我们记$t=i-l+1$,记录$k=r-i+1$，那么我们可以保证$Z(i)\geq min(Z(t), k)$，因为$S\[i..n\]$与$S\[t..n\]$的最长公共前缀长度为$k$。下面我们继续分两种情况讨论：
   1. 如果$Z(t)>k$，那么此时一定有$Z(i)=k$，且$l$和$r$不变。
   2. 否则$Z(t)\leq k$，我们可以保证$Z(i)\geq k$，这时候我们可以将$l$设置为$i$，$r$向右暴力扩展。

除了暴力操作部分，其余的操作时间复杂度都是$O(n)$。并且容易发现每次暴力操作都会使得$r$增大，而$r$只会在$i$增大时减少1，因此暴力最多发生$O(2n)$次。总的时间复杂度为$O(n)$

换了Z algorithm后，233ms就通过了。

# 后缀树

很早以前了解到后缀树算法，但是一直不会。本来以为会后缀自动机就不需要学后缀树，但是，后缀自动机的各种定义太过复杂，已经忘光了，最近做到一道印度人出的[题](https://codeforces.com/contest/1037/problem/H)，似乎要用到后缀自动机比较高级的功能，但是不会，但是假如是后缀树的话，由于是树状结构，因此是可以搞的，所以去学了下。

学习的资料：[斯坦福大学课件](http://web.stanford.edu/class/archive/cs/cs166/cs166.1146/lectures/10/Slides10.pdf)，[stackoverflow大佬讲解](https://stackoverflow.com/a/9513423)。

这里简单讲一下后缀树的特点。我们可以考虑将长度为$n$的某个序列的所有后缀插入到一株前缀树中，最后得到的就是后缀树。但是与前缀树不同的是，在前缀树中顶点代表一个字符，而后缀树中边代表一个字符。但是这样做可能会出现$O(n^2)$个顶点，于是我们可以将那些只有一个子结点的顶点与子顶点压缩成一个顶点，这样一条边就代表了某个连续子序列。由于每个后缀最后一定肯定是不同的顶点，因此会有$n$个顶点，之后每次合并都会使$n$个顶点中两个不连通的顶点连通，因此会合并$n-1$次，总的顶点数为$2n-1$。

![](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d2/Suffix_tree_BANANA.svg/1920px-Suffix_tree_BANANA.svg.png)

上面的图引自wiki，大家看一下就好了。

至于代码是不可能有的，根本不会，我用的也是别人写的库。

# 一些后缀处理问题

**问题1：给定一个字符串S，和$m$个查询，每个查询给定$l,r,X$，要求找出所有$S\[l..r\]$的所有字典序严格大于X的子串中最小的**

这是cf的[原题](https://codeforces.com/contest/1037/problem/H)。

一开始的想法是实现一个在线维护后缀的数据结构，但是好像不存在这种东西。于是就转向后缀树，希望能树上维护减少难度。

我的做法是这样的，首先建立S的后缀树，之后我们在后缀树上DFS，给每个叶子分配ID，且要求每个顶点子树中叶子的ID是连续的，这样我们就可以将每个顶点表示成一个区间，然后丢到线段树上进行维护。

之后我们将查询按$l$从大到小进行处理，当处理到某个$l$的时候，我们就将所有$ID$大于等于$l$的叶子激活。之后在后缀树上找到$X$对应的顶点，之后向上回溯，寻找S中是否有个较大的子串满足$r-query(L,R)+1>depth$，其中$query(L,R)$表示的是查询当且顶点子树下已经激活的ID最小的叶子的ID。

整个算法的运行时间是$O(26n+26M\log_2n)$，其中$M$是所有$X$的长度总和。

可以发现把问题丢到树上就非常容易解决。

# 参考文献

- [金策_字符串算法选讲](https://github.com/taodaling/pan/blob/master/string/%E9%87%91%E7%AD%96_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%E9%80%89%E8%AE%B2.pdf)
