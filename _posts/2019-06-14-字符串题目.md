---
categories: problems
layout: post
---

- Table
{:toc}

# BZOJ3098

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=3098](https://www.lydsy.com/JudgeOnline/problem.php?id=3098)

**题解**

随机生成长度为n的字符串。要求计算有多少种不同的长度为m的字符串。设Hash时模去的素数为p。

对于两个不同的字符串，发生误判的概率应该为$\frac{m}{p}$，总共有$n-m$种不同的字符串。而根据生日悖论知道，需要$\sqrt{p/m}$种字符串才能保证发生至少一次误判。


$$
\sqrt{\frac{p}{m}} < n\Rightarrow p<mn^2
$$


我们知道增大m的价值不大，而减少m可以有效的提高$n^2$，因此让m尽可能小，只要保证哈希值足够超出p就可以了。

# POJ2774

**题意**

[http://poj.org/problem?id=2774](http://poj.org/problem?id=2774)

**题解**

神级模板题。还有更裸的吗，后缀数组、后缀自动机、后缀树啥的，都来一波。

# BZOJ1031

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1031](https://www.lydsy.com/JudgeOnline/problem.php?id=1031)

**题解**

很显然，问题要我们对所有可能的序列进行排序。想到对子串进行排序，应该能想到后缀数组吧。但是问题中是对序列进行排序，而非后缀，我们可以将输入字符串s变为s+s。之后如果两个后缀的第一个字符下标均小于\|s\|，那么此时二者的顺序取决于第一个不同的字符，如果这个字符离第一个字符距离超过\|s\|，那么二者顺序不影响结果，否则这个字符将决定二者的正确顺序。

之后直接用height数组，搞搞最长公共前缀就可以了。

# BZOJ1014

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1014](https://www.lydsy.com/JudgeOnline/problem.php?id=1014)

**题解**

判断最长公共前缀，可以用二分加哈希的方法快速计算。但是我们发现字符串是会改变的，因此不能提前算哈希值。我们可以将字符串放在平衡树上维护，pushUp时重新计算哈希值，这样不仅支持修改新增操作，而且每次查询某段区间的哈希值的时间复杂度都被优化到了$O(\log_2n)$。

# Codeforces1207G

**题意**

[https://codeforces.com/contest/1207/problem/G](https://codeforces.com/contest/1207/problem/G)

**题解**

首先理解问题，我们有n个字符串和m个匹配串，希望能找到m个匹配串的出现次数。非常明显的一点就是我们要将m个匹配串建立AC自动机。之后可以发现n个字符串实际上对应了大小为n的一棵前缀树。

之后我们遍历前缀树，每遍历一个顶点，就处理与顶点关联的所有匹配串。需要注意的是我们需要实时统计某个匹配串出现次数，我们可以将AC自动机的fail链条建树，之后一个匹配串的出现次数实际是这个匹配串对应的AC自动机结点及其下所有结点匹配次数之和。

还有一点需要注意的是前缀树会发生回溯，因此每次处理完一个顶点并返回时需要回退所做的所有操作。

时间复杂度为$O(20(n+m))$

# LUOGU4555

**题意**

[https://www.luogu.org/problem/P4555](https://www.luogu.org/problem/P4555)

**题解**

定义函数$f(i)$表示以i为最后一个字符的最长回文长度，定义$g(i)$表示以i为第一个字符的最长回文长度。因此最终结果就是$f(i)+g(i+1)$，枚举所有的切分点i即可。

$f$和$g$都可以通过最长尾回文算法得出，比如哈希，manacher或者回文树都可以。

# Hash算法

考虑有一个字符串$s=s_0s_1\ldots s_{n-1}$，要求快速判断字符串的某两个子串$\[l,r\]$和$\[a,b\]$是否完全相同。

我们可以用哈希算法来进行快速判断。

称$f_s(x)=\sum_{i=0}^{n-1}s_ix^{n-1-i}$是字符串$S$的哈希多项式。而对于某个选定的$x_0$，称$f_S(x_0)$为字符串$S$在$x_0$上的哈希值。

考虑两个字符串$a=a_0a_1\ldots a_{n-1}$和$b=b_0b_1\ldots b_{n-1}$。考虑$H(x)=f_a(x)-f_b(x)=\sum_{i=0}^{n-1}(a_i-b_i)x^{n-1-i}$。很显然当$A$和$B$相同的时候，$H(x)=0$，换言之，当两个字符串相同，无论$x_0$怎么选择，$H(x)$都为0，这代表着始终有$f_a(x_0)=f_b(x_0)$。

现在我们来估计误判率，即对于两个不同的字符串，两者有着相同的哈希值的概率。下面假设$a\neq b$。这时候我们会发现$H(x)\neq 0$，且阶数不超过$n-1$。

我们要证明误判率，首先需要聊聊如何防止精度溢出，一般的方法就是让其自然溢出（等价于模$2^{32}$），但是这样并不好，因为模合数的剩余类环不支持乘法逆运算，如果我们选择一个素数$p$，这样我们让结果模$p$，这时候由于模素数的剩余类环支持乘法逆运算（实际上就是域）。

一个定义在某个域上的非0多项式，其最多有和其阶数相同的零点。因此我们可以判断出$H$在模$p$的剩余类中最多有$n-1$个零点。因此假如我们随机选择$0$到$p-1$中的数作为$x_0$，那么可以推测出$P(H(x_0)=0)\leq \frac{n-1}{p}$。即误判率不超过$\frac{n}{p}$。

有时候由于生日悖论的缘故，导致哈希失败，有一种简单的方法解决，那就是独立选择多个可能的$x_1,\ldots,x_k$，只有当两个字符在任意$x_i$上取到相同的哈希值时才认为二者相同。由于选择是独立的，因此误判概率为$(\frac{n}{p})^k$。

我们可以用差分法来维护整个字符串的哈希值，这样查询某段区间字符串的哈希值时的时间复杂度为$O(1)$，在末尾增加或删除一个字符的时间复杂度为$O(1)$。

我们也可以用BIT或平衡树来维护哈希值，这样可以支持在前部增加和删除字符的操作，但是所有的操作的时间复杂度都会提高到$O(\log_2n)$。

要算二维数组的哈希，我们可以将每一行构建一个差分哈希，之后用滚动哈希的方式结合多行即可。

# 字符串的一些周期、border性质

对于字符串$s=s_0s_1\ldots s_{n-1}$，记$s(i..j)$表示字符串$s_is_{i+1}\ldots s_j$，记$pre(s,l)$表示$s(0..l-1)$，$suf(s,l)$表示$s(n-l..n-1)$。

如果存在整数$p$，满足$\forall i+p<n$，有$s_{p+i}=s_{i}$，那么称$p$是$s$的一个周期。

如果存在整数$b$，满足$pre(s,b)=suf(s,b$，那么称$b$是$s$的一个border。

**弱周期定理：若$p$和$q$都是字符串$s$的周期，且$p+q\leq \|s\|$，那么$gcd(p,q)$也是字符串$s$的周期**

**命题1：若字符串$u$、$v$满足$2\|u\|\geq \|v\|$，则$u$在$v$中的所有匹配位置形成一个等差数列。**

**命题2：若字符串$u$、$v$满足$2\|u\|\geq \|v\|$，且$u$在$v$中有两个以上匹配位置，则形成的等差数列的公差为$u$的最小周期$per(u)$**

**命题3：字符串$s$的所有border按长度排序后可以分成$O(\log_2\|s\|)$段，每一段都是一个等差数列**。



# 参考文献

- [金策_字符串算法选讲](https://github.com/taodaling/pan/blob/master/string/%E9%87%91%E7%AD%96_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%E9%80%89%E8%AE%B2.pdf)
