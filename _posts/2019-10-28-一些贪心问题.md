---
categories: algorithm
layout: post
---

- table
{:toc}

# 拟阵

拟阵可以用于证明很多贪心策略的正确性。

这部分的内容主要来自于[【洛谷日报#181】拟阵与最优化问题](https://zhuanlan.zhihu.com/p/74887308)，我主要做了整理以及重写了所有的证明。

设$S$是一个集合，而$L$是$S$的子集族（由$S$的子集组成的一个集合）。我们称$(S,L)$是拟阵，如果它满足下面的性质：

1. $S$是有限集。
2. $\{\emptyset\}\in L$
3. 遗传性：若$A\subseteq B$，则$B\in L\rightarrow A\in L$。
4. 交换性：若$A,B\in L$，且$\|A\|<\|B\|$，那么一定存在一个元素$x\in B\setminus A$，使得$A\cup \{x\}\in L$。

集合$L$中的每个元素，都称作独立集。如果$A$是独立集，且存在某个元素$x\in S$，使得$A\cup \{x\}$也是独立集，那么称$A$是可扩展的，否则称$A$是极大独立集。

**命题1：$L$中的所有极大独立集拥有相同大小**

证明：如果存在两个极大独立集$A$,$B$，且$A$的大小小于$B$，则根据交换性，我们可以从$B$中找到一个元素扩展$A$，这与$A$是极大独立集的前提相悖。

现在考虑我们选择了一个权值函数$w:S\rightarrow \Reals^+$，我们利用这个函数为每个$S$中的元素赋予一个正数权值。同时我们定义一个独立集的权值为其中所有元素的权值之和，即：$w(A)=\sum_{x\in A}w(x)$。如果对于某个独立集$A$，它的权值大于等于所有$L$中独立集的权值，那么称$A$是最大权独立集。

**命题2：最大权独立集一定是极大的**

证明：假设$A$是最大权独立集且不是极大的，$B$是任意极大独立集，我们可以找到$B$中的某个元素$x$来扩展$A$，考虑到$w(x)>0$，因此$w(A\cup \{x\})=w(A)+w(x)>w(A)$，这与$A$是最大权独立集相悖。

这里我们可以直接提供一个算法来计算最大权独立集：

```java
maximumWeightIndependentSet(S, L){
    将S中的元素按照权值从大到小进行排序;
    A = {};
    //从前到后遍历S
    for(x : S){
        //如果A与{x}的并集是独立集
        if((A+{x}) in L){
            A = A + {x};
        }
    }
    return A;
}
```

很显然这个算法的时间复杂度为$O(n(log_2n+m))$，其中$n=\|S\|$，$m$是每次判断某个集合是否是独立集的时间复杂度。

**命题3：上面的`maximumWeightIndependentSet`返回的是最大权独立集**

证明：

我们这边需要利用归纳法进行证明。记$S_i$表示由$S$中权值最大的前$i$个元素组成的集合，$L_i$表示$L$中所有仅包含$S_i$中元素的集合组成的族，记录$A_i$表示拟阵$(S_i,L_i)$的最大权独立集。在处理完$S_0$后，很显然此时$A_0$是空集。

考虑处理完前$i$个元素后，此时$A_i$是$S_i$的最大权独立集。现在我们考虑集合$A'=A_i\cup \{x\}$，其中$x$是$S$中权重第$i+1$大的元素。

如果$A'\in L$，那么我们可以直接断定$L_{i+1}$的极大独立集的大小等于$\|A'\|$，由于$L_i$的极大独立集大小为$\|A_i\|=\|A'\|-1$，因此$A_{i+1}$一定包含$x$，由于$A_{i+1}\setminus \{x\}$是$L_i$中的某个独立集，其权值不可能超过$A_i$。因此在这种情况下一定有$w(A_{i+1})=w(A')$。

现在考虑$A'\notin L$，那么我们可以断定$L_{i+1}$的极大独立集的大小等于$\|A_i\|$。若$A_{i+1}$包含$x$，那么$A_{i+1}\setminus \{x\}$是$L_i$的某个独立集（非极大），同时由交换性可知：我们可以从$A_i$中选出一个元素加入到$A_{i+1}\setminus \{x\}$中。这样得到的集合是$L_{i}$的某个独立集，且权重要大于等于$A_{i+1}$，小于等于$A_i$，因此可以得出$w(A_i)=w(A_{i+1})$。

因此利用归纳法我们就证明了算法的正确性。

## 例子1：拟阵解决最小生成树问题

**最小生成树问题：给定无向图$G=(V,E)$，保证所有顶点连通。要求从边集中恰好选出$\|V\|-1$条边构成一株树，并且保证所有边的权重和最小。**

首先我们先建立拟矩$(S,L)$。记录$S=E$。对于$S$的子集$X$，如果$X$中不出现可以构成环的边序列，那么$X\in L$。

显然$S$是有限集，且空集属于$L$。

很显然$L$是满足遗传性的，因为如果一组边不形成环，删除任意边后当然还是不会出现环的。

接下来我们证明$L$也满足交换性。考虑两个边集$A$,$B$，二者都是构成森林的边集合，且$\|A\|<\|B\|$。我们可以用下面流程找到可以加入$A$的$B\setminus A$中元素$x$。

1. 记$X=A$

2. 遍历$B$中元素，记当且遍历的边为$b$。
    
    2.1. 如果$b$加入$X$中后会出现环，此时环中一定会包含一条$A$中的边$a$，从$X$中删除$a$后并加入$e$。回到步骤2。

    2.2. 否则$b$加入$X$中不会出现环，那么此时我们直接得到了$x=b$。

由于$\|B\|>\|A\|$，因此这个流程一定会在2.2处结束。利用这个构造性算法我们可以保证$L$满足交换性。

到此我们证明了$(S,L)$是一个拟阵。下面我们来解决最小生成树问题。

由于我们掌握了求拟阵的最大权独立集的算法，我们可以应用到这里。要让和最小，等价于让和的相反数最大。对于边$i$，如果原本权重为$w(i)$，那么我们定义一个新的权重函数$w'(i)=\inf-w(i)$。其中$\inf$是一个足够大的常数，能够保证$w'(i)>0$。

很显然最大权独立集一定是极大独立集，而极大独立集的大小一定为$\|V\|-1$，能够正好构造一株树。而真实的权重为最大权独立集的权重减去$\inf \cdot (\|V\|-1)$后取反即可。

## 例子2：任务调度问题

**任务调度问题：给定$n$个任务，每个任务花费1单位时间，第$i$个任务要求在$t_i$时间之前完成，否则罚款$c_i$，问如何调度任务的处理顺序可以使得总罚款最小。**

首先我们建立拟阵$(S,L)$，记录$S$为任务集合。对于$S$的子集$X$，如果我们能够通过调度使得所有$X$中的任务都能在截止时间前完成，那么$X\in L$。

显然$S$是有限集，且空集属于$L$。

很显然如果$X$能够通过调度在截止时间前完全执行完，那么从中删除几个任务后，肯定能保证剩余的任务能全被执行完，因此遗传性得到满足。

现在考虑两个$L$中元素，$A$与$B$，其中$\|A\|<\|B\|$，现在我们希望能找出能加入$A$的$B\setminus A$的元素$x$。记录$A$中截止时间最晚的任务的截止时间为$t_A$，而$B$中截止时间最晚的任务的截止时间为$t_B$。如果$t_A<t_B$，那么将$x$就是$B$中截止时间最晚的任务。否则，我们有$t_A\geq t_B \geq \|B\| > \|A\|$，此时我们记录$x$为$B$中截止时间最晚的任务，可以发现在$x$加入$A$后，所有$A$中时间小于$t_B$的任务的执行顺序不变，时间大于等于$t_B$的任务都延迟一秒后执行。如果此时出现矛盾，即存在某个时刻$t\geq t_B$，满足排在它之前的任务数大于等于$t$，但是这就意味着$A\cup \{x\}$中至少包含$t+1\geq t_B+1\geq \|B\|+1$个任务，这与之前假设的$\|A\|<\|B\|$不符。到此，交换性得到证明。

之后我们考虑如何建立权重函数，要让罚款最小，而总罚款是固定的，等价于让按时完成的任务的总罚款最大，即我们可以选择每个任务的权重为其罚款。

之后我们只需要找到拟阵的最大权独立集即可。

# 前缀匹配问题

考虑下面问题：

**形态1：电影院有$n$个人和$n$把椅子，椅子编号为1到n，对于第$i$个人，他希望能坐在前$a_i$把椅子中的一把椅子上，不然他会不满意。现在要求我们安排这$n$个人的座次，要求不满意的人数最少。**

很容易看出，将人和椅子建立二分图，就是一个简单的二分图匹配问题。

但是，假如我告诉你$n=10^6$的时候，是不是就发现这问题不简单了。

观察一下这个问题与经典的二分图匹配问题有哪些区别，最重要的区别就是每个人能够匹配的椅子都是某个前缀。因此我们可以贪心地解决这个问题。

因此算法就得出来了，我们把所有人按$a_i$进行排序，之后从前往后遍历每一张座位，如果有座位在，我们让所有能坐在该座位上的人中$a_i$属性最小的人坐上去。（假如最优方案由编号更大的人坐在这里，我们交换两人座位方案依旧可行且最大匹配不变）



下面强化一下这个问题：

**形态2：电影院有$n$个人和$n$把椅子，椅子编号为1到n，对于第$i$个人，他希望能坐在前$a_i$把椅子中的一把椅子上，不然他的不满意值会变成$u_i$（如果满意则为0）。现在要求我们安排这$n$个人的座次，要求所有人不满意值最小。**

这个问题是带权二分图匹配，经典做法就是直接上最小费用最大流。但是这里的$n=10^6$，因此是不可行的。

实际上问题还是可以贪心解决。我们先对所有人按照$a_i$进行排序。之后扫描所有椅子，让所有能坐上这把椅子的人中$a_i$最小的那个人坐上。但是不同的是，当处理完第i把椅子后，我们需要考虑所有最后能匹配的椅子为i的人，他们该何去何从。我们会试图用他们替换已经坐上椅子中的人中$u_i$最小的那个，假如比我们现在手头的候选人的$u_i$更小，那么就替换它，否则我们的候选人将永远失去坐上椅子的机会。

*注意到算法只是用到了$u_i$属性的偏序关系，真实值并不会影响结果，而这一点会直接决定下一个问题的解法。*



下面考虑一下这个问题的变形：

**形态3：电影院有$n$个人和$n$把椅子，椅子编号为1到n，对于第$i$个人，他希望能坐在前$a_i$把椅子中的一把椅子上，或者坐在后$b_i$把椅子中的一把椅子上，不然他会不满意。现在要求我们安排这$n$个人的座次，要求不满意的人数最少。**

这个问题不仅存在前缀，还存在后缀，怎么解决呢。我们先分配前缀，再分配后缀座位。对于一个人，如果$b_i$越大，那么在分配前缀的阶段中，即使被淘汰，成本也越小。因此我们可以规定一个人被淘汰的费用为$-b_i$，那么分配前缀的过程实际上就是一个最小费用最大匹配，而分配后缀的过程就是一个普通的最大匹配。

**形态4：电影院有$n$个人和$m$把椅子，椅子编号为1到m，对于第$i$个人，他希望能坐在前$a_i$把椅子中的连续的$c_i$把椅子上，不然他会不满意。现在要求我们安排这$n$个人的座次，要求不满意的人数最少。**

这个问题中，一个人可以分配到不止一把椅子。我可以把第i个人占用的$c_i$个座位理解成为让他没有椅子坐的费用为$-c_i$。之后就是一个带权的前缀匹配问题了。

# CF1251E2

**题意**

[http://codeforces.com/contest/1251/problem/E2](http://codeforces.com/contest/1251/problem/E2)

**题解**

首先我们可以将这个问题转换为一般的前缀匹配问题形态2。第$i$个人在有$m_i$个人支持后费用位0，否则费用为$p_i$。转换为我们的问题，就是第$i$个人希望做前$n-m_i$把椅子，否则不满意度为$p_i$。这样就可以直接解决了。

# ARC076D

**题意**

[https://arc076.contest.atcoder.jp/tasks/arc076_d?lang=en](https://arc076.contest.atcoder.jp/tasks/arc076_d?lang=en)

**题解**

问题实际上就是前缀匹配问题形态3。

# Atcoder Zabuton

**题意**

[https://atcoder.jp/contests/cf17-final/tasks/cf17_final_d](https://atcoder.jp/contests/cf17-final/tasks/cf17_final_d)

**题解**

前缀匹配问题形态4

---
categories: problems
layout: post
---

- Table
{:toc}
# CF1175D

**题意**
[https://codeforces.com/contest/1175/problem/D](https://codeforces.com/contest/1175/problem/D)

**题解**

记S(i)=a(i)+a(i+1)+...+a(n)。分别记最优解的划分下，第i个分块的第一个元素下标为f(i)。那么问题下面式子在最优解下一定取最大值。


$$
1\cdot (S(f(1))-S(f(2)))+2\cdot (S(f(2)) - S(f(3)))\\+\ldots + (n-1)(S(f(n-1))-S(f(n)))+nS(f(n))\\
=\sum_{i=1}^nS(f(i))
$$


由于f(1)一定是取到1，我们可以将S(2),S(3),...,S(n)排序后取前面最大的k-1个的和加上S(1)就是结果。

# CF1175F

**题意**
[https://codeforces.com/contest/1175/problem/F](https://codeforces.com/contest/1175/problem/F)

**题解**

我们可以逐个统计每个有效子排列。寻找所有1出现的位置，很显然一个有效排列必定包含且只保护其中之一的1。

我们维护一个函数R，R(i)表示形如a(i),a(i+1),...的无重复元素的最长序列的长度。

之后我们遍历每个1出现的位置i。之后包含i的序列的右边界只可能为j=i,i+1,..., i+R(i)-1。之后假设序列中最大的元素落在i的右边，因此我们只需要知道m=max(a(i),a(i+1),...,a(j))，而序列有效的必要条件是长度等于m，因此我们可以推出左边界k=j-m+1。之后只需要快速判断子序列a(k),...,a(j)是否是一个有效序列就可以了。判断的方法很简单，首先要求R(k)>=max，其次min(a(k),...,a(j))=1且max(a(k),...,a(j))=m。

对于最大元落在左边的情况，只要翻转序列后重新用上面过程处理一次就可以了。

利用线段树就可以在O(nlogn)的时间复杂度内解决。

# BZOJ1345

**题意**
[https://www.lydsy.com/JudgeOnline/problem.php?id=1345](https://www.lydsy.com/JudgeOnline/problem.php?id=1345)

**题解**

很显然最后留下的是序列中的最大值。选择最大值，处于最大值左侧区间中的最大值最后只能与全局最大值合并，对于右侧同理。这提示了我们可以以全局最大值为根建立一棵树，根的左节点是左侧区间最大值，右节点是右侧区间最大值。建树可以通过递归实现。而对于每个结点，其提供的费用是结点对应的值乘上结点的子节点数目，汇总所有结点的费用就是结果。

还有注意如果你利用递归建树，那么就需要用到一些平衡树结构，这样时间复杂度为$O(n\log_2n)$。但是实际上我们建出的是一个树堆，而建立树堆是可以通过单调栈实现的，这样时间复杂度就优化到了$O(n)$。

# BZOJ1816

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1816](https://www.lydsy.com/JudgeOnline/problem.php?id=1816)

**题解**

如果能组成k+1副牌，那么组成k副牌肯定不是难事。因此二分可以组成的牌数。

如果组成k组牌，需要x张joker，x满足x<=k且x<=m，那么我们就一定能组成k组牌。

# BZOJ1863

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1816](https://www.lydsy.com/JudgeOnline/problem.php?id=1816)

**题解**

对于分配给将军1的奖牌，我们称为特殊奖牌。假设我们我们造好了k种颜色，那么是不是存在一种符合需求的分配方案。这里可以用贪心的方法，对于将军i，如果i与n同奇偶性，则分配尽可能少的特殊奖牌，否则分配尽可能多的特殊奖牌。如果最后将军n得到了至少一个特殊奖牌，那么方案不存在，否则存在。

贪心也可以替换为动态规划，记f(i)、g(i)表示分配前i个人后，第i个人可以得到最多多少特殊奖牌以及最少多少特殊奖牌。这里不考虑第1个人和第n个人的邻接关系。很显然$f(i)=\min(a_1-g(i-1), a_i)$，$g(i)=\max(0, a_i-(k-a_1-(a_{i-1}-f(i-1))))$。如果$g(n)>0$那必定无解，否则有解。

由于方案的存在性随着k的增加递增，因此可以用二分法优化。

# BZOJ3293

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=3293](https://www.lydsy.com/JudgeOnline/problem.php?id=3293)

**题解**

咋一看，最小费用最大流。但是看看数据量，10w级别，再见。

这个问题可以转换为另外一个耳熟能详的形式。记$s_i$表示第i个人初始的金币，$x_i$表示第i个人给后面那个人的金币数，记t为平均金币。那么在进行交换后，第i个人持有的金币应该满足：


$$
s_i+x_{i-1}-x_i=t
$$


$x_1$一旦确认，其他几个未知变量也会对应确认。将所有的变量用$x_1$来表示，可以得出：


$$
x_i=\sum_{j=2}^i(s_j-t)+x_1
$$


我们要做的就是最小化式子


$$
\sum_{i=1}^n|x_i|=\sum_{i=1}^n|\sum_{j=2}^i(s_j-t)+x_1|=\sum_{i=1}^n|x_1-p_i|
$$


这个问题，可以转化为这样的形式：在x轴上放置n个点$p_1,p_2,\ldots ,p_n$，要求我们选择一个点，这个点到其它所有点距离和最小。

很显然无论在哪个位置，当$x_1$向中点靠近时，距离和会递减。因此我们可以选择$x_1$为中点即可。

# BZOJ1150

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1150](https://www.lydsy.com/JudgeOnline/problem.php?id=1150)

**题解**

比较奇怪的一道题。很容易发现电线只会连接邻近的两个点，我们可以根据点下标的奇偶性生成二分图，之后要求的实际上是这副二分图上的最小费用最大流。但是数据量有点大，费用流是过不了的。

仔细观察，可以发现这幅二分图是很特殊的，每个顶点的度都不超过2。我们知道费用流是不断找最短费用路进行增广，最短费用路在这里一定是交错路，我们可以动态维护所有的路径，再手动模拟增广，就可以在不使用费用流算法时达到费用流的效果。

我的方法的时间复杂度是$O(n\log_2n)$。记$d_t$表示第$t$与$t+1$的距离，那么从$i$到$j$的交错路的费用为$\sum_{k=i}^{j-1}(-1)^{k-i}d_k$，这个可以通过前缀和技术预先处理。之后我们将所有的路径维护在一个树集中，并维护一个左结点的可行点集合和右结点的可行点集合。每次我们增广后，都可能会向路径集合增加四条路径。

# BZOJ1053

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1053](https://www.lydsy.com/JudgeOnline/problem.php?id=1053)

**题解**

要计算一个数$x$的因子数，我们需要先利用算术基本定理将其分解为若干个不同的素数的幂的乘积。


$$
x=p_1^{c_1}\ldots p_k^{c_k}
$$


而$x$的因子数可以表示为$g(x)=\prod_{i=1}^k(1+c_i)$。

而我们要找的是小于等于N的因子数最多的x，如果有多个拥有相同因子数的数，那么需要取最小的。很显然要让因子数尽可能多，那么我们可以选择较小的几个素数组成x，实际上较小的素数可以获得的x也是较小的，这与我们目标吻合。

这里只需要小于等于23的所有素数即可，之后深搜暴力，时间复杂度这种东西不重要。

# BZOJ1112

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1112](https://www.lydsy.com/JudgeOnline/problem.php?id=1112)

**题解**

枚举所有可能的区间，共n-k+1种。之后对于每个区间，我们将其中的高度从小到大排序，而在最终高度取到区间高度的中位数时费用最小。

因此用平衡树维护一下区间，之后找一下中位数就好了。

# TIMUS1032

**题意**

[http://acm.timus.ru/problem.aspx?space=1&num=1032](http://acm.timus.ru/problem.aspx?space=1&num=1032)

**题解**

组合数学书上一道用于介绍鸽巢定理的例题。如果以前没看过，我应该也做不出来。

首先给出n个值a1,a1+a2,...,a1+a2+...+an，如果其中有一个模n为0，那么就找到了解。否则由于有n个值落在1~n-1之间，因此至少有两个数有相同值，找到这两个数，其中一个必定是另外一个的前缀，从较长的序列中移除较短的序列那部分就找到解了。

# BZOJ1025

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1025](https://www.lydsy.com/JudgeOnline/problem.php?id=1025)

**题解**

记$f(x,y,n)$表示将边长为x，y的矩形分给n个人的最优解。容易知道


$$
f(x,y,n)=\min(\\
\min_i(\max(f(x\cdot \frac{i}{n},y,i),f(x\cdot \frac{n-i}{n},y,n-i))),\\
\min_i(\max(f(x,y\cdot \frac{i}{n},i),f(x\cdot \frac{n-i}{n},y\cdot \frac{i}{n},n-i)))\\
)
$$


记$T(n)$表示执行形如$f(x,y,n)$所需要的时间。那么有


$$
T(n)=2nT(n-1)+1=\ldots\approx 2^n\cdot n!
$$


注意到


$$
\max(f(x\cdot \frac{i}{n},y,i),f(x\cdot \frac{n-i}{n},y,n-i))
=\max(f(x\cdot \frac{n-i}{n},y,n-i),f(x\cdot \frac{i}{n},y,i))
$$


我们在遍历$i$时，只需要遍历$1~\frac{n}{2}$。利用这个优化可以得到修正后的时间复杂度：


$$
T(n)=nT(n-1)+1\approx n!
$$


由于n只能取到10，而$10!=3628800$，因此足够通过题目了。

# BZOJ1029

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1029](https://www.lydsy.com/JudgeOnline/problem.php?id=1029)

**题解**

解法是贪心，我们先对t2按从小到大排序，之后按序处理所有建筑。

1. 如果还有多余的时间分配给当前建筑用于修复，那么就修复建筑。
2. 否则如果之前修复的建筑的中修复时间最长的建筑的修复时间多余当前建筑的修复时间，则取消对该建筑的修复，转而将时间分配给当前建筑。
3. 否则，就跳过当前建筑。

在处理完第i个建筑后，得到的策略是能修复最多建筑的策略中花费总时间最少的。如果单独将策略中前k个费用最小的建筑提出来，那么提出来的建筑会组成新的策略，是处理完前i个建筑后，共修复k个建筑且费用最小的策略。

# BZOJ1106

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1106](https://www.lydsy.com/JudgeOnline/problem.php?id=1106)

**题解**

记i的出现的左边坐标为l(i)，右边坐标为r(i)。

那么如果l(i)<l(j)<r(j)<r(i)，那么先消除j会让之后消除i少交换两次，而先消除i并不会减少j消除需要的交换次数。其余的值对没有明显先后要求。

我们可以对r(i)-l(i)的大小对所有的值对位置进行排序，从区间较小的开始消除就可以了。

# LUOGU5419

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=5419](https://www.lydsy.com/JudgeOnline/problem.php?id=5419)

**题解**

首先题目上已经给出了最短上升路径的下界，n-1。下面就需要我们构建这样一个可能的完全图。

如果我们能将n(n-1)/2条边均分为n个不相交子集，每个子集大小为(n-1)/2，且相同子集中的边不共享端点。这样我们为相同的子集中的边分配连续的权重，就能保证每次移动都会经过不同子集中的边，从而保证最多移动n-1次，即最长上升路径的长度为n-1。

下面我们考虑分组的策略。

考虑n是奇数的情况，首先我们建立一个顶点序列\[1,2,...,n\]，之后我们构建第一个子集，加入边(2,n),(3,n-1)...之后我们旋转序列一个单位，得到[n,1,2,...,n-1]，之后用类似的方法构建第二个子集，加入边(1,n-1),(2,n-2)...。重复上面过程直到构建了n个子集。可以证明每个子集的大小都是(n-1)/2，且子集中的边无公共端点。接着考虑顶点u，v。由于u、v在序列中的距离一端为奇数，一端为偶数，边(u,v)被处理仅在u、v为奇数一端的中间顶点作为序列起点的时候才会发生，且仅发生一次。这样我们就得到了n个满足条件的大小为(n-1)/2的分组了。

现在考虑n是偶数的情况，先处理1~n-1顶点（奇数个顶点），得到n-1个满足条件的大小为n/2-1的分组后，考虑每个分组，向分组中加入缺少的那个顶点和顶点n组成的边之后，我们就得到了n-1个满足条件的大小为n/2的分组。

# LUOGU1729

**题意**

[https://www.luogu.org/problem/P1792](https://www.luogu.org/problem/P1792)

**题解**

神奇脑回路题。

维护一个双端链表表示环，每次从双端链表中取权重最大的顶点（用堆优化），同时移除它的前驱和后继。

假设被移除的顶点为y，y的前驱为x，后继为z。那么我们能保证必定存在一个最优方案S，其要么包含y，要么同时包含x和z。先假设S不包含x、y、z，那么我们知道S中一定有权重比y小的顶点，我们将其替换为y可以得到更大的总权，因此不可能。若y出现，那么很显然x、z一定不出现与S，下面考虑y不出现的情况。由之前的证明知道x、z至少出现一个，假如仅出现一个，那么可以直接将出现的那个替换为y得到更优解，因此x、z一定成对出现。

考虑到上面提到的内容，我们已经处理了y出现的情况，但是并没有考虑x与z同时出现的情况。我们可以将x、y同时出现的情况作为一个新的结点w替换x、y、z，同时w的权值为x-y+z（因为我们弹出y时已经加上了y的权值，这里换成x、z同时出现的策略，那么总权需要先减去y之后加上x+z）。

# LUOGU3620

**题意**

[https://www.luogu.org/problem/P3620](https://www.luogu.org/problem/P3620)

**题解**

同LUOGU1729。

很显然最终结果中电线只会连接相邻的大楼。

首先我们可以将电线视作点，那么问题就变成了给出若干个带权的点组成的链表，允许选取k个不相邻的点，问最小可能总权值。

我们可以加入一条权值为无穷的点，这个点连接链表的头尾，这样就形成了环。之后就和LUOGU1729一致了。

# LUOGU4131

**题意**

[https://www.luogu.org/problem/P4131](https://www.luogu.org/problem/P4131)

**题解**

首先因为$a\|b-c\|=\|ab-ac\|$，所以可以将$C_i$直接乘到对应的属性里。

接下来考虑到$\|x-y\|\geq x-y$，因此我们可以直接暴力枚举前k-1个属性的符号，来获得前k-1个属性和的上界。

但是第k个属性的符号是负数，而我们没有技术可以枚举其上界怎么办？我们注意到存在遍历顺序，我们可以提前将生物按照第k个属性排序后，按序逐一处理生物，这样就能直接使用减法而不用考虑绝对值问题了。

# LUOGU4528

**题意**

[https://www.luogu.org/problem/P4528](https://www.luogu.org/problem/P4528)

**题解**

观察公式：


$$
f(1324)-f(1243)-f(1432)\\
=(f(1x2x)-f(1423))-f(1432)-f(1243)\\
=f(1x2x)-f(14xx)-f(12xx)+f(1234)\\
=f(1x2x)-f(1xxx)+f(13xx)+f(1234)
$$


最后得出的就是我们要算的。

- f(1x2x)，考虑将第i个值作为2，难点在左边元素的计数，首先统计i左边的小于$y_i$的数的数目c，并统计这些数的下标和s，左边的序列数目应该为$c(i-1)-s-{c \choose 2}$。
- f(1xxx)，非常简单
- f(13xx)，考虑价格第i个值作为3，4的可选值为i右边大于$y_i$的数的数目。现在仅考虑2对应的值，我们需要统计形如$a<i<b,y_a < y_b < i$的数对数目，这个用线段树可以完成，只需要注意到每当i自增1时，实际上带来的影响可以通过线段树批量操作快速完成。
- f(1234)，这个就是一般的统计长度为4的递增序列问题。用线段树统计即可。

# LUOGU4643

**题意**

[https://www.luogu.org/problem/P4643](https://www.luogu.org/problem/P4643)

**题解**

将边权平摊到顶点上，之后统计的时候能保证二者的差值不变。

# Codeforces1209B

**题意**

[https://codeforces.com/contest/1209/problem/B](https://codeforces.com/contest/1209/problem/B)

**题解**

我做的顺序是D、A、C。。。B。这道题还是有点东西的。

一开始看，以为是中国余数定理（怎么可能，C还是一个贪心呢，B怎么可能）。后来搞了搞贪心，没搞出来。最后实际一看，a、b范围很小，只有5。

实际上问题非常简单，由于b范围很小，那么我们可以保证灯下一次亮的时间不会超过10。而a范围很小，我们可以推出灯亮的间隔不会超过10。因此10秒之后，L=lcm(2,4,6,8,10)是所有灯状态的一个周期。因此我们只要暴力枚举到130左右，就能遍历所有可能了。

当然保险起见，枚举个10000也未尝不可。

# Atcoder jsc2019_qual_c

**题意**

[https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_c](https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_c)

**题解**

挺难的题。

首先我们注意到操作顺序不重要。

之后还需要注意到对于两次操作(l1,r1),(l2,r2)，等价于(l1,r2),(l2,r1)。

现在我们需要为每个操作分配一个L、R属性，分配到L的表示其作为操作左端点，R的表示作为操作右端点。

继续观察发现如果一个i位置为L，那么i和i-1在所有操作完成后具有不同的颜色（原本相同变作不同，原本不同变作相同）。如果位置j为R，那么j和j+1在所有操作完成后具有不同的颜色。当然如果两个相连的位置为RL，那么就会相互抵消，两者颜色保留。

通过上面观察我们找到了一个唯一分配L，R的方案，利用这个思路$O(n)$内可以分配LR。

之后为了统计操作数，我们首先要找出左右括号的配对可能数。之后结果还要乘上$n!$，作为操作执行顺序对结果的贡献。

# Atcoder agc037_b

**题意**

[https://atcoder.jp/contests/agc037/tasks/agc037_b](https://atcoder.jp/contests/agc037/tasks/agc037_b)

**题解**

感觉很神奇的题目。这个题目可以继续推广出去，但是解法是相同的。

我们先先考虑只有两种颜色时的情况。假设只有颜色为黑色和白色的两种颜色的球的长度为2n的排列，每个球赋予不同的权值。

我们将黑球的权值从小到大记作
$$
B_1,B_2,\ldots,B_n
$$
，之后将白球权值从小到大记作
$$
b_1,b_2,\ldots,b_n
$$
。现在记
$$
m_i=\min\{B_i,b_i\}
$$
，同时记
$$
M_i=\max\{B_i,b_i\}
$$
。记录$x_i$为实际与$B_i$配对的白球。

当我们分别将$b_i$和$B_i$进行配对时，得到了一个解：
$$
\sum_{i=1}^nM_i-m_i
$$
。下面我们证明这就是最优解：

首先假设我们要构造一组分配
$$
(x_1,y_1),(x_2,y_2),\ldots,(x_n,y_n)
$$
，希望使得该公式最大：
$$
\sum_{i=1}^n\min\{x_i,y_i\}
$$
。不妨认为$m_1=B_1$，那么与$B_1$配对的白球的最好的选择就是$b_1$（假设是其它的，我们可以用其于$b_1$交换，这样结果只大不小）。重复这个过程，我们发现正好满足：
$$
\min\{x_i,y_i\}=m_i
$$
。同理我们可以证明要使得
$$
\sum_{i=1}^n\min\{x_i,y_i\}
$$
最小，只需要令
$$
\max\{x_i,y_i\}=M_i
$$
。因此对于任何的配对(x_i',y_i')，都有：


$$
\sum_{i=1}^n|x_i'-y_i'|\geq \min_{x,y}\sum_{i=1}^n\max\{x_i,y_i\}-\max_{x,y}\sum_{i=1}^n\min\{x_i,y_i\}=\sum_{i=1}^nM_i-m_i
$$


现在我们可以简单推广到任意多颜色的情况。假设有$m$种颜色，记第$i$种颜色第$j$次出现的下标为
$$
I_{i,j}
$$
。那么最小的配对差为：


$$
\sum_{i=1}^n\max_k\{I_{k,i}\}-\min_k\{I_{k,i}\}
$$


下面说一下怎么统计最小差的配对方案数目。将求球类为三类，若
$$
I_{i,j}=m_i
$$
，那么称$I_{i,j}$为第一类点，若
$$
I_{i,j}=M_i
$$
，那么称$I_{i,j}$为第二类点，否则称为第三类点。问题要求我们统计有多少种配对方案，对于一个配对$(a,b,c)$，要求三者颜色不同，且a是第一类点，c是第二类点，b是第三类点。

在这个问题场景中，我们会发现，只要三类点一出现就会和唯一颜色的一类点匹配，从而保证一类点颜色唯一。而三类点一出现，就必定和另外两个点匹配。因此可以贪心地从左往右扫描，记录r、g、b、rg、rb、bg的出现次数，每种可能都要乘到结果中去。最后结果还要乘上n!，表示匹配和人的关系。

# Atcoder AGC003E

**题意**

[https://atcoder.jp/contests/agc003/tasks/agc003_e](https://atcoder.jp/contests/agc003/tasks/agc003_e)

**题解**

首先如果对于连续的两次请求，后一次请求的$q_i$小于前面一次请求$q\_{i-1}$，那么请求$q\_{i-1}$不会对最终的统计带来任何影响，我们可以将其从请求队列中剔除。

因此最终保留下来的请求一定是一个严格递增序列，我们记作：
$$
q_1,q_2,\ldots,q_m
$$
。

这个问题非常神奇的一点是我们可以反向统计。首先我们知道最终的请求$q\_m$完成后序列的长度为$q\_m$，我们维护一个数组$C$，$C\_i$表示请求i完成后的结果序列对于最终结果的贡献。

算法流程如下：

当扫描第i个请求时，我们知道它的贡献为C_i，我们维护一个数h，它初始值为$q\_i$，那么我们从$i-1$反向扫描所有请求，记扫描到第$j$个请求，如果$q\_j\leq h$，那么就将C_j$增加
$$
\lfloor h/q_j \rfloor C_i
$$
，并将$h$减少为$h\mod q_j$。重复这个流程。

最后如果$h$非0，那么我们可以建立另外一个数组$P$，其中$P_i$表示初始序列长度为$i$的前缀对最终结果的贡献。

重复这个流程，最终$i$在最终结果中出现的次数为
$$
\sum_{k=i}^nP_i
$$
。

由于$h$每一次改变，都会至少减少一半，因此可以推断出$h$最多改变$\log_2q_i$次，而且由于查询时严格增的，因此可以利用二分来查找下一个会使得$h$改变的请求，总的时间复杂度为
$$
O(n\log_2n\log_210^{18})
$$
。

# ARC072E

**题意**

[https://atcoder.jp/contests/arc072/tasks/arc072_c](https://atcoder.jp/contests/arc072/tasks/arc072_c)

**题解**

考虑修改$d_i$，假设此时我们的位置为$p_i$，那么我们可以通过修改距离使得之后的距离处于$0$到$p_i$之间。如果我们知道当处理第$d_{i+1}$时，存在某个距离x，当处于距离x时无法抵达终点。那么，这意味着假如我们在第i步结束时移动到x，那么最终就能不抵达终点。

注意这样的x可能会有很多，但是只需要维护最小的那个就可以了。

# 二维网格放置1x2和2x1方块问题

有一个n行m列的二维网格，你有a个1x2的方块和b个2x1的方块。问是否可以将这些方块不相互覆盖全部放置到网格上。

这是atcoder的一道[题目](https://atcoder.jp/contests/agc021/tasks/agc021_c)。

这个问题我也没法太清晰地证明，就只是讲讲做法就好了。

首先我们可以很自然地将两个1x2方块或两个2x1方块合并为一个2x2方块，这不是什么难事。

当n和m都是偶数的时候，将2x2的方块往上丢就可以了。

之后考虑当m为奇数的时候，我们可以将最左边那一行先用2x1的方块覆盖。

分两种情况讨论，若n是偶数，那么这意味这最左边那一行可以被完全覆盖（除非$2a<n$）。这种情况下问题就变成了在n行(m-1)列网格放置的问题。

同样如果n是奇数、m是偶数，问题也是同样解决。

下面说一下n是奇数、m是偶数的情况下。这时候不管如何放置都会出现至少一个空位。我们先将最左边那一列用2x1的方块覆盖，最上面的那一列用1x2的方块覆盖，当然我们最后一定会留出至少一个空位，推荐将空位让给第3行第1列。比如考虑5行3列的情况。

```
^<>
v..
...
^..
v..
```

我们要的效果就是这样。说一下这样的好处。当剩下的a和b都是奇数的情况下，原先我们会浪费1个2x2的空格。

```
^<>
v<>
...
^^.
vv.
```


但是，这里我们可以避免2x2空格的浪费，考虑下面的方法：

```
^<>
v.^
<>v
^..
v..
```

因此，当a为4，b为3的时候，正确的做法如下：

```
^<>
v.^
<>v
^<>
v<>
```

# Codeforces1110E

**题意**

[https://codeforces.com/contest/1110/problem/E](https://codeforces.com/contest/1110/problem/E)

**题解**

很简单的题，只需要注意到对于连续的三个数字$c_{i-1},c_i,c_{i+1}$。对$c_i$进行操作后得到$c_i'=c_{i-1}+c_{i+1}-c_i$。

容易注意到$c'_i-c_{i-1}=c_{i+1}-c_i$，而$c_{i+1}-c'_i=c_i-c_{i-1}$。

我们可以记录$d_i=c_i-c_{i-1}$，那么操作实际上，会互换$d_i$和$d_{i+1}$，其它的不变。因此这个问题实际上就是问，允许任意次交换相邻d序列元素，能否使得$c$的d序列最终转换为t的d序列。xjb写吧。

# Codeforces1183F

**题意**

[https://codeforces.com/problemset/problem/1183/F](https://codeforces.com/problemset/problem/1183/F)

**题解**

首先由于不能选择相同的数，因此，我们可以在重复的数中仅保留唯一的。

现在来考虑怎么解决这个问题。

首先我们可以暴力枚举每个数$i$，以及以$i$作为选取最大值的所有方案的最大和。

在已知$i$是方案中最大的数的前提下，我们可以继续枚举第二大的数。我们找到比$i$小且不是$i$的因子的最大的数$j$。

接下来我们证明以$i$作为最大值的所有方案中和最大的方案，一定同时包含$j$。为啥呢，因为如果不含$j$，那么就必定包含另外两个数$a$，$b$，且$a,b<j$。由于$a,b$不能与$j$共存，因此$a$,$b$都一定是$j$的因子，即$a+b\leq j(\frac{1}{2}+\frac{1}{3})<j$。而这个方案还不如直接选择$i$,$j$来的好，因此假设不成立。

那么现在我们直到$i$,$j$必选了，最后一个数选啥呢，当然选能选的里面的最大的就可以了。

这个问题，每个数最多有$\sqrt{n}$个因子，因此时间复杂度为$O(n\sqrt{n})$。

# Codeforces1144G

**题意**

[https://codeforces.com/problemset/problem/1144/G](https://codeforces.com/problemset/problem/1144/G)

**题解**

我一开始写的是DP的做法，用线段树优化。

后来发现有一位大佬提了个贪心的做法，果然好用。算法非常简单，维护两个列表，一个递增，一个递减。之后从前往后处理$a_i$，如果$a_i$不能放入任意一个列表中，就无解。否则若仅能放入一个列表中，就放到允许的列表中即可。否则，我们根据$a_{i+1}$来做决定，若$a_i<a_{i+1}$，那么就将$a_i$放入递增列表，否则放入递减。

可以证明如果有解，上面算法一定能找到一组解。事实上，仅考虑最后一种情况，若最优结果中，$a_{i+1}$放入递增列表，那么直接我们发现对$a_i$的处理是不会影响最终解的。当然如果我们把$a_{i+1}$放入递减列表，那么我们自然只能间$a_i$放入递增列表。因此可以证明最后一种操作是最优的。

# Codeforces1137D

**题意**

[https://codeforces.com/problemset/problem/1137/D](https://codeforces.com/problemset/problem/1137/D)

**题解**

神奇的解法，以前确实做过类似的龟兔赛跑来判环的方法，但是确实从来不知道用三个棋子，3(t+c)步就可以得出t和c的所有信息。

首先，我们可以用棋子0和棋子1做龟兔赛跑，棋子0每次走两步，棋子1每次走一步。直到二者在环上距离入口x处相遇。这时候0走的距离为$t+x+kc$，1走的距离为$t+x$（1肯定没有走完整个循环）。而由于0走的距离是1的两倍，因此可以推出：$t+x=0\mod c$。这意味着当我们将所有棋子每次都向前移动一步，那么至少需要t步才能保证所有棋子都走到循环的入口，同时t步也正好能保证所有棋子来到循环的入口。

# CF1097D

**题意**

[https://codeforces.com/contest/1098/problem/D](https://codeforces.com/contest/1098/problem/D)

**题解**

这是一个大鱼吃小鱼的问题。我们将所有鱼按重量从轻到重进行排序，重量记作$a_1,a_2,\ldots,a_n$。现在如果有一条鱼$a_t$，满足$2\sum_{i=1}^{t-1}a_i<a_t$，那么我们称$a_t$为胖子。下面我们需要证明最重要的一个定理：

最大危险数等于$n-k$，其中$k$为序列中的胖子数。我们利用归纳法进行证明。

当序列中只有第一个数是胖子时，总共发生$n-1$次战斗，因此我们只需要证明存在一种方案，使得$n-1$次战斗都危险即可。

考虑这样的算法，每次都选择最小的两条鱼战斗。我们可以用归纳法证明这一步，只有两条鱼时命题显然成立。假设现在有$k>2$条鱼。我们将最小的两条鱼合并，同时将合并后的鱼插入到序列中，假设新的序列为$a_1',a_2',\ldots,a_i',\ldots,a_{k-1}$。其中$a_i'$为合并后的鱼。我们需要证明此时只有$a_1'$是胖子。由于$a_2'\leq a_3'\leq \ldots \leq a_i'\leq 2a_1'$，因此$a_2',a_3',\ldots,a_i'$中没有胖子存在。而对于任意数$a_j'$，其中$j>i$，由于所有小于它们的和不变，因此也不是胖子。现在我们证明了当只有第一只鱼是胖子，最大危险数等于$n-1$。

现在考虑胖子数$t$多于1的情况，这时候我们将重量第二小的胖子之前的鱼全部安排战斗，将战斗后活下来的鱼与这个胖子战斗，得到的新序列胖子数会减少1，一场战斗是不危险的。利用归纳法可以得出存在一种战斗方案，危险数等于$n-t$。

但是我们还没有证明$n-t$是一个上限。可以发现对于某个胖子$a_i$，要让$a_1,a_2,\ldots, a_{i-1}$中至少一个鱼与$a_i,a_{i+1},\ldots,a_n$中某条鱼合并，至少需要加入一场不危险的战斗。因此我们可以断定$n-t$是一个上界。

接下来我们要处理的问题就是：

- 删除一个数
- 插入一个数
- 计算有多少个数，其前缀和的两倍小于自己

这个问题貌似还是不能解决。但是我们可以将区间划分为$\[2^0,2^1),\[2^1,2^2),\ldots,\[2^{29},2^{30})$，能够发现每个区间中最多有一个胖子（且一定是区间中最小的数），因此可以维护$30$个平衡树统计一下即可。

# Codeforces 1268B

**题意**

[https://codeforces.com/contest/1268/problem/B](https://codeforces.com/contest/1268/problem/B)

**题解**

有一个高度非严格单调减的直方图，希望放置尽可能多的1x2或2x1的多米诺骨牌上去。

首先我们将直方图看成一个棋盘，并对其进行染色，将所有网格染成黑色或白色，且黑色和白色不相邻。

之后我们记黑色的数目为$B$，白色的数目为$W$。

下面我们用归纳法证明结果为：$\min(B,W)$。

在网格总数为0、1的时候结果当然是0，满足命题。之后我们记棋盘第$i$行的长度为$b_i$，第$j$列的高度为$a_j$。如果存在某个下标$j$满足$a_j=a_{j+1}>a_{j+2}$。我们将第$j$列和第$j+1$列的最顶部的两个网格放置一个多米诺骨牌。这样利用归纳法可以推出结果为$\min(B-1,W-1)+1=\min(B,W)$。如果不存在这样的列，就考虑行。下面认为没有两列或两行相同，那么此时一定满足$a_i=n-i+1$。这时候一定有$B-W=\lceil\frac{n}{2}\rceil\geq 1$。我们可以直接删除第一列最顶部的黑色网格，此时依旧满足$\min(B,W)=\min(B-1,W)=W$。因此命题成立。

# 选择商品问题

**问题1：有$n$类商品，第$i$类商品有$c_i$件。现在你必须从这些商品中选择$k$件商品。假设第$i$类商品我们选择了$a_i$件，那么我们的收益为$\sum_{i=1}^na_i(c_i-a_i)$，问最大收益是多少。其中$n\leq 10^5, 1\leq k\leq \sum c_i\leq 10^5$**

记录$f(x)=x(c-x)$，那么可以发现$f'(x)=c-2x$是单调减少的，因此有$f(x)-f(x-1)>f(x+1)-f(x)$。于是我们可以将第$i$类商品分成$c_i$个商品，分出的第$j$种商品的收益为$j(c_i-j)-(j-1)(c_i-(j-1))$。之后贪心选择最大的$k$件商品即可。

**问题2：有$n$类商品，第$i$类商品有$c_i$件。现在你必须从这些商品中选择$k$件商品。假设第$i$类商品我们选择了$a_i$件，那么我们的收益为$\sum_{i=1}^na_i(c_i-a_i)$，问最大收益是多少。其中$n\leq 10^5, 1\leq k\leq \sum c_i\leq 10^9$**

和问题1类似，但是数据范围大了很多。我们发现随着选择次数的增加，选择的所有商品中收益最小的商品的收益一定递减，因此我们可以二分收益最小的商品的收益，每次二分检查的时间复杂度为$O(n\log_2M)$，因此总的时间复杂度为$O(n(\log_2M)^2)$，其中$M=\sum c_i$。

# 参考文献

- [【洛谷日报#181】拟阵与最优化问题](https://zhuanlan.zhihu.com/p/74887308)