---
categories: algorithm
layout: post
---

- Table
{:toc}
# 莫队算法

莫队可以用于解决一类区间离线统计问题。如果我们以经统计了$[l,r]$的信息，现在要统计$[l+1,r]$、$[l-1,r]$、$[l,r-1]$、$[l,r+1]$（这四种转移是基础转移），如果你能很快滴给出答案，那么就可以用莫队来优化离线区间查询。

假设我们现在有一段长度为n的序列，之后有m个查询，每个查询需要统计一段区间的信息。

下面我们首先按固定大小k进行分块，若请求的左边界为l，那么它会落在块$\lfloor \frac{l}{k} \rfloor$中。首先对查询预先进行排序，排序的第一关键字为查询所属的块，第二关键字为查询的右边界r。

之后我们按顺序处理每个请求，只不过在切换请求时我们复用上一个请求留下来的区间统计信息。比如现在区间为$[a,b]$，而查询的区间为$[l,r]$，我们可以通过四种基础转移将区间进行转换，需要执行$\|a-l\|+\|b-r\|$次转移。

下面我们来分析时间复杂度：

对于块号相同的查询，由于查询的右边界递增，因此右边界最多移动n次。总共有n/k个块，故最多移动$n^2/k$次。

对于块号相同的查询，由于每次切换查询时，左边界最多移动k次，共有m个查询，因此最多移动$km$次。

对于不同块的交界，切换时，我们左边界和右边界可能需要重置，这部分最多需要$2n$次基础操作，块最多切换$n/k$次，因此总共移动$2n^2/k$。

加总所需的时间费用，总共为$O(m\log_2m+km+n^2/k)$，当我们取$k=n/\sqrt{m}$时，此时时间复杂度为$O(m\log_2m+n\sqrt{m})$。

# 带修改莫队

我们可以将莫队修改成支持单点修改的形式。

设区间长度为n，区间查询与单点修改共m次。如何用莫队优化。

我们为查询引入版本的概念，一个查询的版本为在该次查询发生之前发生的修改次数。之后我们选取一个数k，并进行分块。对于查询，其左边界为l，右边界为r，版本为v，其属于分块$(\lfloor \frac{l}{k} \rfloor, \lfloor \frac{v}{k} \rfloor)$。定义块号的顺序为块号的字典序。首先我们需要对查询进行预先排序，排序的第一关键字为查询所处块号，第二关键字为查询的右边界。

之后按顺序处理查询。对于一个查询，如果版本号为上一个处理的查询不同，我们还需要应用或回退一些修改。

下面证明时间复杂度：

对于同一个块的查询，右边界最多移动n次，块数不超过$nm/k^2$，因此右边界总计移动$n^2m/k^2$。

对于同一个块中的查询，左边界和版本号最多分别变动k次，因此总共最多发生$2mk$次变动。

对于块之间的切换，每次左边界最多修改n，右边界最多修改n，版本最多修改m，因此总共发生$(2n+m)nm/k^2$次修改。

总的时间复杂度为$O(m\log_2m+3n^2m/k^2+2mk+nm^2/k^2)$。当我们取k为$n^{2/3}$时，得到时间复杂度$O(m\log_2m+n^{2/3}m+m^2/n^{1/3})$。

# 树上莫队

莫队可以扩展到树上。

对于子树查询，我们可以先计算树的dfs序，之后子树的dfs序一定是连续的，形成一个区间。那么实际上如果我们将结点按照dfs序铺平，那么子树查询就对应了普通的区间查询，直接可以上莫队。同样在这种情形下要支持单点修改，将普通莫队替换为带修改莫队即可。

还有一类比较神奇的应用是树上路径统计。我们知道一株树可以用括号序列来表示，比如(()())是一个根结点带两个叶结点。一个结点在其括号序列中对应两个括号，一个开括号一个闭括号。那么要查询从u到v的路径，我们这边假设u的左括号在v的左括号之前出现，那么可以发现在括号序列中，u的右括号到v的左括号之间仅u到v的路径上顶点的括号正好出现一次，其余顶点的括号要么成对出现要么不出现。因此我们可以认为一个顶点出现奇数次则包含入结果，否则从结果剔除。这里需要特别注意的是u和v的lca可能需要手动处理。

# BZOJ1146

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1146](https://www.lydsy.com/JudgeOnline/problem.php?id=1146)

**题解**

裸的待修改树上莫队。