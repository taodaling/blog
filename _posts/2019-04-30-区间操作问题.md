---
categories: problems
layout: post
---

- Table
{:toc}
# 根号优化

假设给我们一个长度为n的数组，要求支持区间更新，区间统计。

最简单的方式是将数组分块，每一块大小为$m=sqrt{n}$。之后我们为每一块都额外维护一份辅助信息，第i块的辅助信息记作$f(i)$。

现在考虑区间更新问题，只要利用惰性标记就可以实现$sqrt{n}$的时间复杂度。对于完全处于区间中的块，我们直接标记在辅助信息上（如果已经有标记了，就合并标记），这样的块最多有$sqrt{n}$个。而对于与区间有交集的却不被完全覆盖的块，我们先下推标记，之后直接暴力修改，可以得知这样的块不会超过两个，总的修改的元素不超过$2\sqrt{n}$个。

查询操作也是相同的，对于被完全覆盖的块，直接从辅助信息中提取，否则直接暴力查询，时间复杂度为$O(\sqrt{n})$。

# 线段树合并分裂

考虑一株权值线段树，即线段树区间$[x,x]$表示的是值为x的元素数目。（如果权值过大，可以提前离散化处理）

权值线段树最大的特点就是其可以表示一个排序好的数组，我们可以快速得到第k小的元素。

现在我们希望建立多颗权值线段树，并支持合并，分裂，建树操作。

考虑建树操作，由于线段树的数目比较多，因此需要动态开点来保证内存够用。建树操作的时间复杂度和空间复杂度为$O(\log_2K)$，K是值的范围。

接下来考虑分裂操作，按照第k小元素进行分裂，我们可以递归找到第k小元素，在查找的过程中进行分裂。分裂操作的时间复杂度和空间复杂度为$O(\log_2K)$

最后考虑合并操作，将两颗权值线段树合并，我们可以暴力进行合并，只是当一株树为空时则直接返回即可。

```java
Segment merge(Segment a, Segment b){
    if(a == NIL) return b;
    if(b == NIL) return a;
    //递归合并线段树a、b
}
```

由于每次递归调用merge都意味着会销毁至少一个顶点，而总的顶点数与建树次数n和分裂次数m有关，至多为$O((n+m)\log_2K)$。

因此总的时间复杂度为$O((n+m)\log_2K)$。

# sparse-table算法

## 区间最值

st算法可以用于计算区间最值，不同于其它区间最值查询算法，st算法单次查询的时间复杂度仅为$O(1)$。下面讲解st算法。

假设区间的范围为$[0,n]$。我们首先定义函数$f(i,j)$表示区间$[i,i+2^j)$的最小值。很显然我们可以给出递推公式：


$$
f(i,j)=min(f(i,j-1),f(i+2^{j-1},j-1))
$$


对于$i$，共有$0$到$n$总选择，而对于$j$，共有$0$到$\lfloor \log_2n \rfloor$种选择。总计对$f$的调用有$O(n\log2_n)$种可能，我们可以提前通过上面的递推公式以$O(n\log2_n)$的时空复杂度预处理得到。之后的所有$f$调用的时间复杂度都为$O(1)$，这也是st算法能够在$O(1)$时间复杂度内回答区间最小值的关键。

现在，假设我们要查询区间$[l,r]$的最小值。我们知道区间$[l,r]$的最小值，也就是$[l,r+1)$的最小值。记$k=\lfloor \log_2(r+1-l) \rfloor$，则$[l,r+1)$的最小值必定是$[l, l+2^k)$的最小值和$[r+1-2^k,r+1)$的最小值中的较小者，即$min(f(l,k), f(r+1-k,k))$。

上面的操作几乎可以认为是$O(1)$了，美中不足的是我们需要计算$\lfloor \log_2(r+1-l) \rfloor$。一般对于这种操作，各种语言都提供了接近$O(1)$的奇技淫巧，但是如果追求严格，可以以预先处理的方式以$O(n)$的时空复杂度计算$\lfloor \log_2x \rfloor$，其中$x=1,2,\ldots,n+1$。这样对数向下取整也能保证以$O(1)$的时间复杂度得到。

上面预处理的总的时间复杂度和空间复杂度均为$O(n\log_2n)$，而每次查询区间最值仅需要$O(1)$的时间复杂度。

## LCA

LCA问题可以转换为区间最值问题，之后利用st算法就可以高效求解了。

首先我们对树进行深度优先搜索，当第一次访问结点$u$时，将$u.enter$记录为当前时间戳。之后比较特殊的是，在访问$u$时，我们首先将$u$加入某个列表尾部，之后每次访问$u$的子结点返回后，都要将$u$再次加入列表尾部，访问$u$完毕后将$u.leave$设置为当前时间戳。

第一次将$u$加入该列表尾部的费用由$u$支付，之后每次访问某个结点$v$后再次加入$u$的费用由边$(u,v)$支付，每次支付的费用为1，而一株大小为$n$的树中，结点数目为$n$，边的数目为$n-1$，因此最终搜索完毕后列表的大小为$2n-1$。

```java
void dfs(root){
    root.enter = list.size();
    list.add(root);
    for(Node child : root.children)
    {
        dfs(child);
        list.add(root);
    }
    root.leave = list.size() - 1;
}
```

接下来，每次查询结点$x=lca(u,v)$，等价于查询list区间$I=[min(u.enter,v.enter), max(u.leave, v.leave)]$中$enter$值最小的哪个结点。这就是我们上面聊到的区间最值问题。

下面证明一下下面几点：

1. 区间$I$中一定包含$u$与$v$的$x$。
2. $x$是区间$I$中拥有最小$enter$值的结点。

如果$u=v$，落在区间$I$中的结点都是$u$的子结点，因此两条命题都是满足的。下面都认为$u.enter < v.enter$，由于$x=lca(u,v)$，那么可知$u$和$v$分别处在$x$下不同的两个子树中，因此在从含$u$的子树中递归返回后，$x$会被加入到列表尾部，之后会访问$v$，很显然命题1是满足的。并且在$x$返回之前，中间不会加入其它$x$的祖先结点，即$x$是拥有最小$enter$值节点，命题2是满足的。上面的推理对于$u=x$的情况也是一样的。


# BZOJ1699

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1699](https://www.lydsy.com/JudgeOnline/problem.php?id=1699)

**题解**

裸题，可以用来测模板。St或线段树。

# BZOJ1251

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1251](https://www.lydsy.com/JudgeOnline/problem.php?id=1251)

**题解**

裸题，可以用来测模板。Treap、Splay都行。

# BZOJ2243

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2243](https://www.lydsy.com/JudgeOnline/problem.php?id=2243)

**题解**

由于是路径操作，路径操作的题目基本解法都是树链剖分、动态树、树上莫队。

考虑线性结构。类似于这类统计区间不同段数的问题，我们可以维护一个值tag，对于某个段，设置开头元素的tag为1，后续的元素的tag为0。这样，一个区间$[l,r]$存在多少个不同的段，可以统计区间$[l+1,r]$中tag的和，加上1后就是正确结果。

在处理树上路径的时候，也可以同样处理。如果u与其父节点在同一条重链上，且u与父节点的颜色不同，就设置u的tag为1。使用树链剖分，我们每次操作只需要处理$\log_2n$条重链，统计重链上tag的和，并且统计所有处于路径上的连接两个不同的重链的边，如果边的两端颜色不同，那么我们还需要在向结果加1。

而更新操作只需要处理路径上的重链就好了。

# BZOJ1036

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1036](https://www.lydsy.com/JudgeOnline/problem.php?id=1036)

**题解**

水题，树链剖分或动态树。

# BZOJ2038

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2038](https://www.lydsy.com/JudgeOnline/problem.php?id=2038)

**题解**

裸的莫队

# BZOJ2120

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2120](https://www.lydsy.com/JudgeOnline/problem.php?id=2120)

**题解**

裸的带修改莫队

# BZOJ1878

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1878](https://www.lydsy.com/JudgeOnline/problem.php?id=1878)

**题解**

莫队应该也能过，但是这题有O(nlogn)的解法。

我们从左到右扫描整个贝壳序列，假设当前扫描到i。我们为同类贝壳中最靠近i的贝壳的打上标记，而其余贝壳不打标记，统计以i为右边界的区间中不同贝壳数，可以转为统计区间中打上标记的贝壳数。

提前排序请求，并用BIT维护标记状态即可。

# BZOJ2743

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2743](https://www.lydsy.com/JudgeOnline/problem.php?id=2743)

**题解**

与BZOJ1878相同，但是需要打标记的花朵是距离扫描点第二近的花朵。

# LUOGU4137

**题目**

[https://www.luogu.org/problemnew/show/P4137](https://www.luogu.org/problemnew/show/P4137)

**题解**

有两种做法。

第一种莫队，但是使用块状链表维护每个出现的数，这样每次查询mex只需要$O(\sqrt{n})$的时间复杂度。总的时间复杂度为$O(n\sqrt{n})$

第二种线段树。首先将数据离散化，之后按照请求的右边界从小到大排序请求。之后从左往右遍历数组，遍历到第i个元素的时候，将$a_i$在线段树中的值更新为i。这样我们要查询mex，只需要查询第一个值小于查询左边界的数。这种方法的时间复杂度为$O(n\log_2n)$

# LUOGU3431

**题目**

[https://www.luogu.org/problemnew/show/P3431](https://www.luogu.org/problemnew/show/P3431)

**题解**

首先可以知道抵达点$(i,j)$之前，上一次接客一定发生在点$(x,y)$，其中$(x,y)$落在由$(0,0)$和$(i,j)$确定的矩形中。

现在要计算k个点的最优值，我们可以认为是k次查询。只是查询之间有拓扑关系。我们可以将离线处理查询，将查询按照y值排序，之后用线段树维护x轴。每处理一次请求(a,b)，只需要查询线段树中处于区间[0,a]之间的最大值，之后将查询结果一同更新到线段树中去。

# LUOGU3332

**题目**

[https://www.luogu.org/problemnew/show/P3332](https://www.luogu.org/problemnew/show/P3332)

**题解**

一开始看错题目了，以为是为区间中每个数增大c，始终想不出解法。后来发现原来是往区间每个下标放入一个数c。

怎么解决呢。我们发现每个数都有两个属性，所在的下标，以及它的值，记作(i,v)。由于是二维向量，我们将其绘制在二维坐标系中。每次查询操作都对应查询某个矩形中第k高的点，我们可以借助二分来猜测该点的高度。

到此容易想到用二维线段树来维护。由于预先开点需要消耗过多内存，因此可以改成动态开点。但是修改操作呢，该如何实现。我们可以调整线段树的含义，外部的线段树表示的是权值线段树，内部的线段树表示的是区间线段树，这样修改操作对于外部来说仅更新了一个点，是不需要打标记的，而内部线段树一次性更新了一段区间，是需要打标记的。

之后由于我们查询操作是之前是通过二分来做的，但是在我们将外部线段树改成权值线段树后，可以发现外部线段树的每次查询也带有二分操作，因此我们就不需要二分了，直接在外部线段树上进行二分。

总的时间复杂度为$O(m(\log_2n)^2)$，空间复杂度和时间复杂度一致。

# BZOJ3531

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=3531](https://www.lydsy.com/JudgeOnline/problem.php?id=3531)

**题解**

我一开始写的是带修改树上莫队，但是，TLE了。本地测了一下，速度还行的啊，10w的数据也就几秒。

正解貌似是用轻重链剖分，只是维护100000+1个动态开点的线段树，每个线段树仅记录一种颜色的顶点的信息。这样时间空间复杂度为$O((n+q)(\log_2n)^2)$。

# BZOJ4552

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=4552](https://www.lydsy.com/JudgeOnline/problem.php?id=4552)

**题解**

线段树分裂合并的模板题。

# ARC067F

**题意**

[https://atcoder.jp/contests/arc067/tasks/arc067_d](https://atcoder.jp/contests/arc067/tasks/arc067_d)

**题解**

考虑对于$B_{ij}$，记$x$为满足$B_{xj}>B_{ij}\land x < i$条件的最大值，记$y$为满足$B_{yj}>B_{ij}\land y>i$条件的最小值。

这意味着所有在区间$(x,y)$中游历并经过$i$的旅途，第j张票一定是在餐厅i消费的。对于所有这类旅途，我们在平面上绘制两个顶点(i,i)和(x+1,y-1)，由这两个顶点所确定的矩形中的所有顶点(a,b)，其对应的旅途为从第a个餐厅走到第b个餐厅，此时很显然会穿过餐厅i，且不会到达餐厅x和餐厅y。因此我们需要给其打上标记。

上面的过程可以用矩阵上打差分标记实现。在使用矩阵之前将所有惰性标记下推。之后遍历所有的$n^2$种旅途，暴力枚举每一种旅途的收益即可。

总的时间复杂度为$O(n^2+nm)$。

# ARC068E

**题意**

[https://atcoder.jp/contests/arc068/tasks/arc068_c](https://atcoder.jp/contests/arc068/tasks/arc068_c)

**题解**

这道题必须注意到一个非常关键的东西，不然时做不出来的。

先考虑现在处理移动距离为d，考虑一个区间\[l,r\]，区间的大小为r-l+1，如果区间的大小大于等于d，那么这个区间一定会覆盖到这次旅途中的某个城市。如果区间的大小小于d，我们可以直接记录在数组中，之后暴力寻找0,d,2d...这些下标的值统计，可以发现区间不会被重复统计（即最多在该区间停留一次）。

之后就是随便写写了，时间复杂度为
$$
O(m(log_2m)^2+n\log_2n)
$$
。

# 莫队算法

莫队可以用于解决一类区间离线统计问题。如果我们以经统计了$[l,r]$的信息，现在要统计$[l+1,r]$、$[l-1,r]$、$[l,r-1]$、$[l,r+1]$（这四种转移是基础转移），如果你能很快滴给出答案，那么就可以用莫队来优化离线区间查询。

假设我们现在有一段长度为n的序列，之后有m个查询，每个查询需要统计一段区间的信息。

下面我们首先按固定大小k进行分块，若请求的左边界为l，那么它会落在块$\lfloor \frac{l}{k} \rfloor$中。首先对查询预先进行排序，排序的第一关键字为查询所属的块，第二关键字为查询的右边界r。

之后我们按顺序处理每个请求，只不过在切换请求时我们复用上一个请求留下来的区间统计信息。比如现在区间为$[a,b]$，而查询的区间为$[l,r]$，我们可以通过四种基础转移将区间进行转换，需要执行$\|a-l\|+\|b-r\|$次转移。

下面我们来分析时间复杂度：

对于块号相同的查询，由于查询的右边界递增，因此右边界最多移动n次。总共有n/k个块，故最多移动$n^2/k$次。

对于块号相同的查询，由于每次切换查询时，左边界最多移动k次，共有m个查询，因此最多移动$km$次。

对于不同块的交界，切换时，我们左边界和右边界可能需要重置，这部分最多需要$2n$次基础操作，块最多切换$n/k$次，因此总共移动$2n^2/k$。

加总所需的时间费用，总共为$O(m\log_2m+km+n^2/k)$，当我们取$k=n/\sqrt{m}$时，此时时间复杂度为$O(m\log_2m+n\sqrt{m})$。

# 带修改莫队

我们可以将莫队修改成支持单点修改的形式。

设区间长度为n，区间查询与单点修改共m次。如何用莫队优化。

我们为查询引入版本的概念，一个查询的版本为在该次查询发生之前发生的修改次数。之后我们选取一个数k，并进行分块。对于查询，其左边界为l，右边界为r，版本为v，其属于分块$(\lfloor \frac{l}{k} \rfloor, \lfloor \frac{v}{k} \rfloor)$。定义块号的顺序为块号的字典序。首先我们需要对查询进行预先排序，排序的第一关键字为查询所处块号，第二关键字为查询的右边界。

之后按顺序处理查询。对于一个查询，如果版本号为上一个处理的查询不同，我们还需要应用或回退一些修改。

下面证明时间复杂度：

对于同一个块的查询，右边界最多移动n次，块数不超过$nm/k^2$，因此右边界总计移动$n^2m/k^2$。

对于同一个块中的查询，左边界和版本号最多分别变动k次，因此总共最多发生$2mk$次变动。

对于块之间的切换，每次左边界最多修改n，右边界最多修改n，版本最多修改m，因此总共发生$(2n+m)nm/k^2$次修改。

总的时间复杂度为$O(m\log_2m+3n^2m/k^2+2mk+nm^2/k^2)$。当我们取k为$n^{2/3}$时，得到时间复杂度$O(m\log_2m+n^{2/3}m+m^2/n^{1/3})$。

# 树上莫队

莫队可以扩展到树上。

对于子树查询，我们可以先计算树的dfs序，之后子树的dfs序一定是连续的，形成一个区间。那么实际上如果我们将结点按照dfs序铺平，那么子树查询就对应了普通的区间查询，直接可以上莫队。同样在这种情形下要支持单点修改，将普通莫队替换为带修改莫队即可。

还有一类比较神奇的应用是树上路径统计。我们知道一株树可以用括号序列来表示，比如(()())是一个根结点带两个叶结点。一个结点在其括号序列中对应两个括号，一个开括号一个闭括号。那么要查询从u到v的路径，我们这边假设u的左括号在v的左括号之前出现，那么可以发现在括号序列中，u的右括号到v的左括号之间仅u到v的路径上顶点的括号正好出现一次，其余顶点的括号要么成对出现要么不出现。因此我们可以认为一个顶点出现奇数次则包含入结果，否则从结果剔除。这里需要特别注意的是u和v的lca可能需要手动处理。

# BZOJ1146

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1146](https://www.lydsy.com/JudgeOnline/problem.php?id=1146)

**题解**

裸的带修改树上莫队。

# Codeforces1136E

**题意**

[https://codeforces.com/problemset/problem/1136/E](https://codeforces.com/problemset/problem/1136/E)

**题解**

可以发现，问题可以表述为：

$$
\left\{
\begin{array}{lcr}
a_2-k_1&\geq& a_1\\
a_3-k_2-k_1&\geq& a_2-k_1\\
\ldots\\
a_n-k_{n-1}-\ldots-k_1&\geq& a_{n-1}-k_{n-2}-\ldots-k_1
\end{array}
\right.
$$

即我们可以发现我们将每个数字$a_i$分成了两部分$a_i-k_{i-1}-\ldots-k_1$和$k_{i-1}+\ldots+k_1$的和。后面部分是不会改变的，而前面的部分是非严格递增的，因此可以用线段树维护。

# 一类阈值查询问题

所谓的阈值问题是指要让你维护一个数组，支持区间更新，以及查询某个区间中有多少数大于等于$k$。

**问题1：给定一个序列$a_1,a_2,\ldots, a_n$和一个数$k$，给定m次操作，操作分成两种，第一种是将区间中所有元素加上某个数$x$，第二种操作是询问区间中所有大于等于$k$的元素值的和，这个问题中$x\geq 0$，$n,m\leq 10^5$**

由于$x\geq 0$，我们可以直接暴力维护两颗线段树，第一颗线段树维护数组中所有小于$k$的元素的信息，第二颗线段树维护所有大于等于$k$的元素信息。每次更新操作都需要同时修改两颗线段树，并且修改完后需要不断检查第一颗线段树中最大的元素是否大于等于$k$，如果是，将其从第一颗线段树中删除，并迁移到第二颗线段树中。查询只需要查询第二颗线段树。由于每个区间中的元素最多会被迁移一次，因此时间复杂度为$O((n+m)\log_2n)$。

**问题2：给定一个序列$a_1,a_2,\ldots, a_n$和一个数$k$，给定m次操作，操作分成两种，第一种是将区间中所有元素加上$x$，第二种操作是询问区间中所有大于等于$k$的元素值的和，这个问题中$\|x\|=1$，$n,m\leq 10^5$。**

这个问题的难点在于存在负数的情况，假如使用问题1中提到的算法那么就无法保证迁移只发生$n$次。

下面来聊聊做法，我们将区间分块维护，每一块的大小为$b=\sqrt{n}$。这样每次区间更新操作可以看成$b$个块的完全更新和$2$个块的局部更新。前者我们用惰性标记，同时计算一下有哪些数大于等于$k$。后者我们可以直接暴力更新即可。这里值域比较大，我们可以用哈希表来存储每个块中元素值为$t$的所有元素的总和。查询操作就加总一下所有块即可，总的时间复杂度为$O(n\sqrt{n})$，这里由于使用了哈希表所以可能常数比较大。

# Segment tree beat的一些问题

**问题1：要求维护一段长度为$n$的序列$a_1,\ldots,a_n$，之后有$m$个询问，满足$n,m\leq 10^6$。询问有三种类型：**

1. **给定$l,r,x$，对于区间$l\leq i\leq  r$，将$a_i$替换为$\min(a_i,x)$。**
2. **给定$l,r$，查询$\max(a_l,a_{l+1},\ldots, a_r)$。**
3. **给定$l,r$，查询$a_l+a_{l+1}+\ldots+a_r$。**

吉如一论文中的问题，并且给出了做法，这边只是简单记录一下。

我们可以用线段树维护整个序列。同时为每个线段树维护一个最大值和严格次大值，当然区间和和最大值出现次数也是不可缺少的。这里先不讲为啥一定要维护严格次大值，之后会讲到。

当操作1发生的时候，假如当前扫描的区间完全落在更新区间中，那么要分三种情况处理。

1. 如果当前区间中最大值小于等于$x$，那么更新没有意义，直接返回即可。
2. 如果当前区间中最大值大于$x$，但是次大值小于$x$，那么我们就打上更新标记，同时修改区间和（由于最大值出现次数也在维护，因此新的区间和是可以直接计算的）。
3. 如果当前区间中次大值大于等于$x$（当次大值等于$x$时，这时候虽然我们能成功更新区间和，但是严格次大值就是非严格的了）。因此我们这时候必须暴力更新左右子区间，再利用左右子区间更新后的信息更新当前区间的信息。

这里与一般线段树的唯一区别仅为步骤3，步骤3是一个明显的暴力行为。下面我们证明上面所有操作的时间复杂度为$O((n+m)\log_2n)$。

我们这里需要借助势能分析。下面我们将线段树中存在的标记分为不同类，同一次更新操作打上的标记或同一个标记分裂后下传的两个标记是同一类，其余标记为不同类。一个线段树顶点的势能定义为以它为根的子树中存在的多少类的标记。而线段树整体的势能为线段树中所有顶点的势能之和。

很显然一次更新在不考虑暴力更新的情况下，仅仅会有$O(\log_2n)$个顶点的势能增加1，而所有标记分裂下推操作，最多会使得2个顶点的势能增加1。

下面我们考虑暴力更新操作会带来的影响，由于暴力更新发生，必定是区间中的次大值大于等于$x$，因此我们可以保证在更新操作完成后，所在顶点的势能会减少2（因为将下面最大值和次大值的标记全部回收掉），同时势能还会增加1（因为$x$的标记会打上），因此我们额外释放了多余的1点势能，这点势能的用处就是摊还掉遍历这个顶点的费用。（这就是为什么要维护严格次大值，只有这样才能同时回收两个标记，打上一个标记，总共释放一个标记）

因此我们发现所有操作的摊还后的时间复杂度都是$O(\log_2n)$，而线段树中最多包含$O(n)$个标记，每个标记对势能的贡献最多为$O(n\log_2n)$，因此这里就证明了总的时间复杂度为$O(n\log_2n+m\log_2n)$。

# 线段树上的搜索问题

**问题1：给定一个区间$a_1,a_2,\ldots,a_n$，有$m$个请求，其中$n,m\geq 10^6$。请求可以分为两种：**

1. **给定$l,r,x$，对于$l\leq i\leq r$，将$a_i$修改为$a_i+x$。**
2. **给定$l,r,x$，查询所有满足$l\leq i\leq r$且$a_i\geq x$的下标$i$中最小的那个下标，如果不存在，则输出$-1$，否则输出下标**

我们可以利用一个线段树维护区间，且线段树的每个顶点都维护区间最大值。

操作1可以很容易用惰性标记解决，我们考虑第二类请求。很显然我们可以二分区间进行查询，这样加上线段树的额外时间复杂度，总的时间复杂度为$O(n(\log_2n)^2)$。

上面的过程比较慢，现在我们尝试在搜索线段树的时候同时完成二分过程。这样我们要稍微修改一下线段树递归搜索的过程，我们先搜索左孩子，如果找到了，就直接返回，否则再搜索右孩子。同时在递归之前判断区间最大值是否大于等于$x$，如果不则直接返回。

很显然操作1的时间复杂度为$O(\log_2n)$，那么操作2的时间复杂度是多少呢。

考虑一次查询操作所访问的顶点，我们将其分为三类：

1. 顶点所代表的区间完全落在查询区间中
2. 顶点所代表的区间部分落在查询区间中
3. 顶点所代表的区间与查询区间无交点

如果我们进入第一类顶点中，由于我们可以在顶点中直接端点结果是处于左孩子还是右孩子中，并且不存在回溯，因此可以保证访问的第一类顶点的数目应该是$O(\log_2n)$。

接下来考虑第二类顶点，因为区间已经给定，而线段树上最多有$O(2\log_2n)$个顶点是属于第二类，因此第二类顶点的数目为$O(2\log_2n)$。

第三类顶点只能作为第二类顶点的孩子被访问到，因此最多会有$O(2\log_2n)$个顶点被访问到。

故总共访问到的顶点数目为$O(\log_2n)$，而每次访问的时间复杂度都是$O(1)$，因此操作2每次最坏时间复杂度为$O(\log_2n)$。

这样我们就能在$O(n+m\log_2n)$时间复杂度内解决这个问题。

**问题2：给定一个区间$a_1,a_2,\ldots,a_n$，有$m$个请求，其中$n,m\geq 10^6$。请求可以分为两种：**

1. **给定$l,r,x$，对于$l\leq i\leq r$，将$a_i$修改为$a_i+x$。**
2. **给定$l,r,x$，查询所有满足$l\leq j < i \leq r$且$a_i+a_j\geq x$的下标$i$中最小的那个下标，如果不存在，则输出$-1$，否则输出下标**

问题2和问题1非常类似，区别在于问题2需要在线段树上维护动态规划的信息。我们可以在线段树上每个顶点中维护区间最大值以及区间中最大的两个数的和。之后查询操作就类似于问题1了，但是区别在于如果我们搜索了左子树没有找到，那么我们需要记录所有左边区间中出现过的最大值。

第二类和第三类顶点数目是固定的，无需分析。当进入到第一类顶点的时候，如果目标不在当前区间，那么我们可以直接利用顶点上维护的最大值信息更新查询状态，从而直接可以返回。而如果目标在区间中，则回继续向下搜索。因此一次查询经过的第二类顶点数最多为$O(\log_2n)$，故总的时间复杂度还是$O(n+m\log_2n)$。

# 多维平面操作问题

一般的区间操作都是发生在一维平面上的，但是当这些区间操作发生在多维平面上时，问题将变得非常困难，甚至不能给出多项式时间内的解法。

**问题1：给定一个$n\cdot m$的矩阵$1\leq n,m\leq 10^9$，每个矩阵单元的初始值都是0。之后给出$q$次请求，每次请求要么要求你将落在某个子矩形中的所有单元都加上一个数（可能是负数），要么要求查询某个子矩形中所有单元的值的和**

这个问题可以直接用稀疏二维线段树解决（动态开点）。但是这样的空间复杂度为$O(q\log_2n\log_2m)$。

**问题2：给定一个$n\cdot m$的矩阵$1\leq n,m\leq 10^9$，每个矩阵单元的初始值都是0。之后给出$q$次请求，每次请求要么要求你修改某个单元的数（可能是负数），要么要求查询某个子矩形中所有单元的值的和**

这个问题可用问题1的方案直接解决。如果我们将每次更新看成点的增加和删除，将请求发生的时间作为第三个维度，那么我们可以将查询操作视作在三维平面上的某个立方体中的顶点权值总和的查询，这允许我们用CDQ分治疗解决，时间复杂度为$O(q(\log_2q)^2)$，空间复杂度为$O(q)$。

**问题3：给定一个$n\cdot m$的矩阵，$1\leq n,m\leq 10^9$，之后给出$q$个请求，每次请求要么要求你修改某个单元的数（可能是负数），要么要求查询某个子矩形中所有单元的值的最大值**

这个问题可以直接用稀疏二维线段树解决。时间复杂度和空间复杂度均为$O(q\log_2n\log_2m)$。

**问题4：给定一个$n\cdot m$的矩阵，$1\leq n,m\leq 10^3$，之后给出$q$个请求，每次请求要么要求你将落在某个子矩形中的所有单元都加上一个数（可能是负数），要么要求查询某个子矩形中所有单元的值的最大值**

这个问题可以用这种方式解决，我们可以建立Quad tree，之后你就可以以$O(n+m)$时间复杂度处理每个请求，总的时间复杂度为$O((n+m)q)$。

**问题5：给定一个$n\cdot m$的矩阵，$1\leq n,m\leq 10^9$，，每个单元的初始值都是0。之后给出$q$个请求，每次请求要么要求你将落在某个子矩形中的所有单元都加上一个数（可能是负数），要么要求查询某个子矩形中所有单元的值的最大值，这里$q\leq 10^4$。**

我们没法开quad tree，因为矩阵太大了。这里我们可以对请求进行离散化操作，将一个矩形拆分成$12$个点。如下图。

![https://raw.githubusercontent.com/taodaling/taodaling.github.io/master/assets/images/2020-02-29-interval/clip.png](https://raw.githubusercontent.com/taodaling/taodaling.github.io/master/assets/images/2020-02-29-interval/clip.png)

之后可以用KD树求解，由于$k$维KD树区间查询修改的时间复杂度是$O(n^{1-\frac{1}{k}})$，而这里维度是2，因此时间复杂度为$O(q\sqrt{12q})$

# 区间选择问题

**问题1：给定一个序列$a_1,a_2,\ldots, a_n$，以及$m$个区间$I_1=\[l_1,r_1\],I_2=\[l_2,r_2\],\ldots, I_m=\[l_m,r_m\]$。现在我们允许选择任意个区间，将所有被至少一个选中区间覆盖的元素$a_i$加总，问总和最大可以为多少。其中$-10^9\leq a_i \leq 10^9,1\leq n\leq 10^5,1\leq m\leq 10^5$。**

可以发现，如果我们选择了两个区间$\[l_i, r_i\]$和$\[l_j,r_j\]$，且$l_j\leq l_i \leq r_i\leq r_j$，那么区间$i$是否选择并不会影响结果。因此我们可以认为不允许同时选择嵌套的区间。

对于区间$I_i$，我们为其建立一个DP状态$dp(I_i)$，其意义为已选的右边界最大的区间为$\[l_i,r_i\]$的前提下最大总和是多少。

第一类转移：对于区间$j$，如果$r_j<l_i$，那么转移公式为：$dp(I_i)=dp(I_j)+s(r_i)-s(l_i-1)$，其中$s(k)=a_1+\ldots+a_k$。

第二类转移：对于区间$j$，如果$l_j\leq l_i \leq r_j\leq r_i$，这时候两个区间有交，此时转移公式为：$dp(I_i)=dp(I_j)+s(r_i)-s(r_j)$。

有了转移公式，那么如果找到这些满足条件的$j$呢。我们可以将区间的左边界作为横坐标，将区间的右边界作为纵坐标，这时候会发现所有两类转移都落在由$(0,0)$和$(l_i,r_i)$组成的矩形内。且矩形中坐标大于等于$l_i$的为第二类转移，小于$l_i$的为第一类转移。

上面的几何化意味着我们可以用二维线段树来维护平面信息，但是实际上我们可以通过提前对一个维度进行排序处理的技术，使用普通线段树就可以维护了。

对于第一类转移和第二类转移需要分别建立一颗线段树进行维护。总的时间复杂度为$O(n+m(\log_2n+\log_2m))$。

**问题2：给定一个序列$a_1,a_2,\ldots, a_n$，以及$m$个区间$I_1=\[l_1,r_1\],I_2=\[l_2,r_2\],\ldots, I_m=\[l_m,r_m\]$。现在我们恰好选择$k$个区间，将所有被至少一个选中区间覆盖的元素$a_i$加总，问总和最大可以为多少。其中$-10^9\leq a_i \leq 10^9,1\leq n\leq 10^5,1\leq m\leq 10^5$。**

首先在不考虑$k$的约束情况下，这个问题与问题1无异。可以发现随着$k$增大，增幅会越小，这意味着由$k$和最优解组成的曲线是一个上凸包。考虑到这些，我们就可以利用WQS技术结合问题1求DP的方式解决这个问题，时间复杂度为$O((n+m(\log_2n+\log_2m))\log_2M)$，其中$M$与数值大小以及精度有关，一般不会超过$60$。

**问题3：给定一个序列$a_1,a_2,\ldots, a_n$，以及$m$个区间$I_1=\[l_1,r_1\],I_2=\[l_2,r_2\],\ldots, I_m=\[l_m,r_m\]$。现在我们任意选择区间，将所有被至少一个选中区间覆盖的元素$a_i$加总，问总和最大可以为多少。其中$0\leq a_i \leq 10^9,1\leq n\leq 10^6,1\leq m\leq 10^6$。**

这道题连题都不算，我们直接将所有被至少一个区间覆盖的数值加总起来即可，时间复杂度$O((n+m)\log_2n)$，如果区间已经被按照左边界排序过，那么时间复杂度为$O(m+n)$

**问题4：给定一个序列$a_1,a_2,\ldots, a_n$，以及$m$个区间$I_1=\[l_1,r_1\],I_2=\[l_2,r_2\],\ldots, I_m=\[l_m,r_m\]$。现在我们要正好选择$k$个区间，将所有被至少一个选中区间覆盖的元素$a_i$加总，问总和最大可以为多少。其中$0\leq a_i \leq 10^9,1\leq n\leq 10^6,1\leq m\leq 10^6$。**

这道题实际上是问题2的简化版，于是我们直接可以得出一个$O((n+m(\log_2n+\log_2m))\log_2M)$的做法。但是这道题的数据范围加大了，因此这种做法会超时。

可以想到用WQS二分来解决这个问题，但是现在问题来了，如何计算每次决策惩罚$C(C\geq 0)$的情况下最优能得到的总权。

首先我们还是假设不能选择两个相互包含的区间，因为这是没有意义的。

对于区间$I_i$，我们为其建立一个DP状态$dp(I_i)$，其意义为已选的右边界最大的区间为$\[l_i,r_i\]$的前提下最大总和是多少。

第一类转移：对于区间$j$，如果$r_j<l_i$，那么转移公式为：$dp(I_i)=dp(I_j)+s(r_i)-s(l_i-1)$，其中$s(k)=a_1+\ldots+a_k$。

第二类转移：对于区间$j$，如果$l_j\leq l_i \leq r_j\leq r_i$，这时候两个区间有交，此时转移公式为：$dp(I_i)=dp(I_j)+s(r_i)-s(r_j)$。

对于第一类转移，由于$s(r_i)-s(l_i-1)$是常数，因此我们只需要取最大的$dp(I_j)$即可。而对于第二类转移，比较复杂，但是注意到$s(i)$是非严格递增函数，因此我们可以使用斜率优化计算。

因此在已知惩罚的前提下，一次DP的时间复杂度为$O(n+m)$，结合WQS二分总的时间复杂度为$O((n+m)\log_2M)$，是可以通过的。

提供一道CF[题目](https://codeforces.com/contest/1279/problem/F)。

**问题5：给定一颗树，树根为1，树上有$n$个顶点，第$i$个顶点有一笔价值$w_i$的财富。其中$m$个顶点是特殊的，我们现在可以派出$k$个人，从$k$个特殊的顶点出发，向根出发，搜集路上所有的财富（同一个顶点的财富只会被搜集一次）。问我们最多可以得到多少总财富？其中$0\leq w_i \leq 10^9,1\leq k\leq n\leq 1000$**

这个题目首先可以想到费用流，我们将每个顶点拆分成两个，两个顶点连一条费用为$-w_i$容量为1的边。每个顶点同时连源点和汇点。看最优值即可。总的时间复杂度为$O(kV\log_2V)$，这里使用Dijkstra优化的费用流。

**问题6：给定一颗树，树根为1，树上有$n$个顶点，第$i$个顶点有一笔价值$w_i$的财富。我们现在可以派出$k$个人，从$k$个顶点出发，向根出发，搜集路上所有的财富（同一个顶点的财富只会被搜集一次）。问我们最多可以得到多少总财富？其中$-10^9\leq w_i \leq 10^9,1\leq k\leq n\leq 10^6$**

我们可以直接用贪心法证明，每次选择出发收益最大的顶点出发，$k$次后得到的就是最大收益。假设$v$是初始时出发收益最大的顶点，那么如果最后的方案中不选择$v$，记方案中被搜集的顶点形成的树为$T$，我们可以找到$T$中$v$的深度最小的祖先，回退之前$T$下的任意一个特殊顶点带来的影响，并加入$v$，可以证明这时候我们的收益是不会减少的。

首先我们可以利用所有顶点的dfs序构建线段树，之后利用线段树实现区间修改和弹出全局收益最大顶点的能力（即大根堆）。

第一次增广非常容易，找到收益最大的顶点$v$即可。将其弹出后，我们暴力枚举其所有祖先，之后修改祖先下其余顶点的收益，比如枚举到祖先$a$，祖先到当前顶点的路径中除了祖先外，深度最小的顶点记作$b$，那么我们将$a$代表的子树中的所有顶点的权重减去$a$的收益，但是$b$中的子树需要另外加上$a$的收益（即抵消该次变化）。而对于$v$，我们将$v$下所有顶点减去$v$的收益。这样我们遍历$v$的所有未被处理过的祖先就可以修正剩余所有特殊顶点的收益了。

可以发现每个每个顶点最多被访问一次，因此总的时间复杂度为$(n+k)\log_2n$。

给一道BZOJ[题目](https://www.lydsy.com/JudgeOnline/problem.php?id=3252)，是这道题的弱化版。

# 区间颜色统计问题

**题目1：给定一个序列$a_1,\ldots,a_n$，之后给出$q$个查询，第$i$个查询为$l_i,r_i$，询问$a_{l_i},\ldots,a_{r_i}$中有多少不同的数。**

典型问题，最简单的方式就是直接用莫队，时间复杂度为$O(n\sqrt{n})$。但是实际上这个问题存在$O(n\log_2n)$的解法。

首先定义一个新序列$b_1,\ldots,b_n$，$b_i$表示第$i$个数之前与$a_i$相同的数中最大的下标（如果不存在则设为$-1$）。那么现在查询询问的实际上是区间$b_{l_i},\ldots,b_{r_i}$中有多少数小于$l_i$。

实际上我们可以把第$i$个数转换成二维平面点：$(i,b_i)$。这样查询其实询问的是某个二维平面中子矩形中的顶点数目。由于是离线查询，因此可以用线段树$O(n\log_2n)$求解。

**题目2：给定一个序列$a_1,\ldots,a_n$，之后给出$q$个查询，第$i$个查询为$l_i,r_i$，询问$a_{l_i},\ldots,a_{r_i}$中有多少不同的数。查询强制在线。**

由于是在线查询，因此莫队方法是行不通的。

我们可以用题目1的技巧将问题转换为二维点，之后用持久化线段树替换普通线段树，这样就可以支持在线查询了，时间复杂度和空间复杂度均为$O(n\log_2n)$。

**题目3：给定一个序列$a_1,\ldots,a_n$，之后给出$q$个操作，操作分为两类：第一类，查询$l_i,r_i$，询问$a_{l_i},\ldots,a_{r_i}$中有多少不同的数；第二类，修改某个$a_{x_i}$，将其修改为某个指定数。**

由于可以离线，所以用带修莫队可以过，时间复杂度为$O(n^{\frac{5}{3}})$。

同样我们将每个值转换为二维点，而修改操作就变成了增加点和删除点（对应点权为$1$和$-1$）。因此第$i$个值转换为$(i,b_i,t_i)$，其中$t_i$表示这个顶点出现的时间。之后问题就变成了三维空间的子矩形问题，可以利用CDQ分治以$O(n(\log_2n)^2)$的时间复杂度求解。


**题目4：给定一个序列$a_1,\ldots,a_n$，之后给出$q$个操作，操作分为两类：第一类，查询$l_i,r_i$，询问$a_{l_i},\ldots,a_{r_i}$中有多少不同的数；第二类，修改某个$a_{x_i}$，将其修改为某个指定数。要求查询和修改在线。**

莫队继续躺好。

将每个值转换为二维点之后，问题就变成了在线删点、加点以及统计区间，稀疏二维线段树足矣。时间复杂度和空间复杂度均为$O(n(\log_2n)^2)$。

**题目5：给定一株拥有$n$个顶点的树，第$i$个顶点上写着$a_i$。要求统计每个顶点作为根的子树下有多少不同的数。**

树上DSU可以轻松解决，时间复杂度为$O(n\log_2n)$。

**题目6：给定一株拥有$n$个顶点的树，第$i$个顶点上写着$a_i$。之后$q$个查询，每个查询指定两个顶点$u,v$，要求回答$u$到$v$的唯一路径上的顶点上总共写着多少不同的数字。**

树上路径统计是莫队的强项，直接用树上莫队即可。时间复杂度为$O(n\sqrt{n})$。

**题目7：给定一株拥有$n$个顶点的树，第$i$个顶点上写着$a_i$。之后$q$个操作：操作1，指定两个顶点$u,v$，要求回答$u$到$v$的唯一路径上的顶点上总共写着多少不同的数字；操作2，修改某个顶点上的数字。**

树上带修莫队，时间复杂度为$O(n^{\frac{5}{3}})$。

# 参考资料

- [线段树的特殊运用](https://blog.csdn.net/zawedx/article/details/51818475)
- [2016年集训队论文](https://github.com/enkerewpo/OI-Public-Library/blob/master/IOI%E4%B8%AD%E5%9B%BD%E5%9B%BD%E5%AE%B6%E5%80%99%E9%80%89%E9%98%9F%E8%AE%BA%E6%96%871999-2019/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F2016%E8%AE%BA%E6%96%87%E9%9B%86.pdf)