---
categories: problems
layout: post
---

- Table
{:toc}

# BZOJ1699

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1699](https://www.lydsy.com/JudgeOnline/problem.php?id=1699)

**题解**

裸题，可以用来测模板。St或线段树。

# BZOJ1251

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1251](https://www.lydsy.com/JudgeOnline/problem.php?id=1251)

**题解**

裸题，可以用来测模板。Treap、Splay都行。

# BZOJ2243

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2243](https://www.lydsy.com/JudgeOnline/problem.php?id=2243)

**题解**

由于是路径操作，路径操作的题目基本解法都是树链剖分、动态树、树上莫队。

考虑线性结构。类似于这类统计区间不同段数的问题，我们可以维护一个值tag，对于某个段，设置开头元素的tag为1，后续的元素的tag为0。这样，一个区间$[l,r]$存在多少个不同的段，可以统计区间$[l+1,r]$中tag的和，加上1后就是正确结果。

在处理树上路径的时候，也可以同样处理。如果u与其父节点在同一条重链上，且u与父节点的颜色不同，就设置u的tag为1。使用树链剖分，我们每次操作只需要处理$\log_2n$条重链，统计重链上tag的和，并且统计所有处于路径上的连接两个不同的重链的边，如果边的两端颜色不同，那么我们还需要在向结果加1。

而更新操作只需要处理路径上的重链就好了。

# BZOJ1036

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1036](https://www.lydsy.com/JudgeOnline/problem.php?id=1036)

**题解**

水题，树链剖分或动态树。

# BZOJ2038

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2038](https://www.lydsy.com/JudgeOnline/problem.php?id=2038)

**题解**

裸的莫队

# BZOJ2120

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2120](https://www.lydsy.com/JudgeOnline/problem.php?id=2120)

**题解**

裸的带修改莫队

# BZOJ1878

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1878](https://www.lydsy.com/JudgeOnline/problem.php?id=1878)

**题解**

莫队应该也能过，但是这题有O(nlogn)的解法。

我们从左到右扫描整个贝壳序列，假设当前扫描到i。我们为同类贝壳中最靠近i的贝壳的打上标记，而其余贝壳不打标记，统计以i为右边界的区间中不同贝壳数，可以转为统计区间中打上标记的贝壳数。

提前排序请求，并用BIT维护标记状态即可。

# BZOJ2743

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2743](https://www.lydsy.com/JudgeOnline/problem.php?id=2743)

**题解**

与BZOJ1878相同，但是需要打标记的花朵是距离扫描点第二近的花朵。

# LUOGU4137

**题目**

[https://www.luogu.org/problemnew/show/P4137](https://www.luogu.org/problemnew/show/P4137)

**题解**

有两种做法。

第一种莫队，但是使用块状链表维护每个出现的数，这样每次查询mex只需要$O(\sqrt{n})$的时间复杂度。总的时间复杂度为$O(n\sqrt{n})$

第二种线段树。首先将数据离散化，之后按照请求的右边界从小到大排序请求。之后从左往右遍历数组，遍历到第i个元素的时候，将$a_i$在线段树中的值更新为i。这样我们要查询mex，只需要查询第一个值小于查询左边界的数。这种方法的时间复杂度为$O(n\log_2n)$

