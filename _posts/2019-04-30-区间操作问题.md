---
categories: problems
layout: post
---

- Table
{:toc}
# 根号优化

假设给我们一个长度为n的数组，要求支持区间更新，区间统计。

最简单的方式是将数组分块，每一块大小为$m=sqrt{n}$。之后我们为每一块都额外维护一份辅助信息，第i块的辅助信息记作$f(i)$。

现在考虑区间更新问题，只要利用惰性标记就可以实现$sqrt{n}$的时间复杂度。对于完全处于区间中的块，我们直接标记在辅助信息上（如果已经有标记了，就合并标记），这样的块最多有$sqrt{n}$个。而对于与区间有交集的却不被完全覆盖的块，我们先下推标记，之后直接暴力修改，可以得知这样的块不会超过两个，总的修改的元素不超过$2\sqrt{n}$个。

查询操作也是相同的，对于被完全覆盖的块，直接从辅助信息中提取，否则直接暴力查询，时间复杂度为$O(\sqrt{n})$。

# 线段树合并分裂

考虑一株权值线段树，即线段树区间$[x,x]$表示的是值为x的元素数目。（如果权值过大，可以提前离散化处理）

权值线段树最大的特点就是其可以表示一个排序好的数组，我们可以快速得到第k小的元素。

现在我们希望建立多颗权值线段树，并支持合并，分裂，建树操作。

考虑建树操作，由于线段树的数目比较多，因此需要动态开点来保证内存够用。建树操作的时间复杂度和空间复杂度为$O(\log_2K)$，K是值的范围。

接下来考虑分裂操作，按照第k小元素进行分裂，我们可以递归找到第k小元素，在查找的过程中进行分裂。分裂操作的时间复杂度和空间复杂度为$O(\log_2K)$

最后考虑合并操作，将两颗权值线段树合并，我们可以暴力进行合并，只是当一株树为空时则直接返回即可。

```java
Segment merge(Segment a, Segment b){
    if(a == NIL) return b;
    if(b == NIL) return a;
    //递归合并线段树a、b
}
```

由于每次递归调用merge都意味着会销毁至少一个顶点，而总的顶点数与建树次数n和分裂次数m有关，至多为$O((n+m)\log_2K)$。

因此总的时间复杂度为$O((n+m)\log_2K)$。

# BZOJ1699

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1699](https://www.lydsy.com/JudgeOnline/problem.php?id=1699)

**题解**

裸题，可以用来测模板。St或线段树。

# BZOJ1251

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1251](https://www.lydsy.com/JudgeOnline/problem.php?id=1251)

**题解**

裸题，可以用来测模板。Treap、Splay都行。

# BZOJ2243

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2243](https://www.lydsy.com/JudgeOnline/problem.php?id=2243)

**题解**

由于是路径操作，路径操作的题目基本解法都是树链剖分、动态树、树上莫队。

考虑线性结构。类似于这类统计区间不同段数的问题，我们可以维护一个值tag，对于某个段，设置开头元素的tag为1，后续的元素的tag为0。这样，一个区间$[l,r]$存在多少个不同的段，可以统计区间$[l+1,r]$中tag的和，加上1后就是正确结果。

在处理树上路径的时候，也可以同样处理。如果u与其父节点在同一条重链上，且u与父节点的颜色不同，就设置u的tag为1。使用树链剖分，我们每次操作只需要处理$\log_2n$条重链，统计重链上tag的和，并且统计所有处于路径上的连接两个不同的重链的边，如果边的两端颜色不同，那么我们还需要在向结果加1。

而更新操作只需要处理路径上的重链就好了。

# BZOJ1036

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1036](https://www.lydsy.com/JudgeOnline/problem.php?id=1036)

**题解**

水题，树链剖分或动态树。

# BZOJ2038

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2038](https://www.lydsy.com/JudgeOnline/problem.php?id=2038)

**题解**

裸的莫队

# BZOJ2120

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2120](https://www.lydsy.com/JudgeOnline/problem.php?id=2120)

**题解**

裸的带修改莫队

# BZOJ1878

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1878](https://www.lydsy.com/JudgeOnline/problem.php?id=1878)

**题解**

莫队应该也能过，但是这题有O(nlogn)的解法。

我们从左到右扫描整个贝壳序列，假设当前扫描到i。我们为同类贝壳中最靠近i的贝壳的打上标记，而其余贝壳不打标记，统计以i为右边界的区间中不同贝壳数，可以转为统计区间中打上标记的贝壳数。

提前排序请求，并用BIT维护标记状态即可。

# BZOJ2743

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2743](https://www.lydsy.com/JudgeOnline/problem.php?id=2743)

**题解**

与BZOJ1878相同，但是需要打标记的花朵是距离扫描点第二近的花朵。

# LUOGU4137

**题目**

[https://www.luogu.org/problemnew/show/P4137](https://www.luogu.org/problemnew/show/P4137)

**题解**

有两种做法。

第一种莫队，但是使用块状链表维护每个出现的数，这样每次查询mex只需要$O(\sqrt{n})$的时间复杂度。总的时间复杂度为$O(n\sqrt{n})$

第二种线段树。首先将数据离散化，之后按照请求的右边界从小到大排序请求。之后从左往右遍历数组，遍历到第i个元素的时候，将$a_i$在线段树中的值更新为i。这样我们要查询mex，只需要查询第一个值小于查询左边界的数。这种方法的时间复杂度为$O(n\log_2n)$

# LUOGU3431

**题目**

[https://www.luogu.org/problemnew/show/P3431](https://www.luogu.org/problemnew/show/P3431)

**题解**

首先可以知道抵达点$(i,j)$之前，上一次接客一定发生在点$(x,y)$，其中$(x,y)$落在由$(0,0)$和$(i,j)$确定的矩形中。

现在要计算k个点的最优值，我们可以认为是k次查询。只是查询之间有拓扑关系。我们可以将离线处理查询，将查询按照y值排序，之后用线段树维护x轴。每处理一次请求(a,b)，只需要查询线段树中处于区间[0,a]之间的最大值，之后将查询结果一同更新到线段树中去。

# LUOGU3332

**题目**

[https://www.luogu.org/problemnew/show/P3332](https://www.luogu.org/problemnew/show/P3332)

**题解**

一开始看错题目了，以为是为区间中每个数增大c，始终想不出解法。后来发现原来是往区间每个下标放入一个数c。

怎么解决呢。我们发现每个数都有两个属性，所在的下标，以及它的值，记作(i,v)。由于是二维向量，我们将其绘制在二维坐标系中。每次查询操作都对应查询某个矩形中第k高的点，我们可以借助二分来猜测该点的高度。

到此容易想到用二维线段树来维护。由于预先开点需要消耗过多内存，因此可以改成动态开点。但是修改操作呢，该如何实现。我们可以调整线段树的含义，外部的线段树表示的是权值线段树，内部的线段树表示的是区间线段树，这样修改操作对于外部来说仅更新了一个点，是不需要打标记的，而内部线段树一次性更新了一段区间，是需要打标记的。

之后由于我们查询操作是之前是通过二分来做的，但是在我们将外部线段树改成权值线段树后，可以发现外部线段树的每次查询也带有二分操作，因此我们就不需要二分了，直接在外部线段树上进行二分。

总的时间复杂度为$O(m(\log_2n)^2)$，空间复杂度和时间复杂度一致。

# BZOJ3531

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=3531](https://www.lydsy.com/JudgeOnline/problem.php?id=3531)

**题解**

我一开始写的是带修改树上莫队，但是，TLE了。本地测了一下，速度还行的啊，10w的数据也就几秒。

正解貌似是用轻重链剖分，只是维护100000+1个动态开点的线段树，每个线段树仅记录一种颜色的顶点的信息。这样时间空间复杂度为$O((n+q)(\log_2n)^2)$。

# BZOJ4552

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=4552](https://www.lydsy.com/JudgeOnline/problem.php?id=4552)

**题解**

线段树分裂合并的模板题。

# ARC067F

**题意**

[https://atcoder.jp/contests/arc067/tasks/arc067_d](https://atcoder.jp/contests/arc067/tasks/arc067_d)

**题解**

考虑对于$B_{ij}$，记$x$为满足$B_{xj}>B_{ij}\land x < i$条件的最大值，记$y$为满足$B_{yj}>B_{ij}\land y>i$条件的最小值。

这意味着所有在区间$(x,y)$中游历并经过$i$的旅途，第j张票一定是在餐厅i消费的。对于所有这类旅途，我们在平面上绘制两个顶点(i,i)和(x+1,y-1)，由这两个顶点所确定的矩形中的所有顶点(a,b)，其对应的旅途为从第a个餐厅走到第b个餐厅，此时很显然会穿过餐厅i，且不会到达餐厅x和餐厅y。因此我们需要给其打上标记。

上面的过程可以用矩阵上打差分标记实现。在使用矩阵之前将所有惰性标记下推。之后遍历所有的$n^2$种旅途，暴力枚举每一种旅途的收益即可。

总的时间复杂度为$O(n^2+nm)$。

# ARC068E

**题意**

[https://atcoder.jp/contests/arc068/tasks/arc068_c](https://atcoder.jp/contests/arc068/tasks/arc068_c)

**题解**

这道题必须注意到一个非常关键的东西，不然时做不出来的。

先考虑现在处理移动距离为d，考虑一个区间\[l,r\]，区间的大小为r-l+1，如果区间的大小大于等于d，那么这个区间一定会覆盖到这次旅途中的某个城市。如果区间的大小小于d，我们可以直接记录在数组中，之后暴力寻找0,d,2d...这些下标的值统计，可以发现区间不会被重复统计（即最多在该区间停留一次）。

之后就是随便写写了，时间复杂度为
$$
O(m(log_2m)^2+n\log_2n)
$$
。·

# 参考资料

- [线段树的特殊运用](https://blog.csdn.net/zawedx/article/details/51818475)