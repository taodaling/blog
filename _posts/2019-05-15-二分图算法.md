---
categories: algorithm
layout: post
---

- Table
{:toc}

# 基础概念

一个图G=(V,E)，如果V可以分为两个不相交集合L、R，使得$L\cup R=V$且$L\cap R=\emptyset$。且集合L中任意两个顶点之间没有边存在，集合R中任意两个顶点之间没有边存在，那么称图G为二分图。

对于E的一个子集，若子集中的任意两条边都没有公共顶点，那么称该子集为图G的一个匹配。如果不存在比某个匹配更大的匹配，则称该匹配为G的最大匹配。

对于V的一个子集，若对于任意E中的一条边，其至少一个顶点属于该子集，那么称该子集为图G的一个顶点覆盖。所有顶点覆盖中最小的顶点覆盖，称为图G的最小顶点覆盖。

对于E的一个子集，若对于任意V中的一个顶点v，一定能在子集中找到一个边e，使得v是e的某个端点，那么称该子集是图G的一个边覆盖。所有边覆盖中最小的称为最小边覆盖。

对于V的一个子集，若子集中任意两个不同顶点之间都没有边，那么称该子集为G的一个独立集。独立集中最大的称为最大独立集。

对于V的一个子集，若子集中任意两个顶点之间都有边，那么称该子集为G的一个团，团中最大的称为最大团。

我们将V分成若干个子集$X_1,X_2,\ldots,X_k$，其中每个子集都对应G中的一条无环路径，且所有子集的并集为V，那么称顶点子集族${X_1,X_2,\ldots,X_k}$为G的路径覆盖。最小的路径覆盖称为最小路径覆盖。如果所有子集彼此之间交集为空，那么称子集族为G的不相交路径覆盖，否则称为相交路径覆盖。

# 最大流算法求最大匹配

我们向图中加入两个顶点s，t，分别作为源点和终点，从s到所有L中顶点建立一条容量为1的边，从R中所有顶点到t建立一条容量为1的边。之后在图上跑最大流算法就可以得到最大覆盖了，一个边如果流量为1，则边为最大匹配的一部分。

很显然这样得到的一组边集是一个匹配，而对于任意一个匹配，匹配中的每一条边都能为最大流算法提供1的流量。因此最大流算法得出的最大流与最大覆盖的大小等同，而我们得到的边集的大小等同于最大流的大小，因此该覆盖是最大匹配。

最简单的最大流算法就是沿着最短路不断增广的Edmonds-Karp算法，其时间复杂度为$O(E(V+E))$。或者可以选择更进一步优化的ISAP算法，时间复杂度类似，但是实际效果会好很多。

# Kuhn-Munkres算法

Knhn-Munkres也是一个求最大匹配的算法，时间复杂度与EK算法类似，同样是$O(E(V+E))$，但是由于是二分图专用的，因此实际效果非常好，个人实测有将近10倍的差距。

算法的思路与EK算法类似，也是沿着残存网络中的边进行增广。

```java
/**
* 要求node释放自己的同伴，成功返回true，失败false
*/
boolean release(Node node){
    if(node.visited)
    {
        return false;
    }
    node.visited = true;
    if(node.partner != null && bind(node.partner))
    {
        node.partner = null;
    }
    return node.partner == null;
}
/**
* 要求node重新寻找一个新的同伴，成功返回true，失败false
*/
boolean bind(Node node)
{
    if(node.visited)
    {
        return false;
    }
    node.visited = true;
    for(Node nearby : node.edges)
    {
        if(!release(nearby))
        {
            continue;
        }
        node.partner = nearby;
        nearby.partner = node;
        return true;
    }
    return false;
}
```

# Konig定理

Konig定理：二分图中的最大匹配数等于这个图的最小顶点覆盖数。

证明：

假设我们找到了最大匹配Y。

我们称Y中所有边的两个端点为被Y所匹配。我们遍历所有R中没有被Y匹配的顶点，寻找所有长度为偶数的路径，路径中匹配边和未匹配边交替出现。事实上不存在长度为奇数的路径，不然我们就找到了一个增广路径。我们将L中被标记过的顶点和R中未被标记的顶点合成一个新的点集合X，我们接下来证明X是最小顶点覆盖。

首先先说明X是顶点覆盖，即所有边至少有一个端点属于X。假设存在一条边e，e的两个端点$l\in L$,$r\in R$均不属于X，这意味着l未被标记而r被标记过了。但是这是不可能的，因为r被标记意味着存在这样一个顶点序列$r_0,l_0,r_1,l_1,\ldots,r$，其中路径$(r_i,l_i) \notin Y$且$(l_i,r_{i+1}) \in Y$。我们可以在路径尾部追加$l$得到更长的一条奇数路径，l必定被Y匹配，因此存在另外一条边$(l,t)\in Y$，即路径$r_0,l_0,r_1,l_1,\ldots,r,l,t$是一条合法路径，其上所有顶点都会被标记，因此不存在这样的边，X是顶点覆盖。

之后说明X最小。显然每个Y中的边至少需要一个顶点覆盖，因此最小顶点覆盖数至少为\|Y\|。我们接下来证明$\|X\|=\|Y\|$。

很显然，X中的顶点必定都被Y所匹配（回忆下X是由哪些顶点组成的）。而如果一条$Y$中的边e，两个端点$l\in L$,$r\in R$都属于X，这意味着l被标记而r未被标记，这是不可能的，因为我们同样可以构建一个合法的标记路径。因此我们知道$Y$中的每一条边只有一个顶点属于$X$，到此，我们证明了$\|X\|=\|Y\|$。

# 最小边覆盖

最小边覆盖数等于$\|V\|-\|Y\|$，其中，其中Y$是最大匹配。

证明：

假设X是最小边覆盖，我们可以保证，X中每条边都至少独立覆盖了一个顶点（不然我们可以将这条边删除得到更小的一个边覆盖）。我们不断从X中删除仅独立覆盖一条顶点的边，假设共删除了k个顶点。留下的$\|X\|-k$条边都独立覆盖了两个顶点，可以发现此时条边都独立覆盖了两个顶点，可以发现此时条边都独立覆盖了两个顶点，可以发现此时条边都独立覆盖了两个顶点，可以发现此时X同样也是G的一个匹配。由此得出下面不等式：


$$
2X=V+k\geq V+X-Y\Rightarrow X\geq V-Y
$$



因此我们可以得出最小边覆盖的大小至少为$\|V\|-\|Y\|$。下面我们讲述如何得到最小边覆盖。

记边集X初始为Y。由于X覆盖了2X个顶点，记这些顶点集合为U，我们为每个不属于U的顶点，找到一个以其为端点的边并加入到Y中。完成上述操作后，X的大小正好为$\|V\|-\|Y\|$。此时。此时。此时。此时X为图G的一个边覆盖。

# 二分图最大独立集

二分图最大独立集的大小等于$\|V\|-\|M\|$，其中M为最大匹配。

证明：

要计算最大独立集，我们可以换种理解。我们记X为最大独立集，而Y=V-X。要获取最大独立集，我们实际上要从V中移除一些由边连接的顶点。对于任意边的两个端点，我们至少需要从V中移除一个顶点。换言之，每个边的都有至少一个端点属于集合Y。容易发现Y是一个顶点覆盖，同样的任意一个顶点覆盖，其对于V的补集一定也是一个独立集。由于$\|X\|=\|V\|-\|Y\|$，要让X最大，等价于Y最小，因此Y实际上是一个最小顶点覆盖，而我们之前已经讨论过最小顶点覆盖和最大匹配等大，因此公式$\|X\|=\|V\|-\|M\|$。

# 二分图最大团

二分图G=(V,E)中的团，对应G的补图中的一个独立集。而最大团对应的就是补图中的最大独立集，之前已经讨论过最大独立集的求法了，这里不赘述。

# 最小不相交路径覆盖

我们将图G=(V,E)中每个顶点$v$拆成两个顶点$v_l$,$v_r$，而对于E中每一条边$(u,v)$，我们对应的建立一条边$(u_l,v_r)$。这样我们就建立了一个二分图G'。图G的最小不相交路径覆盖的大小等于$\|V\|-\|M\|$。其中M表示最大匹配。

证明：

在初始的时候对于每个顶点v，我们都可以建立一条不相交路径$(v_l,v_r)$，因此一开始我们可以建立$\|V\|$条不相交路径。

对于任意一个匹配，对于匹配中每一条边$(u_l,v_r)$，我们将以$v_r$结尾的路径与以$u_l$为开端的路径通过$(u_l,v_r)$合并在一起。显然每次合并后，任意一个结点出现且仅出现在一条路径中。因此我们可以得到一个大小为$\|V\|-\|M\|$的路径，我们将其中的$u_l$和$u_r$结点合并为一个结点$u$后就得到了原图G中的一条大小为$\|V\|-\|M\|$的不相交路径覆盖。这里我们证明了最小不相交路径覆盖的大小的上界为$\|V\|-\|M\|$，但是还未证明不存在更小的不相交路径覆盖。

同样的，对于任意一个最小不相交路径覆盖$P$，我们将其中每个顶点$v$拆成两个顶点$v_l$和$v_r$通过边$(v_l,v_r)$相连。之后我们将$P$中所有形如$(u_l, v_r)$的边提出为一个集合$Y$，很显然$Y$是图$G'$的一个匹配（因为任意顶点在$P$中最多出现一次）。而$\|P\|+\|Y\|=\|V\|$，因此$\|P\|\geq \|V\|-\|M\|$。这里证明了最小不相交路径覆盖的大小的下界同样为$\|V\|-\|M\|$。

# 最小相交路径覆盖

对于图G=(V,E)，如果顶点u到v存在一条路径，则我们向图中加入一条边$(u,v)$，这样我们得到了图$G'$。$G$中的最小相交路径覆盖与$G'$最小非相交路径覆盖是等大的。

证明：

对于图$G'$中的最小非相交路径覆盖$P$，对于P中的任意边$(u,v)$，我们知道$u$和$v$在原图$G$中一定是有路径连接的，我们用路径替换边$(u,v)$，就可以得到$G$中的一条相交路径覆盖。

同样的对于图$G$中的一条相交路径覆盖，我们可以其中的所有重复路径，替换为一条边。之后就能得到图$G'$中的一条不相交路径覆盖。

# 类型题

## HDU1150

**题目大意**

两台机器A、B，每台机器分别有n和m种模式。k个任务，每个任务可以被机器A以模式x或机器B以模式y处理。每次切换模式，都需要重启机器，问处理完所有任务最少需要重启多少次机器。

**题解**

很容易发现，这是一个二分图问题。一开始，能看出，如果我们以任务作为左边结点，而机器的状态作为右边结点，任务与机器状态的关联转换为边。问如何最少激活右边结点来使得通过网络的流量总共为k。

激活结点的问题看似可以用费用流来解决，比如每个状态与终点连一条边，边上每流量费用为1。但是实际上这个问题不是费用流问题，因为实际上只有第一个单位流的费用为1，后面的流式免费的。

实际上我们将最少激活数看做做少顶点选择数，将A机器的状态作为左边结点，将B机器的状态作为右边结点，每一个任务（i，x，y），建立一条从左边x结点到右边y结点的边。问题就是如何选择最少的顶点集合S，使得边的至少一个端点属于S，这是一个最小顶点覆盖问题，最小顶点覆盖数与最大匹配数是相等的，因此直接上KM算法即可。

## POJ3692

**题目大意**

有G个女生和B个男生，女生互相认识，男生互相认识，部分男生和女生相互认识。问最多能找到多少人，使得这些人都相互认识。

**题解**

问题实际上求的是二分图的最大团。

## POJ2060

**题目大意**

有n个订单，我们可以派出车辆去接这些订单。每个订单都有一个截止时间，接客地点，目标地点。一个车辆送客完成后可以去接下一个订单。要求每个订单，都必须有车辆去接。问最少需要多少车辆。

**题解**

问题实际求的是不相交最小路径覆盖。

## BZOJ1854

**题目大意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1854](https://www.lydsy.com/JudgeOnline/problem.php?id=1854)

**题解**

一开始想的是二分图匹配，但是数据量太大，会TLE。
可以用并查集，如果一个联通块中存在环，则联通块必定可以全选，否则至少有一个结点可以选。

# 参考文献

\[1\] [匹配 wiki介绍](https://zh.wikipedia.org/wiki/%E5%8C%B9%E9%85%8D_(%E5%9B%BE%E8%AE%BA))

\[2\] [Konig定理百度百科](https://baike.baidu.com/item/Konig%E5%AE%9A%E7%90%86)

\[3\] 算法导论

\[4\] [二分图最大匹配的König定理及其证明](http://www.matrix67.com/blog/archives/116)