---
categories: algorithm
layout: post
---

- Table
{:toc}

# Codeforces 1033E

**题意**

[https://codeforces.com/contest/1033/problem/E](https://codeforces.com/contest/1033/problem/E)

**题解**

我们可以尝试找出一株生成树，我们从前到后处理所有顶点，并且维护处理过的顶点形成边数最多的生成树。这样当新加入一个顶点的时候，我们可以二分查找，找到所有与新顶点存在边的连通块，之后对连通块进行二分查找，找到连通块中与新顶点之间恰好存在边的顶点，加入边即可。由于每次合并两个连通块都对应的会有$O(\log_2n)$次查询，因此最多的查询数目为$O(n\log_2n)$，这里常数不超过2，因此在$n=600$的时候总的请求数也不会超过$12000$。

最后我们找到了生成树就很容易判断是否有奇长环了，将树上顶点进行二分染色，之后观察同色顶点之间是否有边存在，如果有就存在了奇环。我们可以将该色的顶点压成一个序列，然后比遍历序列，直到找到某个特殊的点，这个点后面的所有顶点之间没有边，我们记这个顶为first，之后找到first后第一个顶点second，使得second与first之间有边，这里总共最多为$2n$次查询。要找到奇环，可以以first为根，搜索到second的唯一路径即可。

题目的核心是想到这题目所要求的输出，不需要你得到所有边，只需要一株生成树即可。

# Codeforces 1028G

**题意**

[https://codeforces.com/contest/1028/problem/G](https://codeforces.com/contest/1028/problem/G)

**题解**

定义$dp(l,q)$表示最大的$r-l+1$，满足在知道$x$落在$\[l,r\]$的前提下能够在$q$次请求内找到$x$。

那么可以很容易推出转移公式，同时利用$dp$也可以快速找到那些分隔点。

这个问题中由于每个请求中的值不能超过$x$，因此不可以直接均匀切分，这也是为什么要借助动态规划的原因。以后遇到这种复杂的二分查值交互题，一定不要嫌麻烦，写个动态规划。

# Codeforces 1307E

**题目**

[https://codeforces.com/contest/1307/problem/E](https://codeforces.com/contest/1307/problem/E)

**题解**

这是一道挺有趣的问题的，优化的空间很大。

首先吃同一类草的牛，一边最多只会有一只。

很容易想到一个$DP$的方式，时间复杂度为$O(n^3)$。但是这个方式铁定不行。

我们可以换一个思路，枚举从左走出走到最靠右的牛，以及从右走出走到最靠左的牛。之后我们发现其它牛就直接被分成了三类，第一类只能出现在左边，第二类只能出现在右边，第三类可以出现在两边。我们可以对吃一类草的牛独立统计贡献，总的方案数可以将所有贡献乘起来得到。

你可能会问，那时间复杂度不还是$O(n^3)$吗？是的，但是这样弄就有了优化的空间，而之前的$DP$绝对是死路一条。我们会发现为啥我们需要枚举左右两边最靠边的牛的位置呢，是为了防止重复统计，但是实际上如果从左边出来最靠右的牛确定了，右边的牛即使不确定也不会导致重复统计。因此我们这样就直接砍掉了一个$n$，时间复杂度降低为$O(n^2)$。

但是还能优化，如果我们从左往右枚举从左出发最靠右的牛时，每次下标变动的时，最多只有两只牛允许出现位置会变动。因此我们可以通过扫描并不断修改，就能保证时间复杂度为$O(n\log_2n)$，这里的$\log_2n$是因为需要用到求逆运算。

# Codeforces 1311E

**题意**

[https://codeforces.com/contest/1311/problem/E](https://codeforces.com/contest/1311/problem/E)

**题解**

很显然当树是一条链表的时候，深度之和会达到最大，而树除了深度最大的一层外，其它第$i$层正好$2^i$个顶点的时候深度最小。

总深度最小记作$m$，总深度最大记作$M$。下面我们给出一个构造性算法，每次操作都能将总深度减少1。我们从链表开始转换。现在我们开始尝试将总深度减少1：如果一个叶子的深度为$k$，且在深度$k-2$处存在一个顶点，它的孩子数少于2，那么我们称这个叶子是有效的。我们选择所有有效叶子中深度最小的，记它的深度为$k$，将其移动到某个孩子数少于2的深度为$k-2$的顶点下面。这个算法可以持续直到树的深度和达到最小。

# Codeforces 1253F

**题意**

[https://codeforces.com/contest/1253/problem/F](https://codeforces.com/contest/1253/problem/F)

**题解**

一类最小瓶颈路问题，问题3。


# Codeforces 1301F

**题意**

[https://codeforces.com/contest/1301/problem/F](https://codeforces.com/contest/1301/problem/F)

**题解**

容易发现我们可以对每个颜色作为源头进行一次BFS，这样就能保证快速得到每个位置到另外一种颜色任意位置的最短距离，记$D(c,i,j)$，表示位置$(i,j)$到颜色为$c$的任意位置的最短距离。

现在我们考虑如何找到两点的最短距离。考虑到最短距离可能出现了同色块之间的转移，也可能没出现。

没出现的情况下，这时候两点的最短距离是二者之间的曼哈顿距离。

在出现的情况下，我们可以枚举第一次发生同色转移的颜色，记这个颜色为$c$，那么此时最短距离可以分解三部分，第一部分是从颜色$c$的任意块转移到$(r_1,c_1)$，第二部分是从颜色为$c$的任意块转移到$(r_2,c_2)$，第三部分就是我们枚举的$c$颜色的两个位置的转移，因此此时的最短距离为$D(c,r_1,c_1)+D(c,r_2,c_2)+1$。

总的时间复杂度为$O(knm+qk)$，需要注意不要用太多$stl$的东西，这道题目卡常严重。

# Codeforces 1305G Kuroni and Antihype

**题意**

[https://codeforces.com/contest/1305/problem/G](https://codeforces.com/contest/1305/problem/G)

**题解**

首先我们先认为每个人的权值都不同。

我们可以加入一个权值为0的人（记作第$n+1$个人），并且认为这个人一开始就加入了Antihype。同时我们可以假设所有的数都不能自主加入Antihype，必须通过他人邀请才能加入。可以发现这样不会改变结果。

首先我们想一个naive的方法，如果两个人$i,j$是朋友，那么我们可以加入两条单向边$(i,j),(j,i)$，前者的权值为$a_j$，后者的权值为$a_i$。现在我们希望选择其中一部分边，并拿到这些边的权值。选择的规则如下：

- 每个顶点最多有一条入边被激活。
- 沿着顶点的入边不断后退，最后一定会回到顶点$n+1$。

很显然这最终得到的是一个有向图生成树（树形图），同时我们要求权值最大，即要求求最大权树形图，这可以用最小树形图算法解决，时间复杂度是$O(E\log_2V)$。$V=n+1$，是已知，但是$E$可以有多大呢。

任意两个数且运算后位0，那么我们可以枚举$0$到$2^{18}-1$的每个数$x$，以及$x$的子集$a$，这样就可以找到另外一个数$b=x-a$。这样统计的好处是不会出现重复（我们可以恒要求$a>b$来避免重复）。

通过上面算法，我们可以找到所有的边，以及估计出了边的总数为$O(3^{18})$，数量级是3亿级别的。因此上面的算法自然无法通过。（但是至少我们得出了一个比$O(n^2)$或$O(4^{18})$更好的方法）。

我们可以考虑另外一种统计方案，记$out(v)$表示顶点$v$的出度。那么我们实际要统计的是：

$$
\sum_{v}out(v) a_v
$$

上面的公式不能帮助我们太多，但是如果我们用无向边来替代有向边，那么我们会发现每个顶点的出度都会增大1（因为原来的唯一入边也转换成了出边），现在我们记$deg(v)$表示顶点$v$的度数，我们要求的就是：

$$
\sum_{v}(deg(v)-1) a_v=\sum_{v}deg(v)a_v+\sum_va_v
$$

其中$\sum_va_v$是常数，我们可以忽略，现在我们希望$\sum_{v}deg(v)a_v$最大。这个玩意可以将其转换为最小生成树问题（可以参考最小生成树的一些题目-题目1）。

现在我们面对的问题是找到一颗最小生成树。我们可以考虑使用kruskal算法，kruskal要求对边按边权排序，我们可以很自然的从大到小枚举$x$即可。这样我们就给出了一个$O(3^{18}\alpha(n))$，其中$\alpha(n)$是反阿克曼函数，可以直接作为常数看待。

最后还剩下一个问题，就是存在重复的权值。我们可以这样考虑，如果在枚举到$(u,v)$的时候，$u$有$c(u)$个处于不同连通块的人，而$v$有$c(v)$个处于不同连通块的人，我们要让它们连通，只需要加$c(u)+c(v)-1$条边即可，之后他们就连通了，修改$c(u),c(v)$为1即可。

总的时间复杂度为$O(3^{18}\alpha(n))$。

# Codeforces1205D

**题意**

[https://codeforces.com/problemset/problem/1205/D](https://codeforces.com/problemset/problem/1205/D)

**题解**

如果我们为根结点赋予权重0，并且为其余结点均赋予不小于父结点权重的权重。那么我们可以通过差分得到连接父子结点的边的权重，并且权重非负。现在考虑要为一株树上的n个顶点赋予一组权重，我们可以遍历整棵树，按照遍历的顺序从小到大赋予权重，这样进行差分后得到的边的权重均非负，且从根结点到树中任意顶点v的路径总权等于v的顶点权重。

考虑星图，我们认为根结点下挂n-1个顶点。我们任意选择一个C，满足$n/3\leq C \leq 2n/3$。并为前C个子结点赋予权重$1,2,\ldots, C$，而后面的$n-C-1$个子结点赋予权重$(C+1),2(C+1),\ldots, (n-C-1)(C+1)$，这样利用前C个顶点和后n-C-1个顶点我们就可以组合得到$\[1,2n^2/9\]$之间的所有值了。

考虑一般的树，我们找到树的重心，可知重心下最大子树的大小不超过$n/2$。我们可以排序重心下的子顶点，并贪心找到一组子树，使得总大小C落在区间$\[n/3,2n/3\]$中。之和，我们为这组子树中顶点赋予权重1~C，而其余子树中顶点赋予权重$(C+1),2(C+1),\ldots, (n-C-1)(C+1)$。

# Codeforces1209F

**题意**

[https://codeforces.com/contest/1209/problem/F](https://codeforces.com/contest/1209/problem/F)

**题解**

我的做法和题解的不太一样。

首先观察问题，假设1到x的最短路径为1,..,y, x，那么x的数值则是在y的数值的尾部添加若干数字得到，即x的数值一定大于y的数值。我们发现这个性质有点类似于最短路问题，且在这种意义上，我们可以推出边权是非负的。这样我们就可以堂而皇之地使用Dijkstra算法解决它。

首先我们解决一个问题，如果进行比较操作，即如何判断离1所在连通块最近的顶点。

我们可以用一株前缀树维护所有顶点的最短距离，这样每个顶点所在的最短距离就是前缀树的某个顶点。这里我们需要使用动态开点技术，由于每条边最多建立$\log_2m$个前缀树顶点，因此前缀树的大小是$O(m\log_2m)$的。

之后如果比较两个顶点与1所在连通块的距离，我们知道距离已经被我们映射为了前缀树的顶点。因此就是比较两个顶点所代表的数值的大小。

由于边没有前置0，那么深度不同的顶点的大小，可以完全通过深度进行判断，深度较小的顶点代表的数值一定较小。

之后如何判断深度相同的顶点呢，我们必须找到两者的LCA。而要在一个动态加点的前缀树上找LCA，最简单的方式就是倍增技术，为每个顶点维护一个大小为20的数组bl，其中$bl[i]$表示距离当前顶点$2^i$的祖先顶点。这样判断操作就可以在$O(20)$时间内得到。

考虑总的时间复杂度，由于比较会发生$O((n+m)\log_2n)$次，因此总的时间复杂度为$O(20(n+m)\log_2n)$，是可以通过的。

# Codeforces 1312F

**题意**

[https://codeforces.com/contest/1312/problem/F](https://codeforces.com/contest/1312/problem/F)

**题解**

SG函数的循环节上限为$4^{15}$，但是实际上却往往非常小。暴力找出循环节，之后就可以$O(1)$查SG函数了。之后遇到循环节的问题，一定敢暴力，不要被上限所困，因为理论上的上限一般都很难出现。


# Codeforces 1110F

**题意**

[https://codeforces.com/contest/1110/problem/F](https://codeforces.com/contest/1110/problem/F)

**题解**

我竟然想要用ETT来解决这个问题，重点是我也不会ETT，菜得真实。

我们先求出每个顶点到顶点1的距离。之后以顶点1位根进行深度优先搜索。当我们沿着一条边从父结点移动到子结点的时候，容易发现，所有的顶点可以分成三类，第一类是不属于子结点的子树中ID小于子结点的顶点，第二类是属于子结点的子树中的顶点，第三类是不属于子结点的子树中ID大于子结点的顶点。这三类顶点的ID都是连续的区间，这意味着三次区间修改操作，就可以将距离修正。

维护一个线段树，进入子结点时修正距离，离开子结点的时候恢复距离。访问到某个顶点时顺带处理掉所有与它相关的请求即可。

NOTE：非常多的树上查询问题都可以通过将问题挂载到对应的顶点上，并且利用深度优先搜索进行解决。

# 树上卷积问题

考虑一株树，每个顶点$v$都对应一个一阶多项式$f(v)$。现在我们为每个顶点$v$定义一个新的多项式$g(v)$，其定义为：

$$
g(v)=f(v)\prod_{u \in children(v)}g(u)
$$

现在我们为每个顶点提交一个查询，关联与顶点$i$的查询为$q_i$，其询问$g(v)$的$x^{q_i}$项的系数。

很显然我们可以DFS计算每个顶点关联的查询。现在问题是时间复杂度是多少。

我们这里可以直接暴力计算多项式，即用$O(n^2)$的算法。那么时间复杂度为多少呢。

我们知道时间复杂度肯定不会超过$O(n^3)$，但是具体是多少呢。

可以考虑这样的问题，考虑任意两个顶点$u,v$，及其最低公共祖先$a$，很显然在计算$g(a)$时，$u$和$v$会产生一次贡献。而任意一对顶点的唯一一次贡献仅发生在LCA上，因此时间复杂度为$O(n^2)$。

# Codeforces1260F

**题意**

[https://codeforces.com/contest/1260/problem/F](https://codeforces.com/contest/1260/problem/F)

**题解**

毒瘤题。

仅考虑颜色c。我们记V(i)为一个指示器，如果$l_i\leq c\leq r_i$，那么$V(i)$为真，否则为假。记$g(i)=r_i-l_i+1$，记$p=\prod_{i=1}^n g(i)$。

于是单独考虑颜色c的贡献，为：

$$
\sum_{V(i)\land V(j)\land i<j}dist(i,j)\frac{p}{g(i)g(j)}=p\sum_{V(i)\land V(j)\land i<j}dist(i,j)\frac{1}{g(i)g(j)}
$$

这里我们可以稍微变更一下，记$dep(i)$表示顶点i在树中的深度，那么有

$$
dist(i,j)=dep(i)+dep(j)-2dep(lca(i,j))
$$

其中$lca(i,j)$为顶点i和顶点j的最近公共祖先。代入之前的公式得到：

$$
\sum_{V(i)\land V(j)\land i<j}dist(i,j)\frac{1}{g(i)g(j)}\\
=\sum_{V(i)\land V(j)\land i<j}(dep(i)+dep(j)-2dep(lca(i,j)))\frac{1}{g(i)g(j)}\\
=\sum_{V(i)\land V(j)\land i<j}dep(i)\frac{1}{g(i)g(j)}+\sum_{V(i)\land V(j)\land i<j}dep(j)\frac{1}{g(i)g(j)}
+\sum_{V(i)\land V(j)\land i<j}2dep(lca(i,j))\frac{1}{g(i)g(j)}\\
=\sum_{V(i)}dep(i)\frac{1}{g(i)}(\sum_{V(j)}\frac{1}{g(j)})-\sum_{V(i)}dep(i)\frac{1}{g(i)^2}+2\sum_{V(i)\land V(j)\land i<j}dep(lca(i,j))\frac{1}{g(i)g(j)}
$$

现在我们考虑从颜色c转移到c+1，这时候我们会删除一些顶点，同时加入一些顶点。我们希望能在删除加入顶点的同时维护整个公式。事实上，前两项是很容易维护的，这里不另外讨论。最后一项，我们可以这样统计：

$$
\sum_{V(i)\land V(j)\land i<j}dep(lca(i,j))\frac{1}{g(i)g(j)}\\
=\sum_{V(i)}\frac{1}{g(i)}\sum_{V(j)\land i<j}dep(lca(i,j))\frac{1}{g(j)}
$$


我们维护一棵树，每次加入一个顶点x时，结果需要增加从顶点x到根顶点的路径上所有顶点的值，同时我们将顶点x到根节点的路径上所有顶点的值加上$\frac{1}{g(x)}$。（这里我们用到了，考虑两个顶点a和b，二者的公共前缀长度为dep(lca(a,b))，因此我们可以路径加总来替代$dep$函数的使用）。这涉及到路径操作，轻重链剖分或者LCT都可以。

# Codeforces 1111E

**题意**

[https://codeforces.com/contest/1111/problem/E](https://codeforces.com/contest/1111/problem/E)

**题解**

挺不错的问题。首先可以发现这个问题是树上DP问题，但是DP非常难推，且推出来的效率也很低。

我们可以换个思路，一个顶点$u$其只有$x$个禁止加入的分组（与集合中祖先数目相同），如果我们按照顶点的深度从小到大处理，那么如果此时已经存在$k$个分组，那么$u$或者加入已经存在的$k-x$个分组，或者重新创立一个分组。

剩下的就是如何快速确认每个顶点到根有多少个祖先顶点被选中，很简单，动态树即可。将选中的顶点的值全部设置为1，其余的设置为0，那么顶点到根之间祖先数目等于顶点到根这条路径上的值之和减去1（顶点自身）。（同时动态树还支持换根操作）

这个问题实际上还可以引出更加有趣的一种组合数学问题，第二类斯特林数，对于$n$个不同的元素，我们希望将它们分成不空的$k$组，有多少种分法。

# Codeforces 1083C

**题意**

[https://codeforces.com/contest/1083/problem/C](https://codeforces.com/contest/1083/problem/C)

**题解**

我们可以将整棵树放到线段树上维护，线段树上`[l,r]`表示的是从`l`到`r`排列对应的所有顶点，是否处于一条路径上。于是我们要找的结果就是最大的`k`使得`[0,k-1]`对应的顶点都处于一条路径上。这里满足二分的性质，所以我们可以在线段树上二分即可。

下面还需要提到一个问题，如何合并两个区间A和B。如果一个区间的所有顶点处于同一条路径上，我们只需要路径的两个端点就可以得到路径的所有信息了，我们可以在区间中保存路径的两个端点。现在考虑当区间A与B都满足所有顶点处于一条路径上时，是否能将两条路径合并为一条。如果能合并，最后得到的路径的两个端点必定是这四个端点中距离最远的两个，我们可以暴力枚举，找到距离最远的两个端点即可，之后判断所有四个端点是否都落于得到的新的路径上。

这里还可以提一下，线段树是自然支持二分的，因此我们可以在从上向下遍历线段树的时候完成二分过程，因此，总的时间复杂度为$O(n+q\log_2n)$。

# CF1174D

**题意：**

[https://codeforces.com/contest/1174/problem/D](https://codeforces.com/contest/1174/problem/D)

**题解：**

我们可以记构造好的序列为a，而序列a的前缀为b，即b\[i\]=a\[1\]^...^a\[i\]。

任意一段子序列，都可以表示为两个前缀的亦或和，换言之，我们现在需要找到满足条件的一组前缀，使得两两亦或和不为0和x。不为0意味着每个前缀都不同。不为x，意味着对于任意一个数t，t与t^x只能选择一个。因此我们可以通过维护1~2^n个数的可用状况，构造最长的一个前缀，之后将前缀转换为数组。

# Codeforces 1033F

**题意**

[https://codeforces.com/contest/1033/problem/F](https://codeforces.com/contest/1033/problem/F)

**题解**

首先$n$这个东西是障眼法，因为取值只可能有$2^w$种，我们可以一开始就记录下每个数出现的次数。下面考虑单独处理每个请求，对于一个请求，考虑它的第$i$位的运算，我们可以发现要保证这一位为0，那么最多有3种可能性（总共4种可能性，但是由于至少有一种可能性的结果为1，因此最多还剩3种可能性）。于是我们可以递归暴力枚举，这样的时间复杂度为$O(n+m3^w)$，稍微有点大。

但是注意到所有位运算符都满足交换性，因此我们可以把01和10两种情况压缩成一种，我们可以将00记作0，01和10记作1，11记作2（就是1出现的数目而已）。这样我们发现每个运算符最多只能在两种可能性下给出结果0，因此我们可以暴力枚举这两种可能性，总的时间复杂度就降为了$O(n+m2^w)$。

具体实现，我们可以维护一个多维数组，记录每一位和满足某个条件的二元组数目。这里由于会出现动态维护的多维数组，比较麻烦，我们可以直接将其作为三进制进行压缩即可。

总的时间复杂度为$O(n+m2^w+w(2^w)^2)$。

这里还有一个发现，就是如果我们将每个数先转成二进制形式，之后将二进制直接当成三进制处理的话，就可以直接用加法来预处理那个多维数组了。即多维数组的第$k$项的值为$\sum_{i+j=k}C_iC_j$，其中$C_i$表示三进制为$i$的数出现次数，$C_j$同理。这是一个卷积，我们可以直接用FFT计算，这样预处理的时间复杂度就会从$w(2^w)^2$降低到$w3^w$。

# Codeforces1208F

**题意**

[https://codeforces.com/contest/1208/problem/F](https://codeforces.com/contest/1208/problem/F)

**题解**

好题。直接给出解法：

我们先处理
$$
a_j \& a_k
$$
，我们定义函数$f(x)$，其值表示x的所有二进制超集中的下标，如果不存在则返回-1。我们可以为每个可能值（M个）维护一个集合，之后按x从大到小计算$f(x)$。注意到我们实际上只需要考虑这些集合中最大的两个下标，因此可以用一个大小为2的最大堆替代上面提到的集合。

之后问题就变成了问集合中任取两个下标不同的元素，求最大或。

我们可以遍历所有可能的第一个元素x。之后我们求不在x中出现的最大位对应的值t，判断t是否出现在x右边，如果出现，则表示可以取到，否则取不到。之后继续处理剩余的位。

时间复杂度为$O((N+M)\log_2M)$，其中M为取值范围，N为数组大小。

# Codeforces1136E

**题意**

[https://codeforces.com/problemset/problem/1136/E](https://codeforces.com/problemset/problem/1136/E)

**题解**

可以发现，问题可以表述为：

$$
\left\{
\begin{array}{lcr}
a_2-k_1&\geq& a_1\\
a_3-k_2-k_1&\geq& a_2-k_1\\
\ldots\\
a_n-k_{n-1}-\ldots-k_1&\geq& a_{n-1}-k_{n-2}-\ldots-k_1
\end{array}
\right.
$$

即我们可以发现我们将每个数字$a_i$分成了两部分$a_i-k_{i-1}-\ldots-k_1$和$k_{i-1}+\ldots+k_1$的和。后面部分是不会改变的，而前面的部分是非严格递增的，因此可以用线段树维护。


# Codeforces 1146G

**问题:**

见链接[https://codeforces.com/contest/1146/problem/G](https://codeforces.com/contest/1146/problem/G)

**题解:**

令$dp(i,j,k)$表示仅考虑地点i..j，建立最高的屋子的高度不超过k时能获得的最大收益，其中惩罚条款仅考虑那些完全限于i..j内部的条款。要计算$dp(i,j,k)$，我们可以记m为房屋i..j中最高的那座，m可以通过枚举得到。之后如果$m<k$，那么很显然$dp(i,j,k)=dp(i,j,k-1)$。现在仅考虑$m=k$的情况。可以推出公式为：


$$
dp(i,j,k)=\min_m(dp(i,j,k-1),dp(i,m-1,k)+dp(m+1,j,k)+k^2-penalty)
$$

# Codeforces 1146H

**问题:**

见链接[https://codeforces.com/contest/1146/problem/H](https://codeforces.com/contest/1146/problem/H)

**题解:**

记$dp(i,j,k)$表示以顶点i开始结束，长度为k的凸包的数量。为了组成凸包，我们可以将一开始的所有线段按照斜率进行排序。之后我们可以遍历每条线段，并用线段对动态规划公式做补充，这样可以保证得到的折线的联结一定是凸包。

最后统计$\sum_idp(i,i,5)$即可。



# CF1168C

**问题:**

见链接[https://codeforces.com/contest/1168/problem/C](https://codeforces.com/contest/1168/problem/C)

**题解:**

定义dp(i,j)表示所有带j比特中能被i访问到的，且下标最小的数的下标。则可以认为数a[dp(i,j)]或者可以被a[i]直接访问或者被a[i]间接访问，可以被a[i]直接访问的数最多有20个。可以通过动态规划公式得到结果。



# CF1168D

**问题:**

见链接[https://codeforces.com/contest/1168/problem/C](https://codeforces.com/contest/1168/problem/C)

**题解:**

题解说可以通过树链剖分解决，不知道怎么做。按照题解里的来吧。

首先要满足条件，叶结点的深度一定相同。我们记$h_i$表示深度为i的结点的数目，那么不等式一定成立：$h_1\leq h_2 \leq \ldots$，如果我们发现两个相连的深度有等量结点，那么我们可以将两层压缩为一层。由于压缩后的数满足$h_1< h_2 < \ldots$，因此压缩后的树最高为$O(\sqrt(n))$


# Codeforces1117F

**题意**

[https://codeforces.com/problemset/problem/1117/F](https://codeforces.com/problemset/problem/1117/F)

**题解**

很容易想到这是一个位压DP，但是如何判断一个删除策略是否合法呢，这是需要解决的问题。

我们为每个序列中的字符，维护两个列表prev、next。`prev[i]`存储第i个字符之前最近的k种字符的出现顺序，而`next[i]`存储第i个字符之后最近的k种字符的出现顺序。

接着我们考虑所有的字符。假设处理到的字符为u，且u之前存在某个字符v与其不能相邻，那么记s为u与v之间的字符对应的二进制位的或。那么我们需要对s以及所有父集打一个+1标记，同时由于如果u、v中有一个已经被删除了，那么就不会冲突，我们对`s|(1<<u)`和`s|(1<<v)`分别打一个-1标记。而由于`s|(1<<u)|(1<<v)`以及所有父集被多打了一次-1标记，因此我们在上面打一个`+1`标记。如果一个删除状态被打的+1标记多于-1标记，那么这个状态是非法的。

最后问题来了，如何上推标记，很简单用FWT即可。

总的时间复杂度为$O(pn+p2^p)$。

# Codeforces1107F

**题意**

[https://codeforces.com/contest/1107/problem/F](https://codeforces.com/contest/1107/problem/F)

**题解**

首先容易想到最小费用最大流的做法，但是它是$O(n^3)$的。

我们可以将接受的offer分成两类，第一类是我们在买车之前不能还完的，第二类是我们在买车之前能还完的。

仅考虑第一类，我们会发现按照$b_i$从小到大排序后，我们依次进行贷款所需费用最小，而选择的顺序对于第二类是不重要的。因此我们可以进行DP，记$dp(i,j)$表示仅考虑$b_i$从大到小排序前面$i$个offer，总共有$j$个是属于第一类的，问最多能赚多少钱。之后动态规划即可，总的时间复杂度为$O(n^2)$。

# Codeforces1093F

**题意**

[https://codeforces.com/contest/1093/problem/F](https://codeforces.com/contest/1093/problem/F)

**题解**

初看比较奇怪的问题。很显然得用DP。

记录`dp[i][j][k]`表示处理前$i$个字符后，最后一个字符为$j$，最后一个字符已经连续出现了$k$次了。

那么很容易推出转移公式，但是状态有$n^2k$种，很显然过不了。但是仔细观察递推项，会发现`dp[i][j][k]`和`dp[i-1][j][k-1]`完全相同。因此如果我们把状态数组搞成可旋转的，就可以以$O(k)$的时间复杂度从`dp[i-1]`直接得出`dp[i]`。这样总的时间复杂度和空间复杂度都为$O(nk)$。

这种做法比较取巧。个人认为官方的做法比较好，官方的做法定义`dp[i][j]`表示处理完了前$i$个字符后，最后一个字符为`j`的所有有效方案数。

于是可以直接得出$dp\[i\]\[j\]=\sum_{t=1}^k dp\[i-1\]\[t\]$。但是这个公式有一个问题，没有考虑子段不能连续出现$len$个相同字符。这里唯一的一种情况是最后一个字符与前面$len-1$个字符完全相同。我们要减去这些非法状态，非法状态的数目为$\sum_{t=1}^k\[t\neq j\]dp\[i-len\]\[t\]$。


# Codeforces 1056G

**题目**

[https://codeforces.com/contest/1056/problem/G](https://codeforces.com/contest/1056/problem/G)

**题解**

由于$n$比较小，所有我们可以先保证$t$能整除$n$（重复操作直到）。

之后我们可以记录$dp(i,j)$表示从第$i$个位置开始移动$j,j-1,\ldots,1$后所抵达的位置。不难发现，当$i\leq m$时有$dp(i,j)=dp(i+j,j-1)$，在其他位置则有$dp(i,j)=dp(i-j,j-1)$。这意味着$dp(i,?)$是由$dp(i-1,?)$的碎片拼接而成的（最多有四个碎片）。我们可以利用持久化平衡树来优化加速，时间复杂度为$O(n\log_2n)$。

要写一个持久化平衡树太麻烦了，直接上`rope`好了。

# Codeforces 1060F Shrinking Tree

**题意**

[https://codeforces.com/contest/1060/problem/F](https://codeforces.com/contest/1060/problem/F)

**题解**

很诡异的题目，比赛的时候但凡有点思路就又被自己否决了。

树上DP大家应该都知道这么做，可是怎么DP这才是最大的难题。看了其他人的题解后，也没法完全搞懂，这里记录一下。

由于$n$很小，我们可以对每个顶点作为根独立统计一次。下面我们仅考虑1号顶点作为根的情况。

首先统计概率比较麻烦，我们可以统计有多少方案能保证1号顶点最终存活，之后除去$2^{n-1}(n-1)!$得到真实的概率。

为什么这道题难呢，因为每条边对方案数的贡献可能是2，也可能是1（取决于是否与1号顶点相连），且树的形态也会改变。

首先我们避免树的形态改变，我们可以这样理解删边操作，每次删边后，会将边的两端顶点的连通块合并，而实际标号是等概率取两边连通块的标号之1。

我们定义两个辅助函数：

- $f(u,i)$表示顶点$u$为根的子树对应的所有方案中（共$2^{size(u)-1}(size(u)-1)!$种方案），除了前$i$条删除的边外，后面的所有删除的边都不会修改$u$的标号的方案的数目。
- 记$p$为$u$的父亲，定义$g(u,i)$表示以$u$为根的子树，加上$(u,p)$这条边的所有方案中（共$2^{size(u)}size(u)!$种方案），除了前$i$条删除的边外，后面的所有删除的边都不会修改$p$的标号的方案的数目。

如果我们为每个顶点算出了$f$和$g$函数值，那么$f(1,0)$就是我们要求的结果。

要计算$f(u,i)$，我们可以假设$u$下有$a,b,c$三个顶点，那么

$$
f(u,i)=\sum_{c_a+c_b+c_c=i}g(a,c_a)g(b,c_b)g(c,c_c)\frac{i!}{c_a!c_b!c_c!}\frac{(size(u)-1-i)!}{(size(a)-c_a)!(size(b)-c_b)!(size(c)-c_c)!}
$$

这个公式可以通过类似多项式卷积的方式得到，由于是树上DP，且任意两个顶点最多对时间复杂度贡献1，因此计算函数$f$总的时间复杂度为$O(n^2)$。

下面考虑$g(u,i)$怎么计算。这里我们额外加入了边$(u,p)$。可以分两种情况讨论：
- 如果$(u,p)$是前$i$条删除的边中的一个，即早于$p$的标号被修改为1之前，这时候删除这条边，无论选择使用哪个连通块的标号都是没问题的，而除了$(u,p)$外还有$i-1$条$u$子树内的边被删除。且之后删除的所有$u$子树的边都不应该修改$u$的标号（因为这时候$u$和$p$在一个连通块了，如果修改$u$就会同时修改$p$），因此$g(u,i)$得到了$2if(u,i-1)$的贡献（乘2是因为可以任意选择连通块的标号，乘上i是因为$(u,p)$可能是作为第$1,2,\ldots,i$条边被删除的。）。
- 否则$(u,p)$不属于前$i$条被删除的边，这时候它可能是作为第$i+1,i+2,\ldots, size(u)$个边被删除的。如果它是作为第$j$条边被删除的，那么它对$g(u,i)$的贡献应该为$f(u,j-1)$，即在$u$的子树下删除了$j-1$条边后，剩余的删除操作都不应该更高$u$的标号。

结合上面讨论的可以得出：

$$
g(u,i)=2if(u,i-1)+\sum_{j=i}^{size(u)}f(u,j-1)
$$

这里我可以通过预处理后缀的技术，每个顶点以$O(n)$时间复杂度算出函数$g$的值。

对于根选定的情况下，总的时间复杂度为$O(n^2)$，每个顶点都需要作为根算一次，因此总的时间复杂度为$O(n^3)$。