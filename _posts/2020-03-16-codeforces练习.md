---
categories: algorithm
layout: post
---

- Table
{:toc}

# Codeforces 1033E

**题意**

[https://codeforces.com/contest/1033/problem/E](https://codeforces.com/contest/1033/problem/E)

**题解**

我们可以尝试找出一株生成树，我们从前到后处理所有顶点，并且维护处理过的顶点形成边数最多的生成树。这样当新加入一个顶点的时候，我们可以二分查找，找到所有与新顶点存在边的连通块，之后对连通块进行二分查找，找到连通块中与新顶点之间恰好存在边的顶点，加入边即可。由于每次合并两个连通块都对应的会有$O(\log_2n)$次查询，因此最多的查询数目为$O(n\log_2n)$，这里常数不超过2，因此在$n=600$的时候总的请求数也不会超过$12000$。

最后我们找到了生成树就很容易判断是否有奇长环了，将树上顶点进行二分染色，之后观察同色顶点之间是否有边存在，如果有就存在了奇环。我们可以将该色的顶点压成一个序列，然后比遍历序列，直到找到某个特殊的点，这个点后面的所有顶点之间没有边，我们记这个顶为first，之后找到first后第一个顶点second，使得second与first之间有边，这里总共最多为$2n$次查询。要找到奇环，可以以first为根，搜索到second的唯一路径即可。

题目的核心是想到这题目所要求的输出，不需要你得到所有边，只需要一株生成树即可。

# Codeforces 1028G

**题意**

[https://codeforces.com/contest/1028/problem/G](https://codeforces.com/contest/1028/problem/G)

**题解**

定义$dp(l,q)$表示最大的$r-l+1$，满足在知道$x$落在$\[l,r\]$的前提下能够在$q$次请求内找到$x$。

那么可以很容易推出转移公式，同时利用$dp$也可以快速找到那些分隔点。

这个问题中由于每个请求中的值不能超过$x$，因此不可以直接均匀切分，这也是为什么要借助动态规划的原因。以后遇到这种复杂的二分查值交互题，一定不要嫌麻烦，写个动态规划。

# Codeforces 1307E

**题目**

[https://codeforces.com/contest/1307/problem/E](https://codeforces.com/contest/1307/problem/E)

**题解**

这是一道挺有趣的问题的，优化的空间很大。

首先吃同一类草的牛，一边最多只会有一只。

很容易想到一个$DP$的方式，时间复杂度为$O(n^3)$。但是这个方式铁定不行。

我们可以换一个思路，枚举从左走出走到最靠右的牛，以及从右走出走到最靠左的牛。之后我们发现其它牛就直接被分成了三类，第一类只能出现在左边，第二类只能出现在右边，第三类可以出现在两边。我们可以对吃一类草的牛独立统计贡献，总的方案数可以将所有贡献乘起来得到。

你可能会问，那时间复杂度不还是$O(n^3)$吗？是的，但是这样弄就有了优化的空间，而之前的$DP$绝对是死路一条。我们会发现为啥我们需要枚举左右两边最靠边的牛的位置呢，是为了防止重复统计，但是实际上如果从左边出来最靠右的牛确定了，右边的牛即使不确定也不会导致重复统计。因此我们这样就直接砍掉了一个$n$，时间复杂度降低为$O(n^2)$。

但是还能优化，如果我们从左往右枚举从左出发最靠右的牛时，每次下标变动的时，最多只有两只牛允许出现位置会变动。因此我们可以通过扫描并不断修改，就能保证时间复杂度为$O(n\log_2n)$，这里的$\log_2n$是因为需要用到求逆运算。

# Codeforces 1311E

**题意**

[https://codeforces.com/contest/1311/problem/E](https://codeforces.com/contest/1311/problem/E)

**题解**

很显然当树是一条链表的时候，深度之和会达到最大，而树除了深度最大的一层外，其它第$i$层正好$2^i$个顶点的时候深度最小。

总深度最小记作$m$，总深度最大记作$M$。下面我们给出一个构造性算法，每次操作都能将总深度减少1。我们从链表开始转换。现在我们开始尝试将总深度减少1：如果一个叶子的深度为$k$，且在深度$k-2$处存在一个顶点，它的孩子数少于2，那么我们称这个叶子是有效的。我们选择所有有效叶子中深度最小的，记它的深度为$k$，将其移动到某个孩子数少于2的深度为$k-2$的顶点下面。这个算法可以持续直到树的深度和达到最小。

# Codeforces 1253F

**题意**

[https://codeforces.com/contest/1253/problem/F](https://codeforces.com/contest/1253/problem/F)

**题解**

一类最小瓶颈路问题，问题3。


# Codeforces 1301F

**题意**

[https://codeforces.com/contest/1301/problem/F](https://codeforces.com/contest/1301/problem/F)

**题解**

容易发现我们可以对每个颜色作为源头进行一次BFS，这样就能保证快速得到每个位置到另外一种颜色任意位置的最短距离，记$D(c,i,j)$，表示位置$(i,j)$到颜色为$c$的任意位置的最短距离。

现在我们考虑如何找到两点的最短距离。考虑到最短距离可能出现了同色块之间的转移，也可能没出现。

没出现的情况下，这时候两点的最短距离是二者之间的曼哈顿距离。

在出现的情况下，我们可以枚举第一次发生同色转移的颜色，记这个颜色为$c$，那么此时最短距离可以分解三部分，第一部分是从颜色$c$的任意块转移到$(r_1,c_1)$，第二部分是从颜色为$c$的任意块转移到$(r_2,c_2)$，第三部分就是我们枚举的$c$颜色的两个位置的转移，因此此时的最短距离为$D(c,r_1,c_1)+D(c,r_2,c_2)+1$。

总的时间复杂度为$O(knm+qk)$，需要注意不要用太多$stl$的东西，这道题目卡常严重。

# Codeforces 1305G Kuroni and Antihype

**题意**

[https://codeforces.com/contest/1305/problem/G](https://codeforces.com/contest/1305/problem/G)

**题解**

首先我们先认为每个人的权值都不同。

我们可以加入一个权值为0的人（记作第$n+1$个人），并且认为这个人一开始就加入了Antihype。同时我们可以假设所有的数都不能自主加入Antihype，必须通过他人邀请才能加入。可以发现这样不会改变结果。

首先我们想一个naive的方法，如果两个人$i,j$是朋友，那么我们可以加入两条单向边$(i,j),(j,i)$，前者的权值为$a_j$，后者的权值为$a_i$。现在我们希望选择其中一部分边，并拿到这些边的权值。选择的规则如下：

- 每个顶点最多有一条入边被激活。
- 沿着顶点的入边不断后退，最后一定会回到顶点$n+1$。

很显然这最终得到的是一个有向图生成树（树形图），同时我们要求权值最大，即要求求最大权树形图，这可以用最小树形图算法解决，时间复杂度是$O(E\log_2V)$。$V=n+1$，是已知，但是$E$可以有多大呢。

任意两个数且运算后位0，那么我们可以枚举$0$到$2^{18}-1$的每个数$x$，以及$x$的子集$a$，这样就可以找到另外一个数$b=x-a$。这样统计的好处是不会出现重复（我们可以恒要求$a>b$来避免重复）。

通过上面算法，我们可以找到所有的边，以及估计出了边的总数为$O(3^{18})$，数量级是3亿级别的。因此上面的算法自然无法通过。（但是至少我们得出了一个比$O(n^2)$或$O(4^{18})$更好的方法）。

我们可以考虑另外一种统计方案，记$out(v)$表示顶点$v$的出度。那么我们实际要统计的是：

$$
\sum_{v}out(v) a_v
$$

上面的公式不能帮助我们太多，但是如果我们用无向边来替代有向边，那么我们会发现每个顶点的出度都会增大1（因为原来的唯一入边也转换成了出边），现在我们记$deg(v)$表示顶点$v$的度数，我们要求的就是：

$$
\sum_{v}(deg(v)-1) a_v=\sum_{v}deg(v)a_v+\sum_va_v
$$

其中$\sum_va_v$是常数，我们可以忽略，现在我们希望$\sum_{v}deg(v)a_v$最大。这个玩意可以将其转换为最小生成树问题（可以参考最小生成树的一些题目-题目1）。

现在我们面对的问题是找到一颗最小生成树。我们可以考虑使用kruskal算法，kruskal要求对边按边权排序，我们可以很自然的从大到小枚举$x$即可。这样我们就给出了一个$O(3^{18}\alpha(n))$，其中$\alpha(n)$是反阿克曼函数，可以直接作为常数看待。

最后还剩下一个问题，就是存在重复的权值。我们可以这样考虑，如果在枚举到$(u,v)$的时候，$u$有$c(u)$个处于不同连通块的人，而$v$有$c(v)$个处于不同连通块的人，我们要让它们连通，只需要加$c(u)+c(v)-1$条边即可，之后他们就连通了，修改$c(u),c(v)$为1即可。

总的时间复杂度为$O(3^{18}\alpha(n))$。

# Codeforces1205D

**题意**

[https://codeforces.com/problemset/problem/1205/D](https://codeforces.com/problemset/problem/1205/D)

**题解**

如果我们为根结点赋予权重0，并且为其余结点均赋予不小于父结点权重的权重。那么我们可以通过差分得到连接父子结点的边的权重，并且权重非负。现在考虑要为一株树上的n个顶点赋予一组权重，我们可以遍历整棵树，按照遍历的顺序从小到大赋予权重，这样进行差分后得到的边的权重均非负，且从根结点到树中任意顶点v的路径总权等于v的顶点权重。

考虑星图，我们认为根结点下挂n-1个顶点。我们任意选择一个C，满足$n/3\leq C \leq 2n/3$。并为前C个子结点赋予权重$1,2,\ldots, C$，而后面的$n-C-1$个子结点赋予权重$(C+1),2(C+1),\ldots, (n-C-1)(C+1)$，这样利用前C个顶点和后n-C-1个顶点我们就可以组合得到$\[1,2n^2/9\]$之间的所有值了。

考虑一般的树，我们找到树的重心，可知重心下最大子树的大小不超过$n/2$。我们可以排序重心下的子顶点，并贪心找到一组子树，使得总大小C落在区间$\[n/3,2n/3\]$中。之和，我们为这组子树中顶点赋予权重1~C，而其余子树中顶点赋予权重$(C+1),2(C+1),\ldots, (n-C-1)(C+1)$。

# Codeforces1209F

**题意**

[https://codeforces.com/contest/1209/problem/F](https://codeforces.com/contest/1209/problem/F)

**题解**

我的做法和题解的不太一样。

首先观察问题，假设1到x的最短路径为1,..,y, x，那么x的数值则是在y的数值的尾部添加若干数字得到，即x的数值一定大于y的数值。我们发现这个性质有点类似于最短路问题，且在这种意义上，我们可以推出边权是非负的。这样我们就可以堂而皇之地使用Dijkstra算法解决它。

首先我们解决一个问题，如果进行比较操作，即如何判断离1所在连通块最近的顶点。

我们可以用一株前缀树维护所有顶点的最短距离，这样每个顶点所在的最短距离就是前缀树的某个顶点。这里我们需要使用动态开点技术，由于每条边最多建立$\log_2m$个前缀树顶点，因此前缀树的大小是$O(m\log_2m)$的。

之后如果比较两个顶点与1所在连通块的距离，我们知道距离已经被我们映射为了前缀树的顶点。因此就是比较两个顶点所代表的数值的大小。

由于边没有前置0，那么深度不同的顶点的大小，可以完全通过深度进行判断，深度较小的顶点代表的数值一定较小。

之后如何判断深度相同的顶点呢，我们必须找到两者的LCA。而要在一个动态加点的前缀树上找LCA，最简单的方式就是倍增技术，为每个顶点维护一个大小为20的数组bl，其中$bl[i]$表示距离当前顶点$2^i$的祖先顶点。这样判断操作就可以在$O(20)$时间内得到。

考虑总的时间复杂度，由于比较会发生$O((n+m)\log_2n)$次，因此总的时间复杂度为$O(20(n+m)\log_2n)$，是可以通过的。

# Codeforces 1312F

**题意**

[https://codeforces.com/contest/1312/problem/F](https://codeforces.com/contest/1312/problem/F)

**题解**

SG函数的循环节上限为$4^{15}$，但是实际上却往往非常小。暴力找出循环节，之后就可以$O(1)$查SG函数了。之后遇到循环节的问题，一定敢暴力，不要被上限所困，因为理论上的上限一般都很难出现。


# Codeforces 1110F

**题意**

[https://codeforces.com/contest/1110/problem/F](https://codeforces.com/contest/1110/problem/F)

**题解**

我竟然想要用ETT来解决这个问题，重点是我也不会ETT，菜得真实。

我们先求出每个顶点到顶点1的距离。之后以顶点1位根进行深度优先搜索。当我们沿着一条边从父结点移动到子结点的时候，容易发现，所有的顶点可以分成三类，第一类是不属于子结点的子树中ID小于子结点的顶点，第二类是属于子结点的子树中的顶点，第三类是不属于子结点的子树中ID大于子结点的顶点。这三类顶点的ID都是连续的区间，这意味着三次区间修改操作，就可以将距离修正。

维护一个线段树，进入子结点时修正距离，离开子结点的时候恢复距离。访问到某个顶点时顺带处理掉所有与它相关的请求即可。

NOTE：非常多的树上查询问题都可以通过将问题挂载到对应的顶点上，并且利用深度优先搜索进行解决。

# Codeforces1260F

**题意**

[https://codeforces.com/contest/1260/problem/F](https://codeforces.com/contest/1260/problem/F)

**题解**

毒瘤题。

仅考虑颜色c。我们记V(i)为一个指示器，如果$l_i\leq c\leq r_i$，那么$V(i)$为真，否则为假。记$g(i)=r_i-l_i+1$，记$p=\prod_{i=1}^n g(i)$。

于是单独考虑颜色c的贡献，为：

$$
\sum_{V(i)\land V(j)\land i<j}dist(i,j)\frac{p}{g(i)g(j)}=p\sum_{V(i)\land V(j)\land i<j}dist(i,j)\frac{1}{g(i)g(j)}
$$

这里我们可以稍微变更一下，记$dep(i)$表示顶点i在树中的深度，那么有

$$
dist(i,j)=dep(i)+dep(j)-2dep(lca(i,j))
$$

其中$lca(i,j)$为顶点i和顶点j的最近公共祖先。代入之前的公式得到：

$$
\sum_{V(i)\land V(j)\land i<j}dist(i,j)\frac{1}{g(i)g(j)}\\
=\sum_{V(i)\land V(j)\land i<j}(dep(i)+dep(j)-2dep(lca(i,j)))\frac{1}{g(i)g(j)}\\
=\sum_{V(i)\land V(j)\land i<j}dep(i)\frac{1}{g(i)g(j)}+\sum_{V(i)\land V(j)\land i<j}dep(j)\frac{1}{g(i)g(j)}
+\sum_{V(i)\land V(j)\land i<j}2dep(lca(i,j))\frac{1}{g(i)g(j)}\\
=\sum_{V(i)}dep(i)\frac{1}{g(i)}(\sum_{V(j)}\frac{1}{g(j)})-\sum_{V(i)}dep(i)\frac{1}{g(i)^2}+2\sum_{V(i)\land V(j)\land i<j}dep(lca(i,j))\frac{1}{g(i)g(j)}
$$

现在我们考虑从颜色c转移到c+1，这时候我们会删除一些顶点，同时加入一些顶点。我们希望能在删除加入顶点的同时维护整个公式。事实上，前两项是很容易维护的，这里不另外讨论。最后一项，我们可以这样统计：

$$
\sum_{V(i)\land V(j)\land i<j}dep(lca(i,j))\frac{1}{g(i)g(j)}\\
=\sum_{V(i)}\frac{1}{g(i)}\sum_{V(j)\land i<j}dep(lca(i,j))\frac{1}{g(j)}
$$


我们维护一棵树，每次加入一个顶点x时，结果需要增加从顶点x到根顶点的路径上所有顶点的值，同时我们将顶点x到根节点的路径上所有顶点的值加上$\frac{1}{g(x)}$。（这里我们用到了，考虑两个顶点a和b，二者的公共前缀长度为dep(lca(a,b))，因此我们可以路径加总来替代$dep$函数的使用）。这涉及到路径操作，轻重链剖分或者LCT都可以。

# Codeforces 1111E

**题意**

[https://codeforces.com/contest/1111/problem/E](https://codeforces.com/contest/1111/problem/E)

**题解**

挺不错的问题。首先可以发现这个问题是树上DP问题，但是DP非常难推，且推出来的效率也很低。

我们可以换个思路，一个顶点$u$其只有$x$个禁止加入的分组（与集合中祖先数目相同），如果我们按照顶点的深度从小到大处理，那么如果此时已经存在$k$个分组，那么$u$或者加入已经存在的$k-x$个分组，或者重新创立一个分组。

剩下的就是如何快速确认每个顶点到根有多少个祖先顶点被选中，很简单，动态树即可。将选中的顶点的值全部设置为1，其余的设置为0，那么顶点到根之间祖先数目等于顶点到根这条路径上的值之和减去1（顶点自身）。（同时动态树还支持换根操作）

这个问题实际上还可以引出更加有趣的一种组合数学问题，第二类斯特林数，对于$n$个不同的元素，我们希望将它们分成不空的$k$组，有多少种分法。

# Codeforces 1083C

**题意**

[https://codeforces.com/contest/1083/problem/C](https://codeforces.com/contest/1083/problem/C)

**题解**

我们可以将整棵树放到线段树上维护，线段树上`[l,r]`表示的是从`l`到`r`排列对应的所有顶点，是否处于一条路径上。于是我们要找的结果就是最大的`k`使得`[0,k-1]`对应的顶点都处于一条路径上。这里满足二分的性质，所以我们可以在线段树上二分即可。

下面还需要提到一个问题，如何合并两个区间A和B。如果一个区间的所有顶点处于同一条路径上，我们只需要路径的两个端点就可以得到路径的所有信息了，我们可以在区间中保存路径的两个端点。现在考虑当区间A与B都满足所有顶点处于一条路径上时，是否能将两条路径合并为一条。如果能合并，最后得到的路径的两个端点必定是这四个端点中距离最远的两个，我们可以暴力枚举，找到距离最远的两个端点即可，之后判断所有四个端点是否都落于得到的新的路径上。

这里还可以提一下，线段树是自然支持二分的，因此我们可以在从上向下遍历线段树的时候完成二分过程，因此，总的时间复杂度为$O(n+q\log_2n)$。

# CF1174D

**题意：**

[https://codeforces.com/contest/1174/problem/D](https://codeforces.com/contest/1174/problem/D)

**题解：**

我们可以记构造好的序列为a，而序列a的前缀为b，即b\[i\]=a\[1\]^...^a\[i\]。

任意一段子序列，都可以表示为两个前缀的亦或和，换言之，我们现在需要找到满足条件的一组前缀，使得两两亦或和不为0和x。不为0意味着每个前缀都不同。不为x，意味着对于任意一个数t，t与t^x只能选择一个。因此我们可以通过维护1~2^n个数的可用状况，构造最长的一个前缀，之后将前缀转换为数组。

# Codeforces 1033F

**题意**

[https://codeforces.com/contest/1033/problem/F](https://codeforces.com/contest/1033/problem/F)

**题解**

首先$n$这个东西是障眼法，因为取值只可能有$2^w$种，我们可以一开始就记录下每个数出现的次数。下面考虑单独处理每个请求，对于一个请求，考虑它的第$i$位的运算，我们可以发现要保证这一位为0，那么最多有3种可能性（总共4种可能性，但是由于至少有一种可能性的结果为1，因此最多还剩3种可能性）。于是我们可以递归暴力枚举，这样的时间复杂度为$O(n+m3^w)$，稍微有点大。

但是注意到所有位运算符都满足交换性，因此我们可以把01和10两种情况压缩成一种，我们可以将00记作0，01和10记作1，11记作2（就是1出现的数目而已）。这样我们发现每个运算符最多只能在两种可能性下给出结果0，因此我们可以暴力枚举这两种可能性，总的时间复杂度就降为了$O(n+m2^w)$。

具体实现，我们可以维护一个多维数组，记录每一位和满足某个条件的二元组数目。这里由于会出现动态维护的多维数组，比较麻烦，我们可以直接将其作为三进制进行压缩即可。

总的时间复杂度为$O(n+m2^w+w(2^w)^2)$。

这里还有一个发现，就是如果我们将每个数先转成二进制形式，之后将二进制直接当成三进制处理的话，就可以直接用加法来预处理那个多维数组了。即多维数组的第$k$项的值为$\sum_{i+j=k}C_iC_j$，其中$C_i$表示三进制为$i$的数出现次数，$C_j$同理。这是一个卷积，我们可以直接用FFT计算，这样预处理的时间复杂度就会从$w(2^w)^2$降低到$w3^w$。

# Codeforces1208F

**题意**

[https://codeforces.com/contest/1208/problem/F](https://codeforces.com/contest/1208/problem/F)

**题解**

好题。直接给出解法：

我们先处理
$$
a_j \& a_k
$$
，我们定义函数$f(x)$，其值表示x的所有二进制超集中的下标，如果不存在则返回-1。我们可以为每个可能值（M个）维护一个集合，之后按x从大到小计算$f(x)$。注意到我们实际上只需要考虑这些集合中最大的两个下标，因此可以用一个大小为2的最大堆替代上面提到的集合。

之后问题就变成了问集合中任取两个下标不同的元素，求最大或。

我们可以遍历所有可能的第一个元素x。之后我们求不在x中出现的最大位对应的值t，判断t是否出现在x右边，如果出现，则表示可以取到，否则取不到。之后继续处理剩余的位。

时间复杂度为$O((N+M)\log_2M)$，其中M为取值范围，N为数组大小。

# Codeforces1136E

**题意**

[https://codeforces.com/problemset/problem/1136/E](https://codeforces.com/problemset/problem/1136/E)

**题解**

可以发现，问题可以表述为：

$$
\left\{
\begin{array}{lcr}
a_2-k_1&\geq& a_1\\
a_3-k_2-k_1&\geq& a_2-k_1\\
\ldots\\
a_n-k_{n-1}-\ldots-k_1&\geq& a_{n-1}-k_{n-2}-\ldots-k_1
\end{array}
\right.
$$

即我们可以发现我们将每个数字$a_i$分成了两部分$a_i-k_{i-1}-\ldots-k_1$和$k_{i-1}+\ldots+k_1$的和。后面部分是不会改变的，而前面的部分是非严格递增的，因此可以用线段树维护。


# Codeforces 1146G

**问题:**

见链接[https://codeforces.com/contest/1146/problem/G](https://codeforces.com/contest/1146/problem/G)

**题解:**

令$dp(i,j,k)$表示仅考虑地点i..j，建立最高的屋子的高度不超过k时能获得的最大收益，其中惩罚条款仅考虑那些完全限于i..j内部的条款。要计算$dp(i,j,k)$，我们可以记m为房屋i..j中最高的那座，m可以通过枚举得到。之后如果$m<k$，那么很显然$dp(i,j,k)=dp(i,j,k-1)$。现在仅考虑$m=k$的情况。可以推出公式为：


$$
dp(i,j,k)=\min_m(dp(i,j,k-1),dp(i,m-1,k)+dp(m+1,j,k)+k^2-penalty)
$$

# Codeforces 1146H

**问题:**

见链接[https://codeforces.com/contest/1146/problem/H](https://codeforces.com/contest/1146/problem/H)

**题解:**

记$dp(i,j,k)$表示以顶点i开始结束，长度为k的凸包的数量。为了组成凸包，我们可以将一开始的所有线段按照斜率进行排序。之后我们可以遍历每条线段，并用线段对动态规划公式做补充，这样可以保证得到的折线的联结一定是凸包。

最后统计$\sum_idp(i,i,5)$即可。



# CF1168C

**问题:**

见链接[https://codeforces.com/contest/1168/problem/C](https://codeforces.com/contest/1168/problem/C)

**题解:**

定义dp(i,j)表示所有带j比特中能被i访问到的，且下标最小的数的下标。则可以认为数a[dp(i,j)]或者可以被a[i]直接访问或者被a[i]间接访问，可以被a[i]直接访问的数最多有20个。可以通过动态规划公式得到结果。



# CF1168D

**问题:**

见链接[https://codeforces.com/contest/1168/problem/C](https://codeforces.com/contest/1168/problem/C)

**题解:**

题解说可以通过树链剖分解决，不知道怎么做。按照题解里的来吧。

首先要满足条件，叶结点的深度一定相同。我们记$h_i$表示深度为i的结点的数目，那么不等式一定成立：$h_1\leq h_2 \leq \ldots$，如果我们发现两个相连的深度有等量结点，那么我们可以将两层压缩为一层。由于压缩后的数满足$h_1< h_2 < \ldots$，因此压缩后的树最高为$O(\sqrt(n))$


# Codeforces1117F

**题意**

[https://codeforces.com/problemset/problem/1117/F](https://codeforces.com/problemset/problem/1117/F)

**题解**

很容易想到这是一个位压DP，但是如何判断一个删除策略是否合法呢，这是需要解决的问题。

我们为每个序列中的字符，维护两个列表prev、next。`prev[i]`存储第i个字符之前最近的k种字符的出现顺序，而`next[i]`存储第i个字符之后最近的k种字符的出现顺序。

接着我们考虑所有的字符。假设处理到的字符为u，且u之前存在某个字符v与其不能相邻，那么记s为u与v之间的字符对应的二进制位的或。那么我们需要对s以及所有父集打一个+1标记，同时由于如果u、v中有一个已经被删除了，那么就不会冲突，我们对`s|(1<<u)`和`s|(1<<v)`分别打一个-1标记。而由于`s|(1<<u)|(1<<v)`以及所有父集被多打了一次-1标记，因此我们在上面打一个`+1`标记。如果一个删除状态被打的+1标记多于-1标记，那么这个状态是非法的。

最后问题来了，如何上推标记，很简单用FWT即可。

总的时间复杂度为$O(pn+p2^p)$。

# Codeforces1107F

**题意**

[https://codeforces.com/contest/1107/problem/F](https://codeforces.com/contest/1107/problem/F)

**题解**

首先容易想到最小费用最大流的做法，但是它是$O(n^3)$的。

我们可以将接受的offer分成两类，第一类是我们在买车之前不能还完的，第二类是我们在买车之前能还完的。

仅考虑第一类，我们会发现按照$b_i$从小到大排序后，我们依次进行贷款所需费用最小，而选择的顺序对于第二类是不重要的。因此我们可以进行DP，记$dp(i,j)$表示仅考虑$b_i$从大到小排序前面$i$个offer，总共有$j$个是属于第一类的，问最多能赚多少钱。之后动态规划即可，总的时间复杂度为$O(n^2)$。

# Codeforces1093F

**题意**

[https://codeforces.com/contest/1093/problem/F](https://codeforces.com/contest/1093/problem/F)

**题解**

初看比较奇怪的问题。很显然得用DP。

记录`dp[i][j][k]`表示处理前$i$个字符后，最后一个字符为$j$，最后一个字符已经连续出现了$k$次了。

那么很容易推出转移公式，但是状态有$n^2k$种，很显然过不了。但是仔细观察递推项，会发现`dp[i][j][k]`和`dp[i-1][j][k-1]`完全相同。因此如果我们把状态数组搞成可旋转的，就可以以$O(k)$的时间复杂度从`dp[i-1]`直接得出`dp[i]`。这样总的时间复杂度和空间复杂度都为$O(nk)$。

这种做法比较取巧。个人认为官方的做法比较好，官方的做法定义`dp[i][j]`表示处理完了前$i$个字符后，最后一个字符为`j`的所有有效方案数。

于是可以直接得出$dp\[i\]\[j\]=\sum_{t=1}^k dp\[i-1\]\[t\]$。但是这个公式有一个问题，没有考虑子段不能连续出现$len$个相同字符。这里唯一的一种情况是最后一个字符与前面$len-1$个字符完全相同。我们要减去这些非法状态，非法状态的数目为$\sum_{t=1}^k\[t\neq j\]dp\[i-len\]\[t\]$。


# Codeforces 1056G

**题目**

[https://codeforces.com/contest/1056/problem/G](https://codeforces.com/contest/1056/problem/G)

**题解**

由于$n$比较小，所有我们可以先保证$t$能整除$n$（重复操作直到）。

之后我们可以记录$dp(i,j)$表示从第$i$个位置开始移动$j,j-1,\ldots,1$后所抵达的位置。不难发现，当$i\leq m$时有$dp(i,j)=dp(i+j,j-1)$，在其他位置则有$dp(i,j)=dp(i-j,j-1)$。这意味着$dp(i,?)$是由$dp(i-1,?)$的碎片拼接而成的（最多有四个碎片）。我们可以利用持久化平衡树来优化加速，时间复杂度为$O(n\log_2n)$。

要写一个持久化平衡树太麻烦了，直接上`rope`好了。

# Codeforces 1060F Shrinking Tree

**题意**

[https://codeforces.com/contest/1060/problem/F](https://codeforces.com/contest/1060/problem/F)

**题解**

很诡异的题目，比赛的时候但凡有点思路就又被自己否决了。

树上DP大家应该都知道这么做，可是怎么DP这才是最大的难题。看了其他人的题解后，也没法完全搞懂，这里记录一下。

由于$n$很小，我们可以对每个顶点作为根独立统计一次。下面我们仅考虑1号顶点作为根的情况。

首先统计概率比较麻烦，我们可以统计有多少方案能保证1号顶点最终存活，之后除去$2^{n-1}(n-1)!$得到真实的概率。

为什么这道题难呢，因为每条边对方案数的贡献可能是2，也可能是1（取决于是否与1号顶点相连），且树的形态也会改变。

首先我们避免树的形态改变，我们可以这样理解删边操作，每次删边后，会将边的两端顶点的连通块合并，而实际标号是等概率取两边连通块的标号之1。

我们定义两个辅助函数：

- $f(u,i)$表示顶点$u$为根的子树对应的所有方案中（共$2^{size(u)-1}(size(u)-1)!$种方案），除了前$i$条删除的边外，后面的所有删除的边都不会修改$u$的标号的方案的数目。
- 记$p$为$u$的父亲，定义$g(u,i)$表示以$u$为根的子树，加上$(u,p)$这条边的所有方案中（共$2^{size(u)}size(u)!$种方案），除了前$i$条删除的边外，后面的所有删除的边都不会修改$p$的标号的方案的数目。

如果我们为每个顶点算出了$f$和$g$函数值，那么$f(1,0)$就是我们要求的结果。

要计算$f(u,i)$，我们可以假设$u$下有$a,b,c$三个顶点，那么

$$
f(u,i)=\sum_{c_a+c_b+c_c=i}g(a,c_a)g(b,c_b)g(c,c_c)\frac{i!}{c_a!c_b!c_c!}\frac{(size(u)-1-i)!}{(size(a)-c_a)!(size(b)-c_b)!(size(c)-c_c)!}
$$

这个公式可以通过类似多项式卷积的方式得到，由于是树上DP，且任意两个顶点最多对时间复杂度贡献1，因此计算函数$f$总的时间复杂度为$O(n^2)$。

下面考虑$g(u,i)$怎么计算。这里我们额外加入了边$(u,p)$。可以分两种情况讨论：
- 如果$(u,p)$是前$i$条删除的边中的一个，即早于$p$的标号被修改为1之前，这时候删除这条边，无论选择使用哪个连通块的标号都是没问题的，而除了$(u,p)$外还有$i-1$条$u$子树内的边被删除。且之后删除的所有$u$子树的边都不应该修改$u$的标号（因为这时候$u$和$p$在一个连通块了，如果修改$u$就会同时修改$p$），因此$g(u,i)$得到了$2if(u,i-1)$的贡献（乘2是因为可以任意选择连通块的标号，乘上i是因为$(u,p)$可能是作为第$1,2,\ldots,i$条边被删除的。）。
- 否则$(u,p)$不属于前$i$条被删除的边，这时候它可能是作为第$i+1,i+2,\ldots, size(u)$个边被删除的。如果它是作为第$j$条边被删除的，那么它对$g(u,i)$的贡献应该为$f(u,j-1)$，即在$u$的子树下删除了$j-1$条边后，剩余的删除操作都不应该更高$u$的标号。

结合上面讨论的可以得出：

$$
g(u,i)=2if(u,i-1)+\sum_{j=i}^{size(u)}f(u,j-1)
$$

这里我可以通过预处理后缀的技术，每个顶点以$O(n)$时间复杂度算出函数$g$的值。

对于根选定的情况下，总的时间复杂度为$O(n^2)$，每个顶点都需要作为根算一次，因此总的时间复杂度为$O(n^3)$。



# Codeforces1110E

**题意**

[https://codeforces.com/contest/1110/problem/E](https://codeforces.com/contest/1110/problem/E)

**题解**

很简单的题，只需要注意到对于连续的三个数字$c_{i-1},c_i,c_{i+1}$。对$c_i$进行操作后得到$c_i'=c_{i-1}+c_{i+1}-c_i$。

容易注意到$c'_i-c_{i-1}=c_{i+1}-c_i$，而$c_{i+1}-c'_i=c_i-c_{i-1}$。

我们可以记录$d_i=c_i-c_{i-1}$，那么操作实际上，会互换$d_i$和$d_{i+1}$，其它的不变。因此这个问题实际上就是问，允许任意次交换相邻d序列元素，能否使得$c$的d序列最终转换为t的d序列。xjb写吧。

# Codeforces1183F

**题意**

[https://codeforces.com/problemset/problem/1183/F](https://codeforces.com/problemset/problem/1183/F)

**题解**

首先由于不能选择相同的数，因此，我们可以在重复的数中仅保留唯一的。

现在来考虑怎么解决这个问题。

首先我们可以暴力枚举每个数$i$，以及以$i$作为选取最大值的所有方案的最大和。

在已知$i$是方案中最大的数的前提下，我们可以继续枚举第二大的数。我们找到比$i$小且不是$i$的因子的最大的数$j$。

接下来我们证明以$i$作为最大值的所有方案中和最大的方案，一定同时包含$j$。为啥呢，因为如果不含$j$，那么就必定包含另外两个数$a$，$b$，且$a,b<j$。由于$a,b$不能与$j$共存，因此$a$,$b$都一定是$j$的因子，即$a+b\leq j(\frac{1}{2}+\frac{1}{3})<j$。而这个方案还不如直接选择$i$,$j$来的好，因此假设不成立。

那么现在我们直到$i$,$j$必选了，最后一个数选啥呢，当然选能选的里面的最大的就可以了。

这个问题，每个数最多有$\sqrt{n}$个因子，因此时间复杂度为$O(n\sqrt{n})$。

# Codeforces1144G

**题意**

[https://codeforces.com/problemset/problem/1144/G](https://codeforces.com/problemset/problem/1144/G)

**题解**

我一开始写的是DP的做法，用线段树优化。

后来发现有一位大佬提了个贪心的做法，果然好用。算法非常简单，维护两个列表，一个递增，一个递减。之后从前往后处理$a_i$，如果$a_i$不能放入任意一个列表中，就无解。否则若仅能放入一个列表中，就放到允许的列表中即可。否则，我们根据$a_{i+1}$来做决定，若$a_i<a_{i+1}$，那么就将$a_i$放入递增列表，否则放入递减。

可以证明如果有解，上面算法一定能找到一组解。事实上，仅考虑最后一种情况，若最优结果中，$a_{i+1}$放入递增列表，那么直接我们发现对$a_i$的处理是不会影响最终解的。当然如果我们把$a_{i+1}$放入递减列表，那么我们自然只能间$a_i$放入递增列表。因此可以证明最后一种操作是最优的。

# Codeforces1137D

**题意**

[https://codeforces.com/problemset/problem/1137/D](https://codeforces.com/problemset/problem/1137/D)

**题解**

神奇的解法，以前确实做过类似的龟兔赛跑来判环的方法，但是确实从来不知道用三个棋子，3(t+c)步就可以得出t和c的所有信息。

首先，我们可以用棋子0和棋子1做龟兔赛跑，棋子0每次走两步，棋子1每次走一步。直到二者在环上距离入口x处相遇。这时候0走的距离为$t+x+kc$，1走的距离为$t+x$（1肯定没有走完整个循环）。而由于0走的距离是1的两倍，因此可以推出：$t+x=0\mod c$。这意味着当我们将所有棋子每次都向前移动一步，那么至少需要t步才能保证所有棋子都走到循环的入口，同时t步也正好能保证所有棋子来到循环的入口。

# CF1097D

**题意**

[https://codeforces.com/contest/1098/problem/D](https://codeforces.com/contest/1098/problem/D)

**题解**

这是一个大鱼吃小鱼的问题。我们将所有鱼按重量从轻到重进行排序，重量记作$a_1,a_2,\ldots,a_n$。现在如果有一条鱼$a_t$，满足$2\sum_{i=1}^{t-1}a_i<a_t$，那么我们称$a_t$为胖子。下面我们需要证明最重要的一个定理：

最大危险数等于$n-k$，其中$k$为序列中的胖子数。我们利用归纳法进行证明。

当序列中只有第一个数是胖子时，总共发生$n-1$次战斗，因此我们只需要证明存在一种方案，使得$n-1$次战斗都危险即可。

考虑这样的算法，每次都选择最小的两条鱼战斗。我们可以用归纳法证明这一步，只有两条鱼时命题显然成立。假设现在有$k>2$条鱼。我们将最小的两条鱼合并，同时将合并后的鱼插入到序列中，假设新的序列为$a_1',a_2',\ldots,a_i',\ldots,a_{k-1}$。其中$a_i'$为合并后的鱼。我们需要证明此时只有$a_1'$是胖子。由于$a_2'\leq a_3'\leq \ldots \leq a_i'\leq 2a_1'$，因此$a_2',a_3',\ldots,a_i'$中没有胖子存在。而对于任意数$a_j'$，其中$j>i$，由于所有小于它们的和不变，因此也不是胖子。现在我们证明了当只有第一只鱼是胖子，最大危险数等于$n-1$。

现在考虑胖子数$t$多于1的情况，这时候我们将重量第二小的胖子之前的鱼全部安排战斗，将战斗后活下来的鱼与这个胖子战斗，得到的新序列胖子数会减少1，一场战斗是不危险的。利用归纳法可以得出存在一种战斗方案，危险数等于$n-t$。

但是我们还没有证明$n-t$是一个上限。可以发现对于某个胖子$a_i$，要让$a_1,a_2,\ldots, a_{i-1}$中至少一个鱼与$a_i,a_{i+1},\ldots,a_n$中某条鱼合并，至少需要加入一场不危险的战斗。因此我们可以断定$n-t$是一个上界。

接下来我们要处理的问题就是：

- 删除一个数
- 插入一个数
- 计算有多少个数，其前缀和的两倍小于自己

这个问题貌似还是不能解决。但是我们可以将区间划分为$\[2^0,2^1),\[2^1,2^2),\ldots,\[2^{29},2^{30})$，能够发现每个区间中最多有一个胖子（且一定是区间中最小的数），因此可以维护$30$个平衡树统计一下即可。

# Codeforces 1268B

**题意**

[https://codeforces.com/contest/1268/problem/B](https://codeforces.com/contest/1268/problem/B)

**题解**

有一个高度非严格单调减的直方图，希望放置尽可能多的1x2或2x1的多米诺骨牌上去。

首先我们将直方图看成一个棋盘，并对其进行染色，将所有网格染成黑色或白色，且黑色和白色不相邻。

之后我们记黑色的数目为$B$，白色的数目为$W$。

下面我们用归纳法证明结果为：$\min(B,W)$。

在网格总数为0、1的时候结果当然是0，满足命题。之后我们记棋盘第$i$行的长度为$b_i$，第$j$列的高度为$a_j$。如果存在某个下标$j$满足$a_j=a_{j+1}>a_{j+2}$。我们将第$j$列和第$j+1$列的最顶部的两个网格放置一个多米诺骨牌。这样利用归纳法可以推出结果为$\min(B-1,W-1)+1=\min(B,W)$。如果不存在这样的列，就考虑行。下面认为没有两列或两行相同，那么此时一定满足$a_i=n-i+1$。这时候一定有$B-W=\lceil\frac{n}{2}\rceil\geq 1$。我们可以直接删除第一列最顶部的黑色网格，此时依旧满足$\min(B,W)=\min(B-1,W)=W$。因此命题成立。

# CF1251E2

**题意**

[http://codeforces.com/contest/1251/problem/E2](http://codeforces.com/contest/1251/problem/E2)

**题解**

首先我们可以将这个问题转换为一般的前缀匹配问题形态2。第$i$个人在有$m_i$个人支持后费用位0，否则费用为$p_i$。转换为我们的问题，就是第$i$个人希望做前$n-m_i$把椅子，否则不满意度为$p_i$。这样就可以直接解决了。

# CF1175D

**题意**
[https://codeforces.com/contest/1175/problem/D](https://codeforces.com/contest/1175/problem/D)

**题解**

记S(i)=a(i)+a(i+1)+...+a(n)。分别记最优解的划分下，第i个分块的第一个元素下标为f(i)。那么问题下面式子在最优解下一定取最大值。


$$
1\cdot (S(f(1))-S(f(2)))+2\cdot (S(f(2)) - S(f(3)))\\+\ldots + (n-1)(S(f(n-1))-S(f(n)))+nS(f(n))\\
=\sum_{i=1}^nS(f(i))
$$


由于f(1)一定是取到1，我们可以将S(2),S(3),...,S(n)排序后取前面最大的k-1个的和加上S(1)就是结果。

# CF1175F

**题意**
[https://codeforces.com/contest/1175/problem/F](https://codeforces.com/contest/1175/problem/F)

**题解**

我们可以逐个统计每个有效子排列。寻找所有1出现的位置，很显然一个有效排列必定包含且只保护其中之一的1。

我们维护一个函数R，R(i)表示形如a(i),a(i+1),...的无重复元素的最长序列的长度。

之后我们遍历每个1出现的位置i。之后包含i的序列的右边界只可能为j=i,i+1,..., i+R(i)-1。之后假设序列中最大的元素落在i的右边，因此我们只需要知道m=max(a(i),a(i+1),...,a(j))，而序列有效的必要条件是长度等于m，因此我们可以推出左边界k=j-m+1。之后只需要快速判断子序列a(k),...,a(j)是否是一个有效序列就可以了。判断的方法很简单，首先要求R(k)>=max，其次min(a(k),...,a(j))=1且max(a(k),...,a(j))=m。

对于最大元落在左边的情况，只要翻转序列后重新用上面过程处理一次就可以了。

利用线段树就可以在O(nlogn)的时间复杂度内解决。


# Codeforces1209B

**题意**

[https://codeforces.com/contest/1209/problem/B](https://codeforces.com/contest/1209/problem/B)

**题解**

我做的顺序是D、A、C。。。B。这道题还是有点东西的。

一开始看，以为是中国余数定理（怎么可能，C还是一个贪心呢，B怎么可能）。后来搞了搞贪心，没搞出来。最后实际一看，a、b范围很小，只有5。

实际上问题非常简单，由于b范围很小，那么我们可以保证灯下一次亮的时间不会超过10。而a范围很小，我们可以推出灯亮的间隔不会超过10。因此10秒之后，L=lcm(2,4,6,8,10)是所有灯状态的一个周期。因此我们只要暴力枚举到130左右，就能遍历所有可能了。

当然保险起见，枚举个10000也未尝不可。


# Codeforces1264E

**题意**

[https://codeforces.com/contest/1264/problem/E](https://codeforces.com/contest/1264/problem/E)

**题解**

题目同[BZOJ2597](https://www.lydsy.com/JudgeOnline/problem.php?id=2597)。

首先建图，n个顶点，如果i胜j，那么加入一条有向边(i,j)。可以发现对于任意一个三个顶点，如果它们不组成一个三元环，那么它们中会恰好有一个顶点的入度为2（仅考虑包含这三个顶点的导出子图）。现在考虑任意一个顶点x，如果它的入度为k，那么在所有入边对应的另外一个顶点组成的集合S中，任取两个顶点y、z，那么x、y、z无法组成一个三元环。因此顶点x对最终结果有$-{k \choose 2}$的贡献。

要让图中的三元环最多，那么就需要让负数贡献尽可能小。我们可以用最小费用最大流来解决。

建立n个顶点，每个顶点到终点有m-1条边，第i条边的费用为i-1。为了保证任意两个顶点u、v的比赛结果只有一方胜利，那么我们为每场比赛建立一个顶点u-v。u-v到u和到v各连一条边，而源点向每一场比赛连一条边（容量为1）。

由于一些比赛的结果已知，比如已知u胜v，那么就将u-v比赛到u的边删除即可。

最后跑一波最大流，结果矩阵可以通过取比赛的流出方向得知。

总的图大小为$O(n^2)$个顶点和边。时间复杂度为$O(n^4)$，能过。

# Codeforces 786E

**题意**

[https://codeforces.com/contest/786/problem/E](https://codeforces.com/contest/786/problem/E)

**题解**

容易发现，问题要求我们求最大权闭合子图，我们需要从市民向守护者建立依赖关系。因此闭合子图中顶点的数目为$O(n+m)$，而边的数目为$O(nm)$。因此我们需要做的是把边的数目降下来。

需要观察到，对于每个市民，其依赖的守护者正好是树上的一条路径。而我们知道有很多技术可以将树上的路径切分为$O(\log_2n)$段的，比如说树上倍增，或者轻重链剖分。我们这里可以选择树上倍增技术，即我们为每个守护者建立$\log_2 n$个顶点，第$i$个顶点代表的是从这个守护者的深度较大的端点向根移动$2^i$步代表的路径上所有的边。

这样闭合子图中的顶点的数目就增大到了$O(n\log_2n + m)$。

而对于市民以来的路径，我们可以算出路径端点的lca，之后分别依赖从端点到lca的路径即可。这样依赖关系也被降低到了$O((n+m)\log_2n)$。

于是我们就可以采用最大流算法来解决这个问题了，时间复杂度为$O(能过)$。

# Codeforces1209E2

**题意**

[https://codeforces.com/contest/1209/problem/E2](https://codeforces.com/contest/1209/problem/E2)

**题解**

一开始以为是贪心或匹配问题，算算时间复杂度怎么都超。但是最后看题解发现是DP。

很显然m列我们最多只需要n列，这n列的最大值一定是最大的。因此提前排序后筛选，就只剩下n行n列。

我们用二进制表示某一行是否已经被选定，1为被选定，0为未选择。定义函数$g(i,s)$，表示第i列的选定状态为s，问最大总和是多少。首先每一列最多有n种形态（旋转的周期为n），之后对每种形态枚举即可。这里的时间复杂度为$O(n^32^n)$，可以稍加优化（在计算子集的同时计算总和），可以优化到$O(n^22^n)$。

之后记函数$f(i,s)$，表示只考虑前i列，选定状态为s的最大和。只需要简单枚举第i列的选定状态，就可以得出前i-1列的选定状态，这是一个子集问题，时间复杂度为$O(n3^n)$。

最后总的时间复杂度为$O(40(nm+m\log_2m+n3^n+n^22^n))$，计算量大概几亿，是可以过的。


# CF1172C

**题意**

[https://codeforces.com/contest/1172/problem/C2](https://codeforces.com/contest/1172/problem/C2)

**题解**

记f(w,i,j,k)表示初始权值为w的喜欢的图片经过k次操作后的期望权值，其中喜欢的图片权值之和为i，讨厌的图片权值之和为j。

可以推出公式：


$$
f(w,i,j,k)=\frac{w}{i+j}f(w+1,i+1,j,k-1)\\
+\frac{i-w}{i+j}f(w,i+1,j,k-1)\\
+\frac{j}{i+j}f(w,i,j-1,k-1)
$$


很显然状态过多了。但是可以证明$f(w,i,j,k)=wf(1,i,j,k)$，因此我们只需要计算形如f(1,i,j,k)的函数值。并且当i和k确认时，j也随之确认。因此我们可以将公式变为$f'(i,k)$。总共有$O(m^2)$种状态。

# Codeforces 1097D

**题意**

[https://codeforces.com/contest/1097/problem/D](https://codeforces.com/contest/1097/problem/D)

**题解**

对于形如$n=p^m$的整数，其中$p$是素数，这个问题是非常简单的，简单DP算算前缀和即可。

那么$n$是不同素数的乘积的情况下该怎么处理，这时候有$n=p_1^{c_1}p_2^{c_2}\ldots p_t^{c_t}$。

这时候需要一个重要的发现，不同的素数衰退是独立的。记录$f(a,b,k)$表示形如$p^a$的数经过k步骤变换为$p^b$的概率。那么$n$经过k步转化为$n=p_1^{c'_1}p_2^{c'_2}\ldots p_t^{c'_t}$的概率可以表达为$f(c_1,c'_1,k)f(c_2,c'_2,k)\ldots f(c_t,c'_t,k)$。

首先$10^{15}$以下的数因子最多两万多个，所以可以暴力枚举所有的解决方案。

# Codeforces1264C

**题意**

[http://codeforces.com/contest/1264/problem/C](http://codeforces.com/contest/1264/problem/C)

**题解**

考虑一段区间$\[l,r\]$，记$f(l,r)$表示从$l$出发，到抵达$r+1$的期望步数，这里假设在$x\leq l$处有最近的复活点。

由于期望可以独立统计。假设复活点为$x_1,x_2,\ldots, x_k$，因此我们需要完成的任务是快速计算$f(x_1,x_2-1)+f(x_2,x_3-1)+\ldots +f(x_k,n)$。每次修改操作最多影响公式中的两项。

考虑$x=x_i$，以及$x_i < l\leq r <x_{i+1}$。我们发现转移关系可以表示为$f(l,r)=a_{l,r}+b_{l,r}f(x,r)$。同时我们可以得到：

$$
f(x,r)=(a_{x,l-1}+f(l,r))(1-b_{x,l-1})+(a_{x,l-1}+f(x,r))b_{x,l-1}\\
=(a_{x,l-1}+a_{l,r}(1-b_{x,l-1}))+(b_{x,l-1}+(1-b_{x,l-1})b_{l,r})f(x,r)
$$

因此可以推出：

$$
a_{x,r}=a_{x,l-1}+(1-b_{x,l-1})a_{l,r}\\
b_{x,r}=b_{x,l-1}+(1-b_{x,l-1})b_{l,r}
$$

对于任意$x<l\leq r$成立。

因此我们可以用类似倍增的方式快速求解。这里不能使用ST来进行加速，因为会带来重复合并的问题，但是可以使用猫树这种数据结构。