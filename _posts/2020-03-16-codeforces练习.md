---
categories: algorithm
layout: post
---

- Table
{:toc}

# Codeforces 1033E

**题意**

[https://codeforces.com/contest/1033/problem/E](https://codeforces.com/contest/1033/problem/E)

**题解**

我们可以尝试找出一株生成树，我们从前到后处理所有顶点，并且维护处理过的顶点形成边数最多的生成树。这样当新加入一个顶点的时候，我们可以二分查找，找到所有与新顶点存在边的连通块，之后对连通块进行二分查找，找到连通块中与新顶点之间恰好存在边的顶点，加入边即可。由于每次合并两个连通块都对应的会有$O(\log_2n)$次查询，因此最多的查询数目为$O(n\log_2n)$，这里常数不超过2，因此在$n=600$的时候总的请求数也不会超过$12000$。

最后我们找到了生成树就很容易判断是否有奇长环了，将树上顶点进行二分染色，之后观察同色顶点之间是否有边存在，如果有就存在了奇环。我们可以将该色的顶点压成一个序列，然后比遍历序列，直到找到某个特殊的点，这个点后面的所有顶点之间没有边，我们记这个顶为first，之后找到first后第一个顶点second，使得second与first之间有边，这里总共最多为$2n$次查询。要找到奇环，可以以first为根，搜索到second的唯一路径即可。

题目的核心是想到这题目所要求的输出，不需要你得到所有边，只需要一株生成树即可。

# Codeforces 1028G

**题意**

[https://codeforces.com/contest/1028/problem/G](https://codeforces.com/contest/1028/problem/G)

**题解**

定义$dp(l,q)$表示最大的$r-l+1$，满足在知道$x$落在$\[l,r\]$的前提下能够在$q$次请求内找到$x$。

那么可以很容易推出转移公式，同时利用$dp$也可以快速找到那些分隔点。

这个问题中由于每个请求中的值不能超过$x$，因此不可以直接均匀切分，这也是为什么要借助动态规划的原因。以后遇到这种复杂的二分查值交互题，一定不要嫌麻烦，写个动态规划。

# Codeforces 1307E

**题目**

[https://codeforces.com/contest/1307/problem/E](https://codeforces.com/contest/1307/problem/E)

**题解**

这是一道挺有趣的问题的，优化的空间很大。

首先吃同一类草的牛，一边最多只会有一只。

很容易想到一个$DP$的方式，时间复杂度为$O(n^3)$。但是这个方式铁定不行。

我们可以换一个思路，枚举从左走出走到最靠右的牛，以及从右走出走到最靠左的牛。之后我们发现其它牛就直接被分成了三类，第一类只能出现在左边，第二类只能出现在右边，第三类可以出现在两边。我们可以对吃一类草的牛独立统计贡献，总的方案数可以将所有贡献乘起来得到。

你可能会问，那时间复杂度不还是$O(n^3)$吗？是的，但是这样弄就有了优化的空间，而之前的$DP$绝对是死路一条。我们会发现为啥我们需要枚举左右两边最靠边的牛的位置呢，是为了防止重复统计，但是实际上如果从左边出来最靠右的牛确定了，右边的牛即使不确定也不会导致重复统计。因此我们这样就直接砍掉了一个$n$，时间复杂度降低为$O(n^2)$。

但是还能优化，如果我们从左往右枚举从左出发最靠右的牛时，每次下标变动的时，最多只有两只牛允许出现位置会变动。因此我们可以通过扫描并不断修改，就能保证时间复杂度为$O(n\log_2n)$，这里的$\log_2n$是因为需要用到求逆运算。

# Codeforces 1311E

**题意**

[https://codeforces.com/contest/1311/problem/E](https://codeforces.com/contest/1311/problem/E)

**题解**

很显然当树是一条链表的时候，深度之和会达到最大，而树除了深度最大的一层外，其它第$i$层正好$2^i$个顶点的时候深度最小。

总深度最小记作$m$，总深度最大记作$M$。下面我们给出一个构造性算法，每次操作都能将总深度减少1。我们从链表开始转换。现在我们开始尝试将总深度减少1：如果一个叶子的深度为$k$，且在深度$k-2$处存在一个顶点，它的孩子数少于2，那么我们称这个叶子是有效的。我们选择所有有效叶子中深度最小的，记它的深度为$k$，将其移动到某个孩子数少于2的深度为$k-2$的顶点下面。这个算法可以持续直到树的深度和达到最小。

# Codeforces 1253F

**题意**

[https://codeforces.com/contest/1253/problem/F](https://codeforces.com/contest/1253/problem/F)

**题解**

一类最小瓶颈路问题，问题3。


# Codeforces 1301F

**题意**

[https://codeforces.com/contest/1301/problem/F](https://codeforces.com/contest/1301/problem/F)

**题解**

容易发现我们可以对每个颜色作为源头进行一次BFS，这样就能保证快速得到每个位置到另外一种颜色任意位置的最短距离，记$D(c,i,j)$，表示位置$(i,j)$到颜色为$c$的任意位置的最短距离。

现在我们考虑如何找到两点的最短距离。考虑到最短距离可能出现了同色块之间的转移，也可能没出现。

没出现的情况下，这时候两点的最短距离是二者之间的曼哈顿距离。

在出现的情况下，我们可以枚举第一次发生同色转移的颜色，记这个颜色为$c$，那么此时最短距离可以分解三部分，第一部分是从颜色$c$的任意块转移到$(r_1,c_1)$，第二部分是从颜色为$c$的任意块转移到$(r_2,c_2)$，第三部分就是我们枚举的$c$颜色的两个位置的转移，因此此时的最短距离为$D(c,r_1,c_1)+D(c,r_2,c_2)+1$。

总的时间复杂度为$O(knm+qk)$，需要注意不要用太多$stl$的东西，这道题目卡常严重。

# Codeforces 1305G Kuroni and Antihype

**题意**

[https://codeforces.com/contest/1305/problem/G](https://codeforces.com/contest/1305/problem/G)

**题解**

首先我们先认为每个人的权值都不同。

我们可以加入一个权值为0的人（记作第$n+1$个人），并且认为这个人一开始就加入了Antihype。同时我们可以假设所有的数都不能自主加入Antihype，必须通过他人邀请才能加入。可以发现这样不会改变结果。

首先我们想一个naive的方法，如果两个人$i,j$是朋友，那么我们可以加入两条单向边$(i,j),(j,i)$，前者的权值为$a_j$，后者的权值为$a_i$。现在我们希望选择其中一部分边，并拿到这些边的权值。选择的规则如下：

- 每个顶点最多有一条入边被激活。
- 沿着顶点的入边不断后退，最后一定会回到顶点$n+1$。

很显然这最终得到的是一个有向图生成树（树形图），同时我们要求权值最大，即要求求最大权树形图，这可以用最小树形图算法解决，时间复杂度是$O(E\log_2V)$。$V=n+1$，是已知，但是$E$可以有多大呢。

任意两个数且运算后位0，那么我们可以枚举$0$到$2^{18}-1$的每个数$x$，以及$x$的子集$a$，这样就可以找到另外一个数$b=x-a$。这样统计的好处是不会出现重复（我们可以恒要求$a>b$来避免重复）。

通过上面算法，我们可以找到所有的边，以及估计出了边的总数为$O(3^{18})$，数量级是3亿级别的。因此上面的算法自然无法通过。（但是至少我们得出了一个比$O(n^2)$或$O(4^{18})$更好的方法）。

我们可以考虑另外一种统计方案，记$out(v)$表示顶点$v$的出度。那么我们实际要统计的是：

$$
\sum_{v}out(v) a_v
$$

上面的公式不能帮助我们太多，但是如果我们用无向边来替代有向边，那么我们会发现每个顶点的出度都会增大1（因为原来的唯一入边也转换成了出边），现在我们记$deg(v)$表示顶点$v$的度数，我们要求的就是：

$$
\sum_{v}(deg(v)-1) a_v=\sum_{v}deg(v)a_v+\sum_va_v
$$

其中$\sum_va_v$是常数，我们可以忽略，现在我们希望$\sum_{v}deg(v)a_v$最大。这个玩意可以将其转换为最小生成树问题（可以参考最小生成树的一些题目-题目1）。

现在我们面对的问题是找到一颗最小生成树。我们可以考虑使用kruskal算法，kruskal要求对边按边权排序，我们可以很自然的从大到小枚举$x$即可。这样我们就给出了一个$O(3^{18}\alpha(n))$，其中$\alpha(n)$是反阿克曼函数，可以直接作为常数看待。

最后还剩下一个问题，就是存在重复的权值。我们可以这样考虑，如果在枚举到$(u,v)$的时候，$u$有$c(u)$个处于不同连通块的人，而$v$有$c(v)$个处于不同连通块的人，我们要让它们连通，只需要加$c(u)+c(v)-1$条边即可，之后他们就连通了，修改$c(u),c(v)$为1即可。

总的时间复杂度为$O(3^{18}\alpha(n))$。

# Codeforces1205D

**题意**

[https://codeforces.com/problemset/problem/1205/D](https://codeforces.com/problemset/problem/1205/D)

**题解**

如果我们为根结点赋予权重0，并且为其余结点均赋予不小于父结点权重的权重。那么我们可以通过差分得到连接父子结点的边的权重，并且权重非负。现在考虑要为一株树上的n个顶点赋予一组权重，我们可以遍历整棵树，按照遍历的顺序从小到大赋予权重，这样进行差分后得到的边的权重均非负，且从根结点到树中任意顶点v的路径总权等于v的顶点权重。

考虑星图，我们认为根结点下挂n-1个顶点。我们任意选择一个C，满足$n/3\leq C \leq 2n/3$。并为前C个子结点赋予权重$1,2,\ldots, C$，而后面的$n-C-1$个子结点赋予权重$(C+1),2(C+1),\ldots, (n-C-1)(C+1)$，这样利用前C个顶点和后n-C-1个顶点我们就可以组合得到$\[1,2n^2/9\]$之间的所有值了。

考虑一般的树，我们找到树的重心，可知重心下最大子树的大小不超过$n/2$。我们可以排序重心下的子顶点，并贪心找到一组子树，使得总大小C落在区间$\[n/3,2n/3\]$中。之和，我们为这组子树中顶点赋予权重1~C，而其余子树中顶点赋予权重$(C+1),2(C+1),\ldots, (n-C-1)(C+1)$。

# Codeforces1209F

**题意**

[https://codeforces.com/contest/1209/problem/F](https://codeforces.com/contest/1209/problem/F)

**题解**

我的做法和题解的不太一样。

首先观察问题，假设1到x的最短路径为1,..,y, x，那么x的数值则是在y的数值的尾部添加若干数字得到，即x的数值一定大于y的数值。我们发现这个性质有点类似于最短路问题，且在这种意义上，我们可以推出边权是非负的。这样我们就可以堂而皇之地使用Dijkstra算法解决它。

首先我们解决一个问题，如果进行比较操作，即如何判断离1所在连通块最近的顶点。

我们可以用一株前缀树维护所有顶点的最短距离，这样每个顶点所在的最短距离就是前缀树的某个顶点。这里我们需要使用动态开点技术，由于每条边最多建立$\log_2m$个前缀树顶点，因此前缀树的大小是$O(m\log_2m)$的。

之后如果比较两个顶点与1所在连通块的距离，我们知道距离已经被我们映射为了前缀树的顶点。因此就是比较两个顶点所代表的数值的大小。

由于边没有前置0，那么深度不同的顶点的大小，可以完全通过深度进行判断，深度较小的顶点代表的数值一定较小。

之后如何判断深度相同的顶点呢，我们必须找到两者的LCA。而要在一个动态加点的前缀树上找LCA，最简单的方式就是倍增技术，为每个顶点维护一个大小为20的数组bl，其中$bl[i]$表示距离当前顶点$2^i$的祖先顶点。这样判断操作就可以在$O(20)$时间内得到。

考虑总的时间复杂度，由于比较会发生$O((n+m)\log_2n)$次，因此总的时间复杂度为$O(20(n+m)\log_2n)$，是可以通过的。

# Codeforces 1312F

**题意**

[https://codeforces.com/contest/1312/problem/F](https://codeforces.com/contest/1312/problem/F)

**题解**

SG函数的循环节上限为$4^{15}$，但是实际上却往往非常小。暴力找出循环节，之后就可以$O(1)$查SG函数了。之后遇到循环节的问题，一定敢暴力，不要被上限所困，因为理论上的上限一般都很难出现。