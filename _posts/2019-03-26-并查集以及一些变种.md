---
categories: data structure
layout: post
---

- Table
{:toc}
# 并查集

## 提个问题

存在若干个元素，$e_1,e_2,\ldots,e_n$。要求我们支持两种操作：

1. 对于给定$i$与$j$，将$e_i$，$e_j$所在的两个集合合并为一个。

2. 对于给定$i$与$j$，判断$e_i$，$e_j$是否处于同一个集合中

如果你将这些元素视作顶点，那么操作1实际是建立边$(e_i, e_j)$，而操作2是询问顶点$e_i$与顶点$e_j$是否连通。问题就转换为图论问题。



并查集是专门用于解决这两个问题的数据结构。

## 按秩合并

并查集的最简单的实现方式是维护一个森林。为每个元素建立一个结点，每个结点维护两个属性：father和rank。father表示父结点，而rank是以自己为根的子树的大小。

```java
class Node{
    Node father = this;
    int rank = 1;
    public Node getRoot(){
        return father == this ? father : father.getRoot();
    }
}
```

查询操作的结果可以通过判断两个元素所在树的根是否相同得到。

合并操作使用的是启发式合并，合并之前先找到两个结点所在树的根，并通过判断根是否相同判断两元素是否处于相同的集合中，如果是相同集合，就可以跳过合并。否则，则将较小集合的根的father字段设置为较大集合的根，并更新较大集合的根的rank字段。

```java
Node union(Node a, Node b){
    a = a.getRoot();
    b = b.getRoot();
    if(a == b){
        return a;
    }
    if(a.rank >= b.rank){
        b.father = a;
        a.rank += b.rank;
        return a;
    }else{
        a.father = b;
        b.rank += a.rank;
        return b;
    }
}
```

由于这里使用的是启发式合并，每次只有较小的树会合并到较大的树中。而一个结点$u$与根的距离每扩大1，意味着它作为较小树中的成员合并到了较大的树中，而$u$所在的树的大小至少增大了一倍。由于$u$所在的树的大小最大为$n$，因此最多被合并$\log_2n$次，即$u$与根的距离最大为$\log_2n$。

因此查询和合并的时间复杂度均为$O(\log_2n)$。

## 路径压缩



# 参考文献

