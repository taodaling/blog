---
categories: algorithm
layout: post
---

- table
{:toc}

# 最小立方倍数问题

给定$n=10000$个数
$$
a_1,a_2,\ldots, a_n
$$
，每个数的范围是
$$
[1,10^{12}]
$$
，要求为每个数
$$
a_i
$$
计算其最小的立方倍数（即
$$
a_i|y^3
$$
）。

这里有一个
$$
O(10^{6}+n\cdot10^4)
$$
的解法。

对于任意数
$$
x\in [1,10^{12}]
$$
，要计算其最小立方倍数。记录Norm(x)表示x的没有立方因子的最大因子，记录Pair(x)表示Norm(x)的最小立方倍数。我们可以先找到所有x的素数因子
$$
p\in [1,10^{12/3}]
$$
。之后利用这些因子可以得到$Norm(x)$。问题在于如何计算$Pair(x)$呢。

考虑数
$$
Norm(x)
$$
除去所有小于
$$
10^{12/3}
$$
的素因子后，最后剩下的数$s$，数$s$可能有三种情况：

1. s是一个素数或1
2. s是两个不同的素数的乘积
3. s是某个素数的平方

对于第一和第二种情况，我们可以直接得出
$$
Pair(s)=s^2
$$
，而对于第三种情况，有
$$
Pair(s)=\sqrt{s}
$$
。

这样假如我们预先处理出所有不超过$10^{12/2}$的素数，并计算出他们的平方。那么我们可以在$O(10^{12/3})$时间复杂度内计算$Pair(x)$和$Norm(x)$。

我们记$Cubic(x)$表示x的最小立方倍数，那么可以得出：
$$
Cubic(x)=x\cdot Pair(x)
$$
。

这里的总的时间复杂度为$O(10^{6}+n\cdot10^4)$。

# 快速绝对值差计算

考虑有这样一个序列$x_1,x_2,\ldots x_n$，其中每个整数都不超过$10^6$，用这个数列可以唯一确定一个函数$f$，其接受一个参数$x_0$，这个函数会输出：
$$
|\ldots|||x_0-x_1|-x_2|-x_3|\ldots-x_n|
$$


其代码大概为：

```java
f(x0){
    ans = x0;
    for(int i = 1; i <= n; i++){
		ans = |ans - a[i]|;       
    }
    return ans;
}
```

现在我们有m个参数$a_1,a_2,\ldots,a_m$，$a_i\leq 10^6$，希望计算这m个输入下f的对应输出$f(a_1),f(a_2),\ldots, f(a_m)$。

其中$n,m \leq 10^6$。

很显然，我们可以在时间复杂度$O(nm)$内解决，但是会花掉过多的时间。

我们可以定义另外n个函数$f_1,f_2,\ldots, f_n$，其中$f_k$表示由序列后k个元素确定的函数，其代码应该为：

```java
fk(x0){
    ans = x0;
    for(int i = n - k + 1; i <= n; i++){
		ans = |ans - a[i]|;       
    }
    return ans;
}
```

可以发现这n个函数之间具有递推关系：
$$
f_i(j)=f_{i-1}(|a[n-i+1]-j|)
$$
。

我们可以将函数用一个数组表示，数组下标为i的元素的值表示输入为i时的输出。

我们自然地定义函数$f_{0}(x)=x$，因此$f_{0}$函数的数组表示为：

```json
[0,1,2,3,4,...,n]
```

之后考虑函数$f_1$，其数组表示为：

```json
[a[n],a[n]-1,a[n]-2, ..., 1, 0, 1, 2, ..., n - a[n]]
```

可以发现$f_1$实际上是将$f_0$的某段前缀翻转并放在了最前面，并删除部分的后缀。

同理我们可以推广出$f_i$到$f_{i+1}$的数组形式的变换。

接下来我们考虑如何快速计算出$f_1,f_2,\ldots, f_n$，我们可以递推处理，这里翻转拼接都可以用持久化平衡树（比如treap）来实现。

而$f=f_n$，因此我们也得到了$f$的数组表示，之后的m个请求可以$O(1)$高效处理。总的时间和空间复杂度为$O(n\log_2n+m)$。

# ARC066B

**题意**

[https://atcoder.jp/contests/arc066/tasks/arc066_b](https://atcoder.jp/contests/arc066/tasks/arc066_b)

**题解**

首先我们需要意识到
$$
a+b=a \oplus b +2\cdot(a\& b)
$$
。

对于只有a为1，而b为0的二进制位，我们可以该二进制位改为a为0，b为1，这样做，$a\oplus b$和$a+b$都不会发生改变。因此处理过后的a是b的一个二进制子集。

现在我们仅考虑符合上面性质的a、b对（a是b的二进制子集），如果有


$$
a\oplus b= u =c\oplus d\\
a+b=v=c+d\Rightarrow a\&b=c\&d
$$


那么我们可以发现对于u中出现的二进制1，b和d都是1，而a和c都是0。而对于u中出现的二进制0，由第二个式子知道，b和d拥有相同的值。故a和c也拥有相同的值。

这样我们就证明了符合条件的(a,b)和(u,v)一一对应。要统计所有的(u,v)，可以通过统计(a,b)得到。

这边可以通过数位DP求解。


