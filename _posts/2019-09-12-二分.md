---
categories: algorithm
layout: post
---

- Table
{:toc}

# 三分算法

假设存在一个定义域和值域均为$\mathbb{R}$的连续下凸函数$f$，要求求函数$f$的极小值。

一般的严格单调函数，我们可以利用二分查找法，以理论最优时间复杂度$O(\log_2D)$，其中D表示函数的定义域大小。

考虑到下凸函数的极值点左端为单调减函数，而右端为单调增函数。我们可以将二分转换为三分，即将区间$[l,r]$划分为$[l,ml]$,$[ml,mr]$和$[mr,r]$。其中$ml=l+(r-l)/3$，而$mr=r-(r-l)/3$。

我们考虑三种情况：
1. 极值点落在$[l,ml]$，这时候一定有$f(ml)\ge f(mr)$，我们可以重置$r=mr$。
2. 极值点落在$[mr,r]$，这时候一定有$f(ml)\le f(mr)$，我们可以重置$l=ml$。
3. 极值点落在$[ml,mr]$，这时候我们可以任意选择重置$l=ml$或$r=mr$的一种。

换言之，我们可以总结为若$f(ml)\ge f(mr)$，则重置$r=mr$，否则重置$l=ml$。

由于每次减少$\frac{1}{3}$的区间，因此时间复杂度为$\log_{1.5}D$。



但是说句实话，三分法要求函数必须为凸函数，而一般问题的难点就是证明函数的凸性。如何保证不存在局部极值点，这是一个很难的问题，当然可以拼运气，但是终究不是好主意。可以选择更加科学的模拟退火算法，其仅需要函数连续，而不要求凸性，尤其在多个维度的情况下，三分并不好写，而模拟退火算法依旧非常好用。

所以为什么要学三分呢，捂脸。。。

# LOJ2169

**题目**

[https://loj.ac/problem/2169](https://loj.ac/problem/2169)

**题解**

首先更新事件有环，我们将更新事件拆分成两个处理。因此现在只剩下一般的线段树操作了。

我们使用整体二分技术，要应用l~r之间的事件，我们先算出中点m，之后将l~m之间的事件应用在线段树上。之后我们查找每个国家的获得的陨石总数，如果超过就标记，否则不标记。

我们将不标记的国家，对其尝试应用m+1~r之间事件。之后我们撤销之前应用l~m之间事件带来的修改，之后对标记的国家，尝试应用l~m之间的事件。

如果l与r相等，就记录结果。

下面我们证明时间复杂度。复杂度分为两部分，一部分是判断国家是否得到了足够的陨石，我们知道每个区域在每个递归层次都只会统计一次，因此统计区域的总的时间复杂度为$O(m\log_2m\log_2k)$。接下来就是递归的时间复杂度了，假设$T(a,b)$表示处理a个国家和b个事件花费的时间，可以推出：


$$
T(a,b)=T(a_1,\frac{b}{2})+T(a-a_1,\frac{b}{2})+O(b
log_2m)=\ldots=O(b\log_2m\log_2k)
$$

总的时间复杂度为$O((m+k)\log_2m\log_2k)$。

# POJ2104

**题意**

[http://poj.org/problem?id=2104](http://poj.org/problem?id=2104)

**题解**

有持久化线段树的$O(n\log_2n)$的在线做法。这里介绍的是整体二分的做法。

首先将元素按照大小进行排序。之后进行二分。当调用二分的时候，我们二分元素，将元素集合分成两部分，之后将左边的元素全部加入到BIT中（BIT中第i元素代表的是第i个元素是否加入，加入为1，否则为0）。之后遍历请求，对于请求q，按照q查询区间中的元素数目与k的关系，将查询也分成两部分。之后重复调用整体二分过程，同时退出函数的时候需要清除这次调用带来的影响。时间复杂度为$O((n+m)(\log_2n)^2)$。

# LUOGU2617

**题意**

[https://www.luogu.org/problem/P2617](https://www.luogu.org/problem/P2617)

**题解**

有树套树的做法，这里介绍的是整体二分的做法。

将所有的修改操作拆成删除元素和增加元素的操作，初始的元素就对应n次新增操作。

之后我们将所有的查询请求和修改请求按照执行时间排序。用整体二分处理请求。

对于中心m，如果是修改操作，且操作的元素值不大于m，那么就处理，否则就跳过。之后将请求拆分成两部分，第一部分就是修改的元素值小于m、或者查询到区间中小于等于m的数目达到或超过k的请求。

整体的时间复杂度为$O(n\log_2n\log_{2}10^9)$。

# LUOGU3332

**题意**

[https://www.luogu.org/problem/P3332](https://www.luogu.org/problem/P3332)

**题解**

将所有数取反，问题实际上就是第k个。用整体二分可以以$O(n(\log_2n)^2)$的时间复杂度解决。

问题与LUOGU2617是相同的，只不过用线段树替换BIT。

# AGC006D

**题意**

[https://atcoder.jp/contests/agc006/tasks/agc006_d](https://atcoder.jp/contests/agc006/tasks/agc006_d)

**题解**

进行二分，考虑问题，最终值是否大于等于x。

这时候，序列中所有小于x的数标记为0，否则标记为1。我们发现如果两个连续的00、11出现，那么它们就不会再改变。

否则，如果0，1交替出现，那么在上面一层，0将变成1，1变成0。因此我们需要知道的就是位置n左右最近的连续的00、11出现的位置，哪个离中心近，哪个就会先占据中心位置，这意味着最终值为0或1。

剩下的就是二分了。

# 二分中的相对和绝对误差

现在很多输出浮点数的题目都会提供两种AC条件，一种是输出与真实结果的绝对误差不超过阈值，一种是输出与真实结果的相对误差不超过阈值。

绝对误差的定义为，预估值为$x$，真实值为$y$，那么绝对误差为$\|x-y\|$，同理相对误差可以定义为$\|\frac{x-y}{y}\|$。

之前一直都没太关注相对误差，但是最近在做Atcoder上的[一道题](https://atcoder.jp/contests/tenka1-2017/tasks/tenka1_2017_e)的时候踩了坑。

相对误差在输出结果很大的时候会发挥巨大的作用。总所周知双精度浮点型共64位，其中1位用于表示符号，11位表示指数，其余的52位用于表示有效数字。简单换算就可以知道双精度浮点型可以精确表示大概15位十进制整数（$2^{10}\approx 10^3$）。

现在考虑一个问题，最终结果为$10^8$，但是要求绝对误差小于$10^{-8}$，这现实吗。事实上尾部的数值由于有效数值不足会被舍去。这就会导致二分的时候，$(l+r)/2$可能会等于$l$或等于$r$，从而导致二分进入死循环。

但是有了相对误差，情况就会大为不同，当输出为$10^8$时，我们可以不需要保留任意小数。

下面考虑相对误差为$t$时，二分左右边界为$l$和$r$时，如何判断是否达到了相对误差阈值，当$l<0<r$的时候，使用绝对误差进行测试，因为这时候不会出现精度问题。如果$l>0$，那么可以利用下面公式检测相对误差：

$$
|\frac{y-l}{y}|\leq |\frac{r-l}{y}|\leq |\frac{r-l}{l}|\leq t\\
$$

对应的，如果$r<0$，那么可以用下面公式检测相对误差：

$$
|\frac{y-l}{y}|\leq |\frac{r-l}{y}|\leq |\frac{r-l}{r}|\leq t\\
$$