---
categories: algorithm
layout: post
---

- Table
{:toc}
# LOJ2169

**题目**

[https://loj.ac/problem/2169](https://loj.ac/problem/2169)

**题解**

首先更新事件有环，我们将更新事件拆分成两个处理。因此现在只剩下一般的线段树操作了。

我们使用整体二分技术，要应用l~r之间的事件，我们先算出中点m，之后将l~m之间的事件应用在线段树上。之后我们查找每个国家的获得的陨石总数，如果超过就标记，否则不标记。

我们将不标记的国家，对其尝试应用m+1~r之间事件。之后我们撤销之前应用l~m之间事件带来的修改，之后对标记的国家，尝试应用l~m之间的事件。

如果l与r相等，就记录结果。

下面我们证明时间复杂度。复杂度分为两部分，一部分是判断国家是否得到了足够的陨石，我们知道每个区域在每个递归层次都只会统计一次，因此统计区域的总的时间复杂度为$O(m\log_2m\log_2k)$。接下来就是递归的时间复杂度了，假设$T(a,b)$表示处理a个国家和b个事件花费的时间，可以推出：


$$
T(a,b)=T(a_1,\frac{b}{2})+T(a-a_1,\frac{b}{2})+O(b
log_2m)=\ldots=O(b\log_2m\log_2k)
$$

总的时间复杂度为$O((m+k)\log_2m\log_2k)$。

# POJ2104

**题意**

[http://poj.org/problem?id=2104](http://poj.org/problem?id=2104)

**题解**

有持久化线段树的$O(n\log_2n)$的在线做法。这里介绍的是整体二分的做法。

首先将元素按照大小进行排序。之后进行二分。当调用二分的时候，我们二分元素，将元素集合分成两部分，之后将左边的元素全部加入到BIT中（BIT中第i元素代表的是第i个元素是否加入，加入为1，否则为0）。之后遍历请求，对于请求q，按照q查询区间中的元素数目与k的关系，将查询也分成两部分。之后重复调用整体二分过程，同时退出函数的时候需要清除这次调用带来的影响。时间复杂度为$O((n+m)(\log_2n)^2)$。

# LUOGU2617

**题意**

[https://www.luogu.org/problem/P2617](https://www.luogu.org/problem/P2617)

**题解**

有树套树的做法，这里介绍的是整体二分的做法。

将所有的修改操作拆成删除元素和增加元素的操作，初始的元素就对应n次新增操作。

之后我们将所有的查询请求和修改请求按照执行时间排序。用整体二分处理请求。

对于中心m，如果是修改操作，且操作的元素值不大于m，那么就处理，否则就跳过。之后将请求拆分成两部分，第一部分就是修改的元素值小于m、或者查询到区间中小于等于m的数目达到或超过k的请求。

整体的时间复杂度为$O(n\log_2n\log_{2}10^9)$。

# LUOGU3332

**题意**

[https://www.luogu.org/problem/P3332](https://www.luogu.org/problem/P3332)

**题解**

将所有数取反，问题实际上就是第k个。用整体二分可以以$O(n(\log_2n)^2)$的时间复杂度解决。

问题与LUOGU2617是相同的，只不过用线段树替换BIT。

# AGC006D

**题意**

[https://atcoder.jp/contests/agc006/tasks/agc006_d](https://atcoder.jp/contests/agc006/tasks/agc006_d)

**题解**

进行二分，考虑问题，最终值是否大于等于x。

这时候，序列中所有小于x的数标记为0，否则标记为1。我们发现如果两个连续的00、11出现，那么它们就不会再改变。

否则，如果0，1交替出现，那么在上面一层，0将变成1，1变成0。因此我们需要知道的就是位置n左右最近的连续的00、11出现的位置，哪个离中心近，哪个就会先占据中心位置，这意味着最终值为0或1。

剩下的就是二分了。