---
categories: algorithm
layout: post
---

- table
{:toc}
# 最小和最大乘积问题

考虑这样一个问题，你需要给出$n$个非负整数$x_1,x_2,\ldots, x_n$，要求它们的和为$m$，算最大乘积：
$$
\prod_{i=1}^nx_i
$$

直观感觉，当$x_i$取$m/n$时可以得到最优解，但是如果$m$不能被$n$整除，就不发保证得到的是整数了。

**命题1：当乘积最大时，$n$个给出的整数中最大值和最小值的差小于等于1**

证明：

非常简单，假设整数中最大值为b，而最小值为a，且$b > a + 1$，那么有：


$$
(b-1)(a+1)=ab+b-a-1>ab
$$


因此我们将$b$替换为$b-1$，而将$a$替换为$a+1$，那么就可以得到更优解，这与假设相悖，因此命题成立。



同理我们可以稍微转换一下问题：我们需要给出$n$个非负整数$x_1,x_2,\ldots, x_n$，要求在它们的乘积至少为$m$的前提下，和尽可能小。

我们知道随着n个整数的和的增大，它们可以严格给出更大的乘积，因此，我们可以二分并检查问题即可，当然这样的时间复杂度为$O(\log_2n\log_2m)$。

事实上，我们知道在最优解中，每个整数的取值落在区间
$$
[\lfloor m^{1/n}\rfloor, \lceil m^{1/n} \rceil]
$$
中，因此我们先令将每个数都取$\lfloor m^{1/n}\rfloor$，之后比较乘积，如果不等，我们就不断将$\lfloor m^{1/n}\rfloor$替换为$\lceil m^{1/n} \rceil$即可，直到最终使得乘积大于m为止。这样时间复杂度为$O(\log_2m)$。

# 当元素大于等于2时，总和一定小于等于总乘积

**命题：当$\forall i(a_i\geq 2)$的时候，一定有$\sum_{i=1}^na_i\leq \prod_{i=1}^na_i$。**

我们不妨认为$a_1\leq a_2\leq\ldots \leq a_n$，那么利用归纳法我们进行如下证明：

当$n=1$的时候，命题显然成立。假设当$n<k$的时候命题恒成立，那么当$n=k$的时候，有

$$
\prod_{i=1}^na_i=a_n\prod_{i=1}^{n-1}a_i\geq a_n\sum_{i=1}^{n-1}a_i\\
\geq 2(n-1)a_n\geq na_n\geq \sum_{i=1}^na_i
$$

因此命题恒成立。

# Atcoder codefestival_2016_final_e

**题意**

[https://atcoder.jp/contests/cf16-final/tasks/codefestival_2016_final_e](https://atcoder.jp/contests/cf16-final/tasks/codefestival_2016_final_e)

**题解**

很好的题目。

首先我们发现我们吃饼干的次数k至多为$O(\log_2n)$级别，因此我们可以直接暴力枚举吃饼干的次数。

考虑次数为k的情况下，假设第$i$次吃饼干之前我们烤了$s_i$秒，而最后我们烤了$s_{k+1}$秒，那么我们花费的总时间为：


$$
kA+(s_1+s_2+\ldots+s_k+s_{k+1})
$$


同时我们必须满足最终得到饼干总数为n，我们可以将其描述为如下约束：


$$
s_1\cdot s_2\cdot\cdots \cdot s_k\cdot s_{k+1}\geq m
$$


这个问题实际上就是最小和最大乘积问题，我们可以将在$O(\log_2n)$的时间复杂度内求解，总的时间复杂度为$O((\log_2n)^2)$，非常的小。

