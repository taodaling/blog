---
categories: algorithm
layout: post
---

- Table
{:toc}

# Prufer编码

prufer编码与树一一对应，可以用于计数树的种类。

先说明如何将一颗树转换为prufer编码。如果树中还剩余多于两个顶点，那么就选择度为1的编号最小的顶点，并将其从树中移除，同时将树中原本唯一与它相连的顶点加入到编码序列尾部。重复该操作直到跳出条件满足。

下面说明将prufer编码转换为树的步骤。维护一个顶点集合X，初始的时候其中包含了所有不出现在prufer编码序列中的顶点。首先从X中移除编号最小的顶点v，并从prufer编码序列中移除最前面的顶点u，在u、v之间连接一条边，如果u不再出现在prufer编码序列中，就将u加入到X中。重复上面的操作直到prufer序列为空。

这里说明一下树转prufer和prufer转树是互逆操作。初始时X集合中仅包含叶子结点，而叶子结点中编号最小的那个结点v一定是在树转prufer时第一个被选择的顶点，之后该顶点的相邻顶点u作为prufer序列的第一个元素。因此我们在prufer转树的第一步就将这两个结点连边。之后的prufer序列对应删除了v后的新树，这里可以用归纳原理证明还原的正确性。

由于树和prufer编码一一对应，我们可以容易发现n个顶点可以组成的树的数目等于$n^{n-2}$。

现在说明prufer编码的性质。

1. 如果一个顶点在原树中的度数为d，那么在prufer编码中包含d-1个该顶点。

# LUOGU2624

**题意**

[https://www.luogu.org/problemnew/solution/P2624](https://www.luogu.org/problemnew/solution/P2624)

**题解**

要统计有多少树，可以通过统计不同prufer编码的数量。即给定一个长度为n-2的序列，要求我们向其中填入1~n，有些数字有限定出现次数，有的没有，组合数学就好了。

# Codeforces1109D

**题意**

[https://codeforces.com/contest/1109/problem/D](https://codeforces.com/contest/1109/problem/D)

**题解**

我们可以暴力枚举a到b之间路径上的顶点数，至少为2，最多为n。现在假设路径上的顶点数为$k$。

由组合数学可以快速得到从a到b这条路径上$k-1$条边总共的权重赋值方案。之后我们需要考虑在固定了a到b这条链后，与其余顶点可以组成多少不同的树。我们可以将a到b中$k$个顶点合并作一个顶点，这样我们问的就是有多少种组成树的方案，最后乘上边权带来的贡献即可。

由prufer编码知道一个顶点度数为d，那么这个顶点会在prufer中出现d-1次。借此我们枚举合并的顶点的度数来求解（每个连接到合并的顶点实际上可能连接到$k$个顶点中的任意一个，这部分贡献不能忘记算）。

记$f(x,n)$表示n个顶点能组成多少树，其中一个顶点是由x个顶点合并得到的。

$$
f(x,n)=\sum_{d=1}^{n-1}{n-2\choose d-1}(n-1)^{(n-2)-(d-1)}x^d\\
=x\sum_{d=1}^{n-1}{n-2\choose d-1}(n-1)^{(n-2)-(d-1)}x^{d-1}\\
=x\sum_{d=0}^{n-2}{n-2\choose d}(n-1)^{(n-2)-d}x^{d}\\
=x(n-1)^{n-2}\sum_{d=0}^{n-2}{n-2\choose d}(\frac{x}{n-1})^d\\
=x(n-1)^{n-2}(1+\frac{x}{n-1})^{n-2}\\
=x(n-1+x)^{n-2}
$$

套上去就可以得出结果了。时间复杂度是$O(n\log_2n)$。