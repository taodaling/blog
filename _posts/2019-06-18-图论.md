---
categories: algorithm
layout: post
---

- Table
{:toc}
# 最小生成树

一个无向连通图的生成树是指该图的一个连通无环子图。而最小生成树就是所有生成树中总边权最小的。

最小生成树的算法有prim和kruskal算法。这里只简单介绍kruskal算法，我们需要做的是对边集按边权从小到大排序，之后遍历处理所有边。如果边的两个端点未连通，那么就将边加入结果中。最后结果中的边就组成了最小生成树。

最小生成树有一些特殊的性质：

1. 最小生成树也是所有生成树中最大边的边权最小的生成树。
2. 最小生成树中任意两个不同端点u，v之间的唯一路径，正好是原无向连通图中u与v之间的最小瓶颈路。（最小瓶颈路是指路径上最大权边的权最小的路径）
3. 同一副图的两个最小生成树的所有边的边权从小到大排序的序列一定相同。
4. 所有生成树，将边权从小到大排成序列，那么最小生成树的边权序列的字典序一定最小。

# BZOJ1232

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1232](https://www.lydsy.com/JudgeOnline/problem.php?id=1232)

**题解**

发现USACO的题目质量好高啊。

首先容易发现，在移除多余的边后得到的是一株树。而无论从那个顶点出发遍历整颗树的最短距离为$2\sum_{e\in E}e.w$，即边权之和的两倍。这很容易理解，遍历以某个顶点为根的子树，我们需要依次遍历每个子结点为根的子树，这和深度优先搜索实际上是相同的实现。而每次我们从根下降访问子树，而访问完子树后需要原路返回，因此每条边都会被经历两次。

但是这距离我们最终结果还相距甚远，因为不仅边有权，点也有对应的权。如果点没有权的话这个问题实际上就是算最小生成树而已。

观察树，对于任意一个顶点u，如果顶点的度为d，那么这个顶点在遍历的整个过程中至少会被访问d次。一条边与父节点连接，这里会访问一次u，之后每次从u的子节点搜索返回，都会访问u一次。根结点比较特殊，因此一开始就位于根结点，因此根节点的访问次数会比它的度额外多1。

因此如果树选取好了，我们简单记作$T=(V,E')$。可以推出最小的要花的时间为：


$$
root.w + \sum_{u\in V}u.w\cdot u.d + \sum_{(u,v)\in E'}(u,v).w\cdot2
$$


因此我们实际上要做的是选取一株树，使得上面式子最小。我们可以将上面公式进行改写：


$$
root.w + \sum_{(u,v)\in E'}((u,v).w\cdot 2+u.w+v.w)
$$


由于root的选择仅影响上面式子中$root.w$这一部分，因此我们始终选择权最小的顶点作为根。而右边和式中，如果我们定义每个边的修正权为$(u,v).w'=(u,v).w\cdot 2+u.w+v.w$，和式就变成了：


$$
\sum_{(u,v)\in E'}(u,v).w'
$$


要使该式最小，只需要基于修正后的边权，生成最小生成树就可以了。

# BZOJ1977

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1977](https://www.lydsy.com/JudgeOnline/problem.php?id=1977)

**题解**

严格最小生成树。看别人博客说是严格次小生成树能和最小生成树只差一条边，我并不知道怎么证明。先记录一下吧。

我们需要维护路径上的最大权边和次大权边，这个用动态树就好了，时间复杂度$O(n\log_2n)$。

# BZOJ3699

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=3699](https://www.lydsy.com/JudgeOnline/problem.php?id=3699)

**题解**

好题。可以脑补一个网格图，左下角网格坐标为(0,0)，横坐标为a，纵坐标为b。之后将所有边按照其a、b分配到网格中。

对于每一个i，我们试图找到最小的一个数j，使得仅使用那些属性a不超过i，属性b不超过j的边，可以保证顶点1和n连通。我们记$f(i)=j$，容易发现f是一个递减函数。

因此，我们可以先从点(-1,50000)出发，之后，不断向右或向下移动一步。可以证明最多移动2L步，L是精灵数要求的上限，这里是50000。

在整个流程中，每条边最多加入图一次，最多被移除一次，因此加入和删除操作会分别发生最多m次。而每次一定后都要重新判断顶点1和n是否连通，即需要查询连通2L次。

可以发现，b越大的边越早被删除。我们以b作为删除时间，那么问题就转换为如何在线维护一副图，图中边有自己的删除时间，要求查询各个时间下的连通性。

这个可以通过动态树实现，我们用动态树维护图的一个生成树。当我们加入一条边时，如果边的两个顶点不连通，这代表加入边后图依旧是森林，即没有环存在。如果边的两个端点连通，那么找到两个端点之间的唯一路径，判断路径上删除时间最小的边，如果该边的删除时间早于我们要加入的边，那么我们可以用新边替换该条边，否则不处理。我们可以保证任意时刻，如果两个顶点在动态树中不连通，那么没有加入动态树的边一定被过期删除了，因此即使这些边加入图中，此时依旧不连通。当然如果连通自然是确实连通的。而用这种方法，并不需要真的执行删除操作，要判断两个顶点连通，只需要判断两条边之间删除时间最早的边是否以及过期。

# LOJ136

**题意**

[https://loj.ac/problem/136](https://loj.ac/problem/136)

**题解**

最小瓶颈路。做法比较简单，我们维护一个图，初始时没有边加入。之后按边的权重不断将边加入，如果因为边的加入导致两个顶点连通，那么这两个顶点在图中的最小瓶颈路的最大权边一定为该边。

这里可以将每个请求关联到两个端点，之后用并查集维护连通性。如果要合并两个连通块，需要将请求合并，合并之前还需要检查请求。这里可以利用启发式合并的思路，保证合并和检查仅发生$q\log_2q$次。总的时间复杂度是$O(m\log_2m+q\log_2q+n)$，空间复杂度为$O(n+m+q\log_2q)$。

# BZOJ1016

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1016](https://www.lydsy.com/JudgeOnline/problem.php?id=1016)

**题解**

按理来说，这道题是不可做的。但是由于相同权值的边数被限制在了10条，因此就有了一种暴力枚举的做法。

首先观察Kruskal的流程，我们可以发现，当我们交换相同权重的边的处理顺序时，才有可能获得新的生成树。因此我们可以将边按照权重分组，从小到大处理。

一种方案是枚举所有边的排列，但是这样的时间复杂度为$10!$，略大。还有一种方案是，我们枚举每条边是否出现在最终的生成树中，这样的时间复杂度为$2^{10}$，是可以接受的。用可撤销的并查集维护构建的生成树，并统计结果数。

这道题的图不一定连通，要小心。

# BZOJ2901

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2901](https://www.lydsy.com/JudgeOnline/problem.php?id=2901)

**题解**

K短路。但是题目中的路径是不允许过重复点的，但是题意中已经给出只能从高处到低处，因此路径上一定不会有重复点。

K短路可以用A star算法求解，空间复杂度为$O(kE)$，时间复杂度为$O(kE\log_2kE)$。

# BZOJ2429

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2429](https://www.lydsy.com/JudgeOnline/problem.php?id=2429)

**题解**

最小生成树或二分。时间复杂度为$O(nlog_2n)$。

# BZOJ1196

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1196](https://www.lydsy.com/JudgeOnline/problem.php?id=1196)

**题解**

可以如果发现在费用上界设为x时有方案，那么设为任意大于x的值也是有方案的。于是可以用二分，二分费用上界。

之后我们用贪心的方式尽可能多用不超过上界的一级道路。之后如果图还不连通，就用二级道路。最后校验是否用够了k条一级道路，以及最后图是否连通。

# BZOJ1715

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1715](https://www.lydsy.com/JudgeOnline/problem.php?id=1715)

**题解**

搜负环的模板题。用Spfa，递归版有奇效。

# BZOJ1050

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1050](https://www.lydsy.com/JudgeOnline/problem.php?id=1050)

**题解**

假如要求最小边的权一定为x，那么我们可以只考虑边权大于等于x的边，按边权从小到大加入到图中，直到s、t连通。这时候最大边的边权为y，则y/x为要求的最小比值。这里是一个贪心的做法。

我们可以枚举最终解中的最小边，提前排序边集，总共有$M$种可能。利用滑动窗口的技巧，我们不必在每次考虑新的最小边的时候重建整个图。这意味着我们只需要做$M$次加边、删边、判连通操作。

我们注意到后加的边一定后删，因此我们可以用LCT判连通。当新的边加入后会成环，那么就剔除环中最早加入的边即可。这样保证连通性检测时的结果不会变动，同时只处理树形结构。

总的时间复杂度为$O(Mlog(N+M))$。

# BZOJ1093

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1093](https://www.lydsy.com/JudgeOnline/problem.php?id=1093)

**题解**

首先我们可以对图中的环进行缩小点，一个点的点权表示该点由多少点缩点而来。我们希望找到一个最大的半连通图，点权和最大。缩完点后的图是有向无环图。

假设G=(V,E)为我们找到的最大半连通图，观察它满足的性质。首先G一定是有向无环连通图，同时我们一定可以找到一个唯一的顶点v，其入度为0（否则假如找到两个点u、v入度都为0，这意味着u、v之间不存在一条路径，这与G是半连通图相悖）。在移除v后得到的图还是半连通图。我们不断重复移除的过程得到了一个顶点序列$v_1,v_2,\ldots ,v_n$。我们可以保证它们构成一条路径。而一条路径一定是半连通图。因此我们得知一个图是半连通图当且仅当它的所有顶点序列可以构成一条路径。

故，我们实际上要找到的是图中的一个最大权路径，在DAG中，我们可以在顶点的拓扑序上使用动态规划技术得到。

# Codeforces1205D

**题意**

[https://codeforces.com/problemset/problem/1205/D](https://codeforces.com/problemset/problem/1205/D)

**题解**

如果我们为根结点赋予权重0，并且为其余结点均赋予不小于父结点权重的权重。那么我们可以通过差分得到连接父子结点的边的权重，并且权重非负。现在考虑要为一株树上的n个顶点赋予一组权重，我们可以遍历整棵树，按照遍历的顺序从小到大赋予权重，这样进行差分后得到的边的权重均非负，且从根结点到树中任意顶点v的路径总权等于v的顶点权重。

考虑星图，我们认为根结点下挂n-1个顶点。我们任意选择一个C，满足$n/3\leq C \leq 2n/3$。并为前C个子结点赋予权重$1,2,\ldots, C$，而后面的$n-C-1$个子结点赋予权重$(C+1),2(C+1),\ldots, (n-C-1)(C+1)$，这样利用前C个顶点和后n-C-1个顶点我们就可以组合得到$\[1,2n^2/9\]$之间的所有值了。

考虑一般的树，我们找到树的重心，可知重心下最大子树的大小不超过$n/2$。我们可以排序重心下的子顶点，并贪心找到一组子树，使得总大小C落在区间$\[n/3,2n/3\]$中。之和，我们为这组子树中顶点赋予权重1~C，而其余子树中顶点赋予权重$(C+1),2(C+1),\ldots, (n-C-1)(C+1)$。

# BZOJ3786

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=3786](https://www.lydsy.com/JudgeOnline/problem.php?id=3786)

**题解**

首先有换父操作，因此我们需要用到动态树。Link-Cut-Tree适合处理路径问题，但是题目中要求支持子树增强权重的操作。

考虑另外一个动态树实现Euler-Tour-Tree。我们利用DFS可以将树转换为括号序列，并用平衡树维护序列。这样将以x为根的子树移除出树，等价于将x的开闭括号从序列中删除。而将以x为根的子树连接到y下，等价于找到y的闭括号，并将x对应的括号序列加到y的闭括号之前。

之后查找x到根所有顶点的权重之和，可以用一种特殊的技巧统计路径信息。我们在遇到开括号时，执行加操作，在遇到闭括号时执行减操作。这样只需要统计根的开括号到x的开括号这段序列的权和即可。

# 参考文献

- [最小生成树的一些性质和理解](<https://blog.csdn.net/zengchen__acmer/article/details/17323245>)