---
categories: algorithm
layout: post
---

- Table
{:toc}

# 最小生成树

一个无向连通图的生成树是指该图的一个连通无环子图。而最小生成树就是所有生成树中总边权最小的。

因为之后的分析要用到最小生成树的一些性质，因此这里详细介绍下。

## prim和kruskal

最小生成树的求法不外乎两种，prim和kruskal。两个都是贪心算法，正确性基于最小生成树类似的性质。

随意取一个顶点u，记所有与u关联的最小权边为$e=(u,v)$，其中$u\neq v$。现在我们证明e一定属于一株最小生成树，用反证法。假设最小生成树T中不包含e。我们知道e是与u关联的最小边，因此可以将e加入到T中，这样就会出现一个包含点u的环。删除环上与u相连的另外一条边e'，得到了一株新的树T'，而T'的总权不可能大于T（加入e删除了e'，e的权重小于等于e')，因此weight(T')<=weight(T)。这样我们就得到了包含e的一株最小生成树。

由这个观察我们可以推出贪心的流程。

1. 创建一个空集T。

2. 任意取一个顶点u，找到与该顶点u相关联的最小权重边e=(u,v)，满足$u\neq v$，从点集V中删除u、v，并将e加入到空集T中，之后合并顶点u、v，将合并后的顶点加入到V中。
3. 如果V中只剩一个顶点了，那么就结束，此时T就是最小生成树。否则回到步骤2。

上面这个流程就是prim算法。由于并不限制步骤2的u的选择，因此你可以总是选择顶点1以及包含顶点1的合并顶点，这样整个流程就完全等价于dijkstra算法了，用最小堆优化后得到的时间复杂度为$O(\min((V+E)\log_2V, V^2))$。

prim算法是通过点去找边，也可以通过边去找点，下面的算法就是如此：

1. 创建一个空集T。
2. 从边集E中弹出权重最小的边e=(u,v)，如果在生成树T中u、v不处于相同连通块，就将e加入T中，否则忽略e。
3. 如果E为空集，那么就结束，此时T就是最小生成树。否则回到步骤2。

上面这个流程就是kruskal算法，我们可以提前对E进行排序，并用路径压缩并查集维护连通块，这样时间复杂度为$O(E+E\log_2E)$。

## 最小瓶颈路

一条路径中，权重最大的边称为路的瓶颈，而从起点到终点的所有路径中瓶颈最小的路径称为最小瓶颈路。

对于两个不同的顶点i,j，记$f_{ij}(x)$表示只保留图中权重不超过x的边的前提下，顶点i与j是否连通（连通为1，不连通为false）。很显然这样的函数$f\_{ij}$一定是非严格递增函数。假设i、j之间的最小瓶颈路的瓶颈权重为t，那么$t$一定是$f\_{ij}$最小的能令其返回1的入参。

因此我们可以先对边集按照权重从小到大进行排序，之后按序将边的两个端点所在连通块合并为一个连通块。这个过程持续直到i和j处于相同的连通块中。

这个流程实际上和kruskal是如同的，因此我们可以相信最小生成树中的任意两个端点i、j之间的唯一路径就是图上的最小瓶颈路。

## 求所有最小生成树的并集

给定一张无向连通图，求其所有最小生成树的并集。

有两种方法。

第一种方法，就是先任意构建一个最小生成树，显然最小生成树中的所有边都要被包含进去。考虑任意未被包含进最小生成树的边$e=(a,b)$，其连通两个顶点，考虑最小生成树中从a到b的唯一路径上权重最大的边$e'$，由于最小生成树具有最小瓶颈路的性质，因此$e'$的权重不可能大于$e$。如果$e'$的权重恰好等于$e$，那么我们可以从最小生成树中删除边$e'$并加入$e$来获取一颗新的最小生成树。

上面的总的时间复杂度为$O((n+m)\log_2n)$，路径操作可以用LCT实现。

第二种方法是，考虑kruskal算法，我们将边集按照边的权重进行分组，第i组就是所有权重为i的边组成的集合。注意到我们可以通过变换同组边之间的处理顺序得到所有的最小生成树。我们可以证明不管如何打乱同一组边的处理顺序，在处理完第i组的边后，所有的连通关系都是相同的，即在一种顺序下两个顶点是连通的，那么在另外一种处理顺序下亦然。这个可以利用归纳法进行证明，假设处理完前i-1类边后连通关系相同。那么考虑以任意顺序处理第i类边，如果第i组边中所有边最后都被加入最小生成树，那么连通关系肯定相同。如果不是所有边被加入，那么考虑任意一个未被加入的边$(a,b)$，那么我们可以断定a和b一定连通（否则我们可以将$(a,b)$纳入最小生成树中）。因此当我们处理完前i类边后，对于任意前i类边$(u,v)$，$(u,v)$一定是连通的。

而一条边是否有机会组成最小生成树，假设边的权重为k，那么我们只要观察，在处理完前$k-1$类边后，这条边的两个端点是否连通即可。第二种方法的时间复杂度也是$O((n+m)\log_2n)$，但是这边不需要用到LCT，只需要用到并查集即可。

## 求最小生成树的数目

最小生成树的数目可以通过kruskal算法求出。在求所有最小生成树的并集这一节中，已经说过了所有kruskal算法流程中，可以通过变换边的处理顺序得到所有的最小生成树。事实上，对于固定的图，要得到最小生成树，其中所有权重为i的边选取的数量也是固定的（和边的处理顺序无关）。假设最小生成树中权重为$i$的边共选择了$c_i$个，那么我们在处理第$i$类边的时候，可以暴力枚举选取$c_i$条边的，情况，去除其中成环的情况。不同权重的边可以独立处理。

## 最小生成树的一些题目

**题目1：给定$n$个顶点$m$条边构成的无向连通图，第$i$个顶点的权值为$w(i)$。要求找到一组边，构成生成树，且要求$\sum_{v}deg(v)w(i)$最大**

我们发现加入一条边$(u,v)$，会导致结果增大$w(u)+w(v)$。我们可以将$w(u)+w(v)$作为边$(u,v)$的权值，用最小生成树算法找到最大生成树即可。

# Euler Tour Tree

Euler Tour Tree也是动态树，支持$O(\log_2n)$的换根，加边，删边操作。类似于Link-Cut-Tree，但是底层原理是将树表示为DFS序，并将DFS序放到平衡树上去维护。

要了解更多，可以去阅读斯坦福大学的课件，地址如下：

[http://web.stanford.edu/class/archive/cs/cs166/cs166.1146/lectures/05/Slides05.pdf](http://web.stanford.edu/class/archive/cs/cs166/cs166.1146/lectures/05/Slides05.pdf)

Euler Tour Tree和Link Cut Tree的区别在于，后者是以Splay森林保存信息，每个森林中的树都代表一条树上的路径，因此Link Cut Tree非常适合用于处理路径问题。而前者是以一株平衡树进行维护的，因此可以很好的利用树的一些性质，比如处理子树问题。

# 连通性检测

对于一个含有n个顶点的无向图，一开始边集为空。你需要处理m个请求，请求内容为下面三类：

1. 增加一条边
2. 删除一条边
3. 判断两个顶点是否处于相同相同的连通块中

## 离线线段树做法

现在我们换个角度来理解问题，有m个时间点，每个时间点，每个请求都会修改某个时间区间的状态。最后要求在所有请求完成后，每个时间点的状态。

这涉及到了区间修改和单点查询，妥妥的就是线段树啊。我们可以把每个请求看成一个事件，事件从某个时间点$L$起到某个时间点$R$结束。我们可以用线段树来存储事件，但是特殊的是，我们不下推时间，即如果有一个线段树顶点代表的区间被某个时间完整覆盖，那么我们将这个事件绑定到这个顶点上，而不继续下推。

很容易证明每次请求最多会修改$\log_2m$个顶点。而最后查询的时候我们在进入顶点的时间执行所有的事件（合并连通块），而在离开顶点的时候撤销所有事件（分裂连通块），由于连通和分裂是一个栈式操作，因此我们可以用不带路径压缩的并查集来维护连通块。由于每个事件只会被处理两次（执行和撤销），而总共有$m\log_2m$个事件，每次合并分裂的时间复杂度均为$\log_2n$，因此总的时间复杂度为$O(m\log_2n\log_2m)$，空间复杂度为$O(m\log_2m+n)$。

## 特殊情况做法

如果存在某个特殊的数$x$，满足前$x$个请求都是加边，而后$m-x$个请求都是删边操作，那么我们可以以线性时间复杂度计算出结果。

具体做法如下。容易发现没有删除操作的情况下，只需要用并查集就可以维护所有连通块，因此前$x$个请求一定能在线性时间复杂度内完成。现在考虑后$m-x$个删除操作。假如删除操作完成后，我们进行回退，会发现我们只需要执行$m-x$个增加操作即可。因此结果还是$O(m-x)$。

总的时间复杂度和空间复杂度都是线性的。

## 离线LCT做法

如果题目可以允许我们离线，我们可以用Link-Cut-Tree轻松解决这个问题。按序处理请求：

1. 假设要加的边为e=(u,v)，我们先检查后面第一个删除边e的类型三请求出现的序号，记作t，将e的寿命设为t。假如此时u和v不连通，那么就直接插入e，用e将u和v连通。否则，我们判断u和v所在路径中寿命最短的边z，判断z的寿命是否小于e的寿命，如果小于，删除z加入e，否则忽略e。
2. 不处理。
3. 假设要处理的顶点对为u、v。先判断u、v是否连通，不连通，则必定不连通。如果连通，就判断u、v之间路径上寿命最短的顶点z，如果z的寿命小于当前请求的序号，则不连通，否则连通。

利用离线做法，我们每次请求都变成了常数次LCT操作，总的时间复杂度为$O((n+m)\log_2n)$。

## 在线做法

如果问题强制要求我们在线，那么就需要使用euler tour tree来解决问题。

首先我们将边分成$L=\log_2n$层。对于边e，记Level(e)表示e所在图的层级，边的层级只降不升。同时建立L个图$G_i$，其中$G_i$包含所有n个顶点和所有层级不超过i的边，我们维护它的最小生成树$F_i$，每个边的权重就是它们所在的级别。我们需要维护两个不变的性质：

1. $G_i$中的连通块大小不会超过$2^i$
2. $F_i=F_L \cap G_i$。

维护一个集合E用来保存所有的加入后没有删除的边的信息。接下来按先后顺序处理所有请求：

1. 设新增的边为e=(u,v)，将e加入E，将Level(e)设为L。之后检查$F_L$中u、v是否连通，如果不连通就向$F_L$插入e，否则忽略。

2. 设删除的边为e=(u,v)，先从集合E中删除e。首先如果e不出现在$F_L$中，那么流程直接结束，因为不会影响到连通性。下面考虑e出现在$F_L$中的情况：

   - for i = Level(e) -> L:

     - 从$F_i$中删除e
- 删除了e并不能保证u、v就不连通了，因为可能存在替换边，我们可以保证假如替换边存在，那么替换边的级别至少是Level(e)，（由最小生成树性质得到）
   - for i = Level(e) -> L:
     - 由于删除了边e，我们将原先u、v所在连通块切分为了两部分，分别记作$B_u$和$B_v$。这里加色和$B_u$的大小不超过$B_v$，考虑到$\|B_u\|+\|B_v\|\leq 2^i$，因此$\|B_u\| \leq 2^{i-1}$，因此我们可以将$B_u$中的全部级别为i的边下推到级别i-1中去
     - 下推$B_u$中的全部级别为i的边到级别i-1中去。
     - for (x, y) in E where Level((x,y))=i and x in $B_u$:
       - if x、y在$F_L$中处于相同的连通块中：
         - 将(u,v)的级别减少1
       - else:
         - 将$(u,v)$加入到$F_i,F_{i+1},\ldots, F_L$中去。并结束过程。

3. 假设要查询的顶点对位u,v，只需要判断在$F_L$中u、v是否在相同连通块中即可。


对于操作1，时间复杂度为$O(\log_2n)$。对于操作2，时间复杂度为$O((\log_2n)^2)$。由于每条边被下放最多$L$次，因此这部分的时间复杂度为$O(m(\log_2n)^2)$。总的时间复杂度为$O(m(\log_2n)^2)$。

# BZOJ1232

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1232](https://www.lydsy.com/JudgeOnline/problem.php?id=1232)

**题解**

发现USACO的题目质量好高啊。

首先容易发现，在移除多余的边后得到的是一株树。而无论从那个顶点出发遍历整颗树的最短距离为$2\sum_{e\in E}e.w$，即边权之和的两倍。这很容易理解，遍历以某个顶点为根的子树，我们需要依次遍历每个子结点为根的子树，这和深度优先搜索实际上是相同的实现。而每次我们从根下降访问子树，而访问完子树后需要原路返回，因此每条边都会被经历两次。

但是这距离我们最终结果还相距甚远，因为不仅边有权，点也有对应的权。如果点没有权的话这个问题实际上就是算最小生成树而已。

观察树，对于任意一个顶点u，如果顶点的度为d，那么这个顶点在遍历的整个过程中至少会被访问d次。一条边与父节点连接，这里会访问一次u，之后每次从u的子节点搜索返回，都会访问u一次。根结点比较特殊，因此一开始就位于根结点，因此根节点的访问次数会比它的度额外多1。

因此如果树选取好了，我们简单记作$T=(V,E')$。可以推出最小的要花的时间为：


$$
root.w + \sum_{u\in V}u.w\cdot u.d + \sum_{(u,v)\in E'}(u,v).w\cdot2
$$


因此我们实际上要做的是选取一株树，使得上面式子最小。我们可以将上面公式进行改写：


$$
root.w + \sum_{(u,v)\in E'}((u,v).w\cdot 2+u.w+v.w)
$$


由于root的选择仅影响上面式子中$root.w$这一部分，因此我们始终选择权最小的顶点作为根。而右边和式中，如果我们定义每个边的修正权为$(u,v).w'=(u,v).w\cdot 2+u.w+v.w$，和式就变成了：


$$
\sum_{(u,v)\in E'}(u,v).w'
$$


要使该式最小，只需要基于修正后的边权，生成最小生成树就可以了。

# BZOJ1977

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1977](https://www.lydsy.com/JudgeOnline/problem.php?id=1977)

**题解**

严格最小生成树。看别人博客说是严格次小生成树能和最小生成树只差一条边，我并不知道怎么证明。先记录一下吧。

我们需要维护路径上的最大权边和次大权边，这个用动态树就好了，时间复杂度$O(n\log_2n)$。

# BZOJ3699

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=3699](https://www.lydsy.com/JudgeOnline/problem.php?id=3699)

**题解**

好题。可以脑补一个网格图，左下角网格坐标为(0,0)，横坐标为a，纵坐标为b。之后将所有边按照其a、b分配到网格中。

对于每一个i，我们试图找到最小的一个数j，使得仅使用那些属性a不超过i，属性b不超过j的边，可以保证顶点1和n连通。我们记$f(i)=j$，容易发现f是一个递减函数。

因此，我们可以先从点(-1,50000)出发，之后，不断向右或向下移动一步。可以证明最多移动2L步，L是精灵数要求的上限，这里是50000。

在整个流程中，每条边最多加入图一次，最多被移除一次，因此加入和删除操作会分别发生最多m次。而每次一定后都要重新判断顶点1和n是否连通，即需要查询连通2L次。

可以发现，b越大的边越早被删除。我们以b作为删除时间，那么问题就转换为如何在线维护一副图，图中边有自己的删除时间，要求查询各个时间下的连通性。

这个可以通过动态树实现，我们用动态树维护图的一个生成树。当我们加入一条边时，如果边的两个顶点不连通，这代表加入边后图依旧是森林，即没有环存在。如果边的两个端点连通，那么找到两个端点之间的唯一路径，判断路径上删除时间最小的边，如果该边的删除时间早于我们要加入的边，那么我们可以用新边替换该条边，否则不处理。我们可以保证任意时刻，如果两个顶点在动态树中不连通，那么没有加入动态树的边一定被过期删除了，因此即使这些边加入图中，此时依旧不连通。当然如果连通自然是确实连通的。而用这种方法，并不需要真的执行删除操作，要判断两个顶点连通，只需要判断两条边之间删除时间最早的边是否以及过期。

# LOJ136

**题意**

[https://loj.ac/problem/136](https://loj.ac/problem/136)

**题解**

最小瓶颈路。做法比较简单，我们维护一个图，初始时没有边加入。之后按边的权重不断将边加入，如果因为边的加入导致两个顶点连通，那么这两个顶点在图中的最小瓶颈路的最大权边一定为该边。

这里可以将每个请求关联到两个端点，之后用并查集维护连通性。如果要合并两个连通块，需要将请求合并，合并之前还需要检查请求。这里可以利用启发式合并的思路，保证合并和检查仅发生$q\log_2q$次。总的时间复杂度是$O(m\log_2m+q\log_2q+n)$，空间复杂度为$O(n+m+q\log_2q)$。

# BZOJ1016

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1016](https://www.lydsy.com/JudgeOnline/problem.php?id=1016)

**题解**

按理来说，这道题是不可做的。但是由于相同权值的边数被限制在了10条，因此就有了一种暴力枚举的做法。

首先观察Kruskal的流程，我们可以发现，当我们交换相同权重的边的处理顺序时，才有可能获得新的生成树。因此我们可以将边按照权重分组，从小到大处理。

一种方案是枚举所有边的排列，但是这样的时间复杂度为$10!$，略大。还有一种方案是，我们枚举每条边是否出现在最终的生成树中，这样的时间复杂度为$2^{10}$，是可以接受的。用可撤销的并查集维护构建的生成树，并统计结果数。

这道题的图不一定连通，要小心。

# BZOJ2901

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2901](https://www.lydsy.com/JudgeOnline/problem.php?id=2901)

**题解**

K短路。但是题目中的路径是不允许过重复点的，但是题意中已经给出只能从高处到低处，因此路径上一定不会有重复点。

K短路可以用A star算法求解，空间复杂度为$O(kE)$，时间复杂度为$O(kE\log_2kE)$。

# BZOJ2429

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2429](https://www.lydsy.com/JudgeOnline/problem.php?id=2429)

**题解**

最小生成树或二分。时间复杂度为$O(nlog_2n)$。

# BZOJ1196

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1196](https://www.lydsy.com/JudgeOnline/problem.php?id=1196)

**题解**

可以如果发现在费用上界设为x时有方案，那么设为任意大于x的值也是有方案的。于是可以用二分，二分费用上界。

之后我们用贪心的方式尽可能多用不超过上界的一级道路。之后如果图还不连通，就用二级道路。最后校验是否用够了k条一级道路，以及最后图是否连通。

# BZOJ1715

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1715](https://www.lydsy.com/JudgeOnline/problem.php?id=1715)

**题解**

搜负环的模板题。用Spfa，递归版有奇效。

# BZOJ1050

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1050](https://www.lydsy.com/JudgeOnline/problem.php?id=1050)

**题解**

假如要求最小边的权一定为x，那么我们可以只考虑边权大于等于x的边，按边权从小到大加入到图中，直到s、t连通。这时候最大边的边权为y，则y/x为要求的最小比值。这里是一个贪心的做法。

我们可以枚举最终解中的最小边，提前排序边集，总共有$M$种可能。利用滑动窗口的技巧，我们不必在每次考虑新的最小边的时候重建整个图。这意味着我们只需要做$M$次加边、删边、判连通操作。

我们注意到后加的边一定后删，因此我们可以用LCT判连通。当新的边加入后会成环，那么就剔除环中最早加入的边即可。这样保证连通性检测时的结果不会变动，同时只处理树形结构。

总的时间复杂度为$O(Mlog(N+M))$。

# BZOJ1093

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1093](https://www.lydsy.com/JudgeOnline/problem.php?id=1093)

**题解**

首先我们可以对图中的环进行缩小点，一个点的点权表示该点由多少点缩点而来。我们希望找到一个最大的半连通图，点权和最大。缩完点后的图是有向无环图。

假设G=(V,E)为我们找到的最大半连通图，观察它满足的性质。首先G一定是有向无环连通图，同时我们一定可以找到一个唯一的顶点v，其入度为0（否则假如找到两个点u、v入度都为0，这意味着u、v之间不存在一条路径，这与G是半连通图相悖）。在移除v后得到的图还是半连通图。我们不断重复移除的过程得到了一个顶点序列$v_1,v_2,\ldots ,v_n$。我们可以保证它们构成一条路径。而一条路径一定是半连通图。因此我们得知一个图是半连通图当且仅当它的所有顶点序列可以构成一条路径。

故，我们实际上要找到的是图中的一个最大权路径，在DAG中，我们可以在顶点的拓扑序上使用动态规划技术得到。

# Codeforces1205D

**题意**

[https://codeforces.com/problemset/problem/1205/D](https://codeforces.com/problemset/problem/1205/D)

**题解**

如果我们为根结点赋予权重0，并且为其余结点均赋予不小于父结点权重的权重。那么我们可以通过差分得到连接父子结点的边的权重，并且权重非负。现在考虑要为一株树上的n个顶点赋予一组权重，我们可以遍历整棵树，按照遍历的顺序从小到大赋予权重，这样进行差分后得到的边的权重均非负，且从根结点到树中任意顶点v的路径总权等于v的顶点权重。

考虑星图，我们认为根结点下挂n-1个顶点。我们任意选择一个C，满足$n/3\leq C \leq 2n/3$。并为前C个子结点赋予权重$1,2,\ldots, C$，而后面的$n-C-1$个子结点赋予权重$(C+1),2(C+1),\ldots, (n-C-1)(C+1)$，这样利用前C个顶点和后n-C-1个顶点我们就可以组合得到$\[1,2n^2/9\]$之间的所有值了。

考虑一般的树，我们找到树的重心，可知重心下最大子树的大小不超过$n/2$。我们可以排序重心下的子顶点，并贪心找到一组子树，使得总大小C落在区间$\[n/3,2n/3\]$中。之和，我们为这组子树中顶点赋予权重1~C，而其余子树中顶点赋予权重$(C+1),2(C+1),\ldots, (n-C-1)(C+1)$。

# BZOJ3786

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=3786](https://www.lydsy.com/JudgeOnline/problem.php?id=3786)

**题解**

首先有换父操作，因此我们需要用到动态树。Link-Cut-Tree适合处理路径问题，但是题目中要求支持子树增强权重的操作。

考虑另外一个动态树实现Euler-Tour-Tree。我们利用DFS可以将树转换为括号序列，并用平衡树维护序列。这样将以x为根的子树移除出树，等价于将x的开闭括号从序列中删除。而将以x为根的子树连接到y下，等价于找到y的闭括号，并将x对应的括号序列加到y的闭括号之前。

之后查找x到根所有顶点的权重之和，可以用一种特殊的技巧统计路径信息。我们在遇到开括号时，执行加操作，在遇到闭括号时执行减操作。这样只需要统计根的开括号到x的开括号这段序列的权和即可。

# Codeforces1209F

**题意**

[https://codeforces.com/contest/1209/problem/F](https://codeforces.com/contest/1209/problem/F)

**题解**

我的做法和题解的不太一样。

首先观察问题，假设1到x的最短路径为1,..,y, x，那么x的数值则是在y的数值的尾部添加若干数字得到，即x的数值一定大于y的数值。我们发现这个性质有点类似于最短路问题，且在这种意义上，我们可以推出边权是非负的。这样我们就可以堂而皇之地使用Dijkstra算法解决它。

首先我们解决一个问题，如果进行比较操作，即如何判断离1所在连通块最近的顶点。

我们可以用一株前缀树维护所有顶点的最短距离，这样每个顶点所在的最短距离就是前缀树的某个顶点。这里我们需要使用动态开点技术，由于每条边最多建立$\log_2m$个前缀树顶点，因此前缀树的大小是$O(m\log_2m)$的。

之后如果比较两个顶点与1所在连通块的距离，我们知道距离已经被我们映射为了前缀树的顶点。因此就是比较两个顶点所代表的数值的大小。

由于边没有前置0，那么深度不同的顶点的大小，可以完全通过深度进行判断，深度较小的顶点代表的数值一定较小。

之后如何判断深度相同的顶点呢，我们必须找到两者的LCA。而要在一个动态加点的前缀树上找LCA，最简单的方式就是倍增技术，为每个顶点维护一个大小为20的数组bl，其中$bl[i]$表示距离当前顶点$2^i$的祖先顶点。这样判断操作就可以在$O(20)$时间内得到。

考虑总的时间复杂度，由于比较会发生$O((n+m)\log_2n)$次，因此总的时间复杂度为$O(20(n+m)\log_2n)$，是可以通过的。

# Atcoder jsc2019_qual_d

**题意**

[https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_d](https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_d)

**题解**

一个图，如果所有的环都是偶数长度当且仅当该图是二分图。

首先说方案，对于n，我们将其分为n层。如果两个顶点的标号i、j第一个不同的二进制位为第k位，那么边(i,j)属于第k类。由于第k个图中的边的两侧端点的第k二进制位都不同，因此一定是二分图。由此证明了方案是正确的划分。

下面证明最少要划分为
$$
\lceil \log_2n \rceil
$$
层。

一个图能的边如果能够被分类为k类，那么我们称该图满足k分，满足k分的显然也能满足k+1分。下面我们证明一个命题：

**命题：能被k分的最大完全图包含$2^k$个顶点。**

证明：

归纳法证明。当k为0和1的时候命题显然成立。下面考虑已知命题在$k=x$时成立，那么考虑大小为$2^x+1$的完全图。我们知道它至少得被x分，那么它能被x分吗？假设它能被x分，我们知道每个层级都是将图划分为左右两部分，图中共$2^x+1$个顶点，因此任意层的二分图的至少一侧有$2^{x-1}+1$个顶点。考虑我们第x层二分图，我们设左边有不少于$2^{x-1}+1$个顶点，那么我们将左边的顶点重新标号为$1,2,\ldots, 2^{x-1}+1$，接下来将其余所有顶点删除，这就转换成了大小为$2^{x-1}+1$的图的一个分类。考虑到第x层图只有左侧顶点，即没有边的存在，因此不需要第x层图。即我们证明了大小为$2^{x-1}+1$的图能被$x-1$分。但是由归纳法知道，这是不可能的。

至此，命题证明完毕。


# 最短路算法

一些记号：

- $G$: 图
- $V$: 顶点集合（在公式中表示顶点数目）
- $E$: 边集（在公式中表示边数目）
- $(u,v)$: 从$u$到$v$的边
- $W(u,v)$: 边$(u,v)$的权重
- $D(u)$: 从源点到$u$的最短距离
- $L(u)$: 从源点到$u$的最短路径的拥有的边数（长度）

## BFS算法

BFS算法适用于这样一类图，所有的边的权重恰好都是1。BFS算法的时间复杂度为$O(V+E)$。

BFS算法非常简单，我们需要维护一个先进先出的队列，一开始将除了源点外所有顶点的距离设为无穷，而将源点的距离设为0。之后我们将源点加入到队列中，重复下面过程直到队列为空：

1. 弹出队列头部顶点，记作$u$。
2. 遍历$u$的所有出边$(u,v)$，如果$D(v)>D(u)+1$，那么就令$D(v)=D(u)+1$，并且将$v$加入到队列尾部。

BFS算法实际上会先找到最短路径为0的所有顶点，之后是为1的，之后为2的，如是循环。很显然，由于在加入$v$的时候，所有最短距离小于$D(u)$的顶点都已经被处理了，因此可以保证之后$v$的距离都不会再变化，因此每个顶点恰好被入队以及处理一次，总的时间复杂度为$O(V+E)$。

## 01权重BFS算法

BFS算法除了可以解决所有边权为1的图的最短路，还能解决所有边权为0或1的图的最短路问题。

非常简单，BFS的原理是一个简化版本的Dijkstra算法，我们用维护一个距离递增的队列来存储顶点。而实际上维护这样一个队列，是可以允许边为0的。考虑现在处理的队列前端元素为$v$，那么很显然弹出$v$后，队列中的所有元素距离都不小于$D(v)$。这样假如存在一条$0$权重边$(v,u)$，那么我们得到了$u$的距离也是为$D(v)$，这意味着将$u$加入到队列前端也不会影响队列中顶点距离递增的性质。因此我们这也就可以直接支持0或1边权的图了。

## 单源最短路算法：Dijkstra算法

Dijkstra算法要求图中的所有边权非负，它的时间复杂度为$O(\min(V^2+E,(V+E)\log_2V))$。

Dijkstra算法基于贪心算法，同样我们需要一开始将除了源点外所有顶点的距离设为无穷，而将源点的距离设为0。之后我们重复下面操作直到所有顶点都被处理过了：

1. 找到所有未处理的顶点中最短距离最小的那个顶点$u$。
2. 将$u$标记为处理过
3. 遍历所有$u$的出边$(u,v)$，如果$D(v)>D(u)+W(u,v)$，那么就令$D(v)=D(u)+W(u,v)$。

很显然上面的算法时间复杂度为$O(V^2+E)$。上面的算法的正确性基于了每个顶点处理前，比它最短距离更小的顶点都已经被处理过了，因此这个顶点的最短距离一定是真正的最短距离。

如果我们采用小根堆来存储顶点，那么时间复杂度就变成了$O(V+E)\log_2V)$。

## 单源最短路算法：Bellman-Ford算法

BM算法允许负权边，并且可以判断图中是否有负权环，它的时间复杂度为$O(V(V+E))$。

BF引入了松弛的概念，非常简单就是选一组顶点，遍历它们的出边，然后尝试优化入点的最短距离，比如说考虑顶点$u$，如果存在出$(u,v)$且$D(v)>D(u)+W(u,v)$，那么就将$D(u)$修改为$D(u)+W(u,v)$。

由于有负权边存在，因此Dijkstra采用的贪心策略是不能保证正确性的。但是我们可以发现在图上选择所有顶点跑一次松弛后尽管大部分顶点的最短距离是错误（大于真实的最短距离）的，但是对于$L(u)=1$的顶点$u$，它的最短距离是此时正确的。同理，当我们跑$k$次BFS后，所有满足$L(u)\leq k$的顶点$u$的最短距离都是正确的。

因此当图中不存在负权环的时候，由于对于任意顶点$u$满足$L(u)<V$，因此我们只需要在原图上选择所有顶点跑最多$V-1$次松弛即可。

当图中存在负权环的时候，那么我们在跑完$V$次BFS后如果有顶点的$L(u,v)$被标记为$V$，那么就一定存在了负权环。

无论是否存在负权环，时间复杂度的上界都是$O(V(V+E))$。

## 单源最短路算法：Spfa算法

Spfa的全称是Shortest path faster algorithm，我们可以将其理解为BF算法的优化版本（但是并没有优化时间复杂度的上界）。

考虑BF算法，我们发现如果某个顶点在上一次的BFS的最短距离没有变动，那么在下一次的BFS的时候就没必要将其作为源点加入。

Spfa算法的优化就是这么简单，其具体实现就是维护一个先进先出的队列，如果一个顶点的最短距离被修改了就入队。循环直到队列为空，或者某个顶点$u$的$L(u)\geq V$，前者无负环，后者表示出现了负环。

在不存在负环的时候Spfa一般会比BF算法快一点，但是有负环的时候两者相差不大。

## 全源最短路算法：Floyd-Warshall

FW算法可以用于计算图中每个点对的最短距离，FW允许负权边，但是不允许存在负权环。

我们用动态规划来计算所有点对的最短距离。由于s与t的最短距离必定会对应至少一条最短路径s..t，而s..t中除了两个端点外序号最大的点记为M(s..t)，称为路径的最大点。利用函数M，我们可以将图中所有路径分类为n种，第i类路径，其最大点为i。

FW算法的原理就是按分类从小到大处理所有路径，并利用这些路径计算得到所有点对之间的最短距离。记D(i,j,k)表示所有从i到j的前k类路径中最短的路径长度。对于D(i,j,k+1)，很显然i与j之间的最短路要么是前k类路，要么就是第k+1类路。如果是第k+1类路，这条路中的最大点为k+1，将路以k+1为断点分裂为两条，i..k+1，k+1..j，很显然两条路都是前k类路。因此：

$$
D(i,j,k+1)=\min(D(i,j,k), D(i,k+1,k)+D(k+1,j,k))
$$

之后动态规划，$O(n^3)$可以解决。

```java
for(k = 1; k <= n; k++){
    for(i = 1; i <= n; i++){
        for(j = 1; j <= n; j++){
            D[i][j] = min(D[i][j], D[i][k]] + D[k][j]);
        }
    }
}
```

## 全源最短路算法：Johnson

这个算法允许图中出现负权边，但是不允许图中出现负权环。它的时间复杂度为$O(\min(VE\log_2V, V^3))$，在图比较稀疏的时候会优于Floyd算法。

我们知道在没有负权边的时候，可以将每个顶点作为源点跑一次Dijkstra算法，这样的时间复杂度为$O(\min(VE\log_2V, V^3))$，那么在有负权的边的时候，能不能也用Dijkstra算法呢？Johnson算法就解决了这个问题。

首先我们向图中加入一个新的顶点，并从新的顶点到所有其它顶点建立一条权重为$0$的有向边，之后我们计算以新顶点作为源点的单源最短路（由于图中有负权边，所以使用BF算法）。

现在我们得到了每个顶点的最短距离，现在我们对所有图中原本存在的边的边的边权进行修正，考虑边$(u,v)$，我们将其新的边权设置为$W(u,v)+D(u)-D(v)$，由最短路性质我们知道$D(u)+W(u,v)\geq D(v)$，因此我们可以得知所有边的新的边权一定非负。

现在考虑一条路径$v_1,v_2,\ldots, v_k$，它的修正后的距离为

$$
W'(v_1,v_2)+W'(v_2,v_3)+\ldots +W'(v_{k-1},v_k)\\
=W(v_1,v_2)+D(v_1)-D(v_2)+\ldots +W(v_{k-1},v_k)+D(v_{k-1})-D(v_k)\\
=W(v_1,v_2)+W(v_2,v_3)+\ldots +W(v_{k-1},v_k)+D(v_1)-D(v_k)
$$

而$D(v_1)$和$D(v_k)$是已知的常数，因此我们可以保证在边权修正之前和修正之后两点之间的最短路是同一条。因此现在的问题就变成了在一个所有边权非负的图上找最短路。

# 最小环算法

Floyd算法也可以用于解决最小环问题。所谓的最小环问题，是指在图中找到一个总边权最小的长度至少为3的简单环。

考虑最小环C，设C上编号最大的顶点为x，记x左右两边的顶点为u，v，C上边的总权重为c，那么必定有

$$
c=D(u,v,x-1)+D(v,x,x-1)+D(x,u,x-1)
$$

我们可以在Floyd流程套入计算最小环的过程。

```java
c = INF;
for(k = 1; k <= n; k++){
    for(i = 1; i <= n; i++){
        for(j = 1; j <= n; j++){
            if(i != j && edges[j][k] && edges[k][i]){
            	c = min(c, D[i][j]+D[j][k]+D[k][i]);
            }
        }
    }
    for(i = 1; i <= n; i++){
        for(j = 1; j <= n; j++){
            D[i][j] = min(D[i][j], D[i][k]] + D[k][j]);
        }
    }
}
```

# BZOJ1491

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1491](https://www.lydsy.com/JudgeOnline/problem.php?id=1491)

**题解**

Floyd+DP

# BZOJ1027

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1027](https://www.lydsy.com/JudgeOnline/problem.php?id=1027)

**题解**

由于a+b+c=1，因此若(a,b)一旦确定，那么c就随着确定。现在考虑两个点$(x_1,y_1),(x_2,y_2)$。对于$t\in [0,1]$，可以取到形如点$(x_1t+x_2(1-t), y_1t+y_2(1-t))$，这些点组成的实际是$(x_1,y_1)$与$(x_2,y_2)$之间的线段。之后继续加点，我们会得到凸多边形。

至此，我们知道了题目实际上的本意，将需求转换为二维平面上的点，我们要找到尽可能少的原料代表的点，使得这些点唯一确定的凸包能包含所有需求点。

一个点落于凸多边形中当且仅当这个点处于凸多边形的所有边的逆时针方向。

我们可以证明要寻找的n个原料点一定是凸包上的点，且由点数最少，可以推出边数最少。能够形成凸包的边一定满足所有顶点都落在凸包的逆时针方向。

我们将所有满足条件的边的边权设为1，不满足条件的边的边权设为无穷。那么可以得出最小环一定是最优解组成凸包上的边。

最小环可以通过FW算法得到。

# LUOGU2371

**题意**

[https://www.luogu.org/problem/P2371](https://www.luogu.org/problem/P2371)

**题解**

神奇的题目，很显然DP是不可能的，暴力也是不可能的。

真正的解法，是从$\{a_i\}$选取任意一个数，记作k。之后我们建立k个顶点，分别代表模k时余数为$0,1,\ldots,k-1$。

之后对于顶点$i$和数$a_j$，我们建立边$(i,(i+a_j)%k)$。之后我们寻找以顶点0为起点的单源最短路径。

对于数x，记$r=x%k$，如果顶点r距离顶点0的最短距离为d，那么根据d与x的大小关系，我们可以快速判断出是否能找到一组非负整数解$\{x_i\}$，使的$\sum_ia_ix_i=x$。如果$d<x$，不存在解，如果$d\geq x$，那么就有解。

# 欧拉迹

欧拉闭迹是指一条包含图中所有边的一条路径，每条边在路径中仅会出现一次，且路径的起点和终点是相同顶点。

一个无向图中包含欧拉闭迹，当且仅当下面两条性质同时满足：

- 图是连通的
- 图中每个顶点的度均为偶数

而一个有向图包含欧拉闭迹，当且仅当下面两条性质同时满足：

- 图是连通的
- 图中每个顶点入度和出度相同

欧拉开迹类似于欧拉闭迹，但是路径的起点和终点允许是不同的顶点。

我们可以发现欧拉开迹可以通过欧拉闭迹删除掉一条边后得到，因此我们也得到了判断欧拉开迹的条件。

一个无向图中包含欧拉开迹，当且仅当下面两条性质同时满足：

- 图是连通的
- 图中除了两个顶点外，其余每个顶点的度均为偶数

而一个有向图包含欧拉开迹，当且仅当下面两条性质同时满足：

- 图是连通的
- 图中除了两个顶点外（这两个顶点如果出度与入度不同，那么必定一个出度比入度少1，一个入度比出度少1），其余每个顶点入度和出度相同

Hierholzer算法用于在连通图寻找欧拉迹，其流程非常简单。

从一个可能的起点出发，进行深度优先搜索，但是每次沿着辅助边从某个顶点移动到另外一个顶点的时候，都需要删除这个辅助边。如果没有可移动的路径，则将所在结点加入到栈中，并返回。

```java
dfs(node, trace){
	while(!node.edges.isEmpty()){
		Node next = node.edges.removeLast();
		dfs(next, trace);
	}
	trace.addLast(node);
}
```

最后得到的栈中保存的就是整个欧拉闭迹中的顶点。

这个算法应用起来非常简单，下面我们先证明几条性质。

**性质1. 如果图中包含闭欧拉迹，则栈的底部存储的必定是起点。如果图中包含的是开欧拉轨迹，则栈底部存储的是与起点不同的另外一个奇度数端点。**

证明：当我们要入栈时，说明当前所在顶点没有任何边了。考虑到从起点出发到当前结点的路径中，除了起点和当前顶点外，所有的顶点都失去了偶数度数（在移除了途经的边后）。如果起点和当前顶点不同，那么两者都失去了奇数度数。如果图中包含闭欧拉迹，这意味着所有顶点的初始度数都是偶数，而当前顶点的剩余度数为0，表示当前顶点的初始度数必定是奇数，当然这是不可能的，因此假设不成立，当前顶点就是起点。同样的对于开欧拉迹，当前顶点不可能是起点，否则起点的度数就是偶数，而开欧拉迹中起点和终点的度数一定是奇数。这样就能推出当前顶点既不是起点度数也是偶数，因此一定是终点。



**性质2.如果图中包含闭欧拉迹，入栈的倒数第二个顶点一定是路径中的第二个顶点。**

证明：由于路径中的第二个顶点入栈，说明起点已经入栈过，换言之，起点已经没有多余的边了。

# 一类最小瓶颈路问题

**问题1：有无向图，有n个顶点，m条边。你从顶点1出发，去往顶点n。每条边上有一个机关，第i条边会使你损失$c_i$点血量。一旦你血量为负数，那么就会回到起点。每当你抵达一个顶点时，你的血量会完全恢复。问至少需要多少血量，才能保证你能顺利抵达顶点n。**

这个问题有比较简单的做法，二分血量，每次校验时，将所有伤害低于血量的边加入，之后判断顶点1和顶点n是否连通即可。时间复杂度为$O((n+m)\log_2m)$。

**问题2：有无向图，有n个顶点，m条边。每条边上有一个机关，第i条边会使你损失$c_i$点血量。一旦你血量为负数，那么就会回到起点。每当你抵达一个顶点时，你的血量会完全恢复。现在有Q个询问，每个询问指定一个起点和终点，问分别至少需要多少血量才能顺利从起点出发抵达终点。**

这个问题可以通过整体二分解决，总的时间复杂度为$O((m + q)\log_2n\log_2m)$。另外一种做法就是观察出对于起点是u，终点是v的时候，我们实际上要求的从$u$到$v$的最小瓶颈路，而已知最小生成树中每对顶点之间存在的唯一路径都是二者之间的最小瓶颈路，因此我们只需要找到最小生成树，之后用LCT维护整棵树，每个请求都可以以$O(log_2n)$的时间复杂度统计。

**问题3：有无向图，有n个顶点，m条边。每条边上有一个机关，第i条边会使你损失$c_i$点血量。一旦你血量为负数，那么就会回到起点。顶点分成两类，第一类顶点具有恢复生命的能力，第二类顶点则没有。现在有Q个询问，每个询问指定一个起点和终点（起点和终点都是第一类顶点），问分别至少需要多少血量才能顺利从起点出发抵达终点。**

首先为每个第二类顶点算出其距离最近的第一类顶点的最短距离（利用多源最短路算法）。之后记$d(u)$表示第二类顶点u到最近的第一类顶点的距离。之前我们判断一条边加不加入是靠边的伤害是否不高过血量，现在我们需要修改判断的标准，对于边$e_i=(a,b)$，当且仅当血量不低于$d(a)+d(b)+c_i$。之后问题转换为最小瓶颈路问题，用整体二分或者LCT都可以。

这边说明一下原因好了，假设血量上限为$x$。我们可以定义状态$(i,j)$表示位于顶点i上，并且有j滴血量。我们可以在图上进行搜索来判断是否可以从某个顶点移动到另外的顶点。如果i是第一类顶点，那么由于恢复的效果，因此$(i,x)$可以从$(i,j)$转移抵达，换言之，我们从$(i,j)$到$(i,x)$加上一条有向边。但是i是对于第二类顶点的情况，那么如果$j<d(i)$，那么很显然不能从$(i,j)$转移到血量更高的状态，这也意味着这些状态无法转移到任意顶点为终点的状态，我们可以直接无视这些状态。现在考虑$(i,j)$，其中$x-d(i)\geq j\geq d(i)$，那么我们可以先从这个顶点出发到达最近的第一类顶点之后再次回到当前顶点，从而血量提高到$x-d(i)$，因此我们从$(i,j)$向$(i,x-d(i))$连一条边。事实上，对于任意$(i,j)$，其中i是第二类点，$j>x-d(i)$，都是不可达的，因此我们也可以无视这些状态。

现在我们可以将上面提到的状态和转移进行压缩，我们可以认为顶点$i$对应的就是状态$(i,x-d(i))$（这是可达的并且可以通过后续转移抵达某个第一类顶点的最优状态）。现在我们考虑边$e_k=(a,b)$，我们是否可以从$(a,x-d(a))$转移到$(b,x-d(b))$呢，这要求我们经过边$e_k$从a到b后剩余的血量至少不少于$d(b)$，即$x-d(a)-c_k\geq d(b)\Rightarrow x\geq d(a)+d(b)+c_k$。这就是题解中公式的由来。

**问题4：有一颗有$n$个顶点的树$T$，顶点分成两类，第一类具有恢复效果，第二类则没有。经过第$i$条边，会受到$c_i$点伤害($1\leq c_i\leq 5$。初始的时候或者抵达第一类顶点的时候血量会恢复到$k$（一旦血量为负则会直接失败）。现在给出$q$个请求，每个请求给定两个顶点$(u,v)$，要求回答是否有可能从$u$出发抵达$v$，不保证$u,v$是第一类点。**

如果能保证每次起点和终点都是第一类顶点的话，这个问题实际上就成为了问题$3$的弱化版。但是这里不保证。

如果没有第一类顶点，那么我们每次只能选择最短路，这条路是树上的唯一路径。因此比较一下血量不小于路径长度即可。

首先我们将所有边切分成单位为0.5的边（比如边的伤害为2，我们就切成四条边，中间创建三个临时顶点）。这样一条边最多切成了$10$条边，而我们可以对应的将血量翻倍。现在问题就成了有一副图，经过每条边都会受到一点伤害，而你的血量是$2k$。

我们可以尝试建立这样一幅图$G$，如果两个第一类顶点的距离不超过$2k$，那么我们可以自由通行与这两个顶点之间，于是我们在$G$上将这两个顶点上建立一条边。对于图$G$，如果两个顶点连通，那我们对应的在树上就可以进行相互转移。由于图$G$只有连通性有用，因此我们可以直接通过维护一个并查集实现。可以证明任意一个$G$中连通块对应的都是一株原树的子树（连通块在$T$中依旧保持连通）。

下面我们考虑怎么求$G$，我们当然可以对每个顶点跑一次单源最短路，但是这样太慢了。我们可以对于每个第一类顶点$v$求出距离它小于等于$k$的顶点，并将它们并入到$v$所在的连通块中。这样任意两个距离不超过$2k$的顶点对，它们的连通块必定会有交集。当然这样求$G$还是太慢了，我们可以换一种做法。先以所有第一类顶点作为起点抛出多源最短路径。之后如果某个顶点$x$距离最近的第一类点$y$的距离小于$k$，那么它的邻近的顶点$z$自然是属于$y$所在的并查集的，事实上我们可以保证$x$与$y$属于相同的并查集，因此我们只需要将$x$与$z$合并即可。这样我们只需要$O(n+n\alpha(n))$的时间复杂度就可以算出$G$中的所有连通信息了。

现在考虑一个请求$u$到$v$。很显然对于一个请求，我们有两种选择，第一种就是不在任何第一类顶点上休息，第二种就是进行了至少进行了一次休息。第一种请求求一下树上路径长度即可，通过差分+求LCA就可以直接解决。下面考虑第二种情况。这时候我们发现$u$到$v$的路径上被切分成若干段，每一段都属于$G$上的不同连通块。第二种选择的策略实际是这样的，我们先移动到某个连通块的边缘顶点$x$，之后去往同一连通块中最近的第一类顶点恢复，之后转移到距离$v$最近的且与当前所在第一类顶点在属于相同连通块的某个顶点$y$，之后从所在处去往$v$。

但是这里我们抵达$x$后需要保留$k$点血量以保证能到达最近的第一类顶点，同理$y$由于与$v$不属于相同的连通块，因此$y$距离一定处于所在连通块的边缘，即此时剩余的血量正好为$k$。

换句话说，$u$到$x$的距离不能超过$k$，而$y$到$v$的距离也不能超过$k$。现在问题变成，如果两个人分别从$u$最多走$k$步，$v$最多走$k$步，问是否有可能两个人最终处于相同的连通块。

考虑到$G$上的连通块是对应$u$到$v$路径上连续的一段，而$u$到$v$的距离超过$2k$。于是乎显然我们应该向彼此尽量靠近，即分别向对方走$k$步，最后判断一下是否处于相同的连通块即可。

提供一道CF[题目](https://codeforces.com/contest/1307/problem/F)。

# CF1253F

**题意**

[https://codeforces.com/contest/1253/problem/F](https://codeforces.com/contest/1253/problem/F)

**题解**

一类最小瓶颈路问题，问题3。

# Erdos-Gallai定理与Havel–Hakimi算法

给定一个包含$n$个顶点的无向简单图（无重边），以及每个顶点的度$d_1,d_2,\ldots,d_n$，问是否存在这样的图，如果存在就构造出来。

如何判断图是否存在.首先有解的前提是度数之和为偶数且所有度数非负。

Erdos-Gallai定理给出了一种$O(n)$时间复杂度的检查方法。其命题如下：

假设度数从大到小排序，$d_1\geq d_2\geq \ldots \geq d_n$，那么如果对于所有$1\leq k\leq n$，下面公式都成立，那么就有解，否则无解。

$$
\sum_{i=1}^kd_i\leq k(k-1)+\sum_{i=k+1}^n\min(d_i,k)
$$

这个公式可以通过一些预先处理，在$O(n)$时间复杂度内计算完成。

那么现在知道有有没有解后，如何构造一组解呢。

很显然构造一组解的时间复杂度至少为$O(D)$，其中$D$是所有顶点的度数的和。我们可以用
Havel–Hakimi递归算法来实现。方法如下，我们将所有顶点按度数从大到小排序后，顶点$1$与$2,3,\ldots, d_1+1$建立一条边。之后我们递归解决剩下的包含$n-1$个顶点且度数分别为$d_2-1,d_3-1,\ldots, d_{d_1+1}-1, d_{d_1+2}, \ldots, d_n$的无向图构建问题。

Havel–Hakimi算法的总的时间复杂度为$O(n^2)$，排序可以选择将修改部分和未修改部分合并或基数排序。

# Codeforces 1301F

**题意**

[https://codeforces.com/contest/1301/problem/F](https://codeforces.com/contest/1301/problem/F)

**题解**

容易发现我们可以对每个颜色作为源头进行一次BFS，这样就能保证快速得到每个位置到另外一种颜色任意位置的最短距离，记$D(c,i,j)$，表示位置$(i,j)$到颜色为$c$的任意位置的最短距离。

现在我们考虑如何找到两点的最短距离。考虑到最短距离可能出现了同色块之间的转移，也可能没出现。

没出现的情况下，这时候两点的最短距离是二者之间的曼哈顿距离。

在出现的情况下，我们可以枚举第一次发生同色转移的颜色，记这个颜色为$c$，那么此时最短距离可以分解三部分，第一部分是从颜色$c$的任意块转移到$(r_1,c_1)$，第二部分是从颜色为$c$的任意块转移到$(r_2,c_2)$，第三部分就是我们枚举的$c$颜色的两个位置的转移，因此此时的最短距离为$D(c,r_1,c_1)+D(c,r_2,c_2)+1$。

总的时间复杂度为$O(knm+qk)$，需要注意不要用太多$stl$的东西，这道题目卡常严重。

# Codeforces 1305G Kuroni and Antihype

**题意**

[https://codeforces.com/contest/1305/problem/G](https://codeforces.com/contest/1305/problem/G)

**题解**

首先我们先认为每个人的权值都不同。

我们可以加入一个权值为0的人（记作第$n+1$个人），并且认为这个人一开始就加入了Antihype。同时我们可以假设所有的数都不能自主加入Antihype，必须通过他人邀请才能加入。可以发现这样不会改变结果。

首先我们想一个naive的方法，如果两个人$i,j$是朋友，那么我们可以加入两条单向边$(i,j),(j,i)$，前者的权值为$a_j$，后者的权值为$a_i$。现在我们希望选择其中一部分边，并拿到这些边的权值。选择的规则如下：

- 每个顶点最多有一条入边被激活。
- 沿着顶点的入边不断后退，最后一定会回到顶点$n+1$。

很显然这最终得到的是一个有向图生成树（树形图），同时我们要求权值最大，即要求求最大权树形图，这可以用最小树形图算法解决，时间复杂度是$O(E\log_2V)$。$V=n+1$，是已知，但是$E$可以有多大呢。

任意两个数且运算后位0，那么我们可以枚举$0$到$2^{18}-1$的每个数$x$，以及$x$的子集$a$，这样就可以找到另外一个数$b=x-a$。这样统计的好处是不会出现重复（我们可以恒要求$a>b$来避免重复）。

通过上面算法，我们可以找到所有的边，以及估计出了边的总数为$O(3^{18})$，数量级是3亿级别的。因此上面的算法自然无法通过。（但是至少我们得出了一个比$O(n^2)$或$O(4^{18})$更好的方法）。

我们可以考虑另外一种统计方案，记$out(v)$表示顶点$v$的出度。那么我们实际要统计的是：

$$
\sum_{v}out(v) a_v
$$

上面的公式不能帮助我们太多，但是如果我们用无向边来替代有向边，那么我们会发现每个顶点的出度都会增大1（因为原来的唯一入边也转换成了出边），现在我们记$deg(v)$表示顶点$v$的度数，我们要求的就是：

$$
\sum_{v}(deg(v)-1) a_v=\sum_{v}deg(v)a_v+\sum_va_v
$$

其中$\sum_va_v$是常数，我们可以忽略，现在我们希望$\sum_{v}deg(v)a_v$最大。这个玩意可以将其转换为最小生成树问题（可以参考最小生成树的一些题目-题目1）。

现在我们面对的问题是找到一颗最小生成树。我们可以考虑使用kruskal算法，kruskal要求对边按边权排序，我们可以很自然的从大到小枚举$x$即可。这样我们就给出了一个$O(3^{18}\alpha(n))$，其中$\alpha(n)$是反阿克曼函数，可以直接作为常数看待。

最后还剩下一个问题，就是存在重复的权值。我们可以这样考虑，如果在枚举到$(u,v)$的时候，$u$有$c(u)$个处于不同连通块的人，而$v$有$c(v)$个处于不同连通块的人，我们要让它们连通，只需要加$c(u)+c(v)-1$条边即可，之后他们就连通了，修改$c(u),c(v)$为1即可。

总的时间复杂度为$O(3^{18}\alpha(n))$。

# 完全图相关问题

**问题1：给定一个拥有$n$个顶点的完全图，将所有无向边都转换为一条单向边。告诉你这${n\choose 2}$条边的方向，要求找到其中一个顶点，这个顶点到其它所有顶点都存在一条路径。**

当顶点数只有1的时候，很容易求解。现在假设顶点数为$n$，且我们找到了$1,2,\ldots,n-1$的导出子图的一个满足条件的顶点$v$。现在考虑顶点$n$和$v$，如果从$n$到$v$有一条边，那么$n$到其余顶点就都有路径了，同理如果$v$到$n$有一条边，$v$到其余顶点也都有路径了。

**问题2：给定一个拥有$n$个顶点的完全图，现在我们将所有无向边都转换为一条单向边。每条无向边有可能有两种颜色，粉色或绿色。现在已知所有粉色的单向边的方向，但是所有绿色边都是未知的。现在要求使用最多$n$次请求，每次请求询问一条绿色边的方向。要求找到其中一个顶点，这个顶点到任意其它顶点，都存在一条仅使用一种颜色边的路径。**

首先我们仅考虑粉色边的存在，用tarjan算法处理出强连通分量。

如果此时入边为0强连通分量数目为1，那么任取该强连通分量中的任意顶点作为根即可。否则我们取两个入度为0的不同强连通分量，并从每个强连通分量中各取一个绿边入度为0的顶点，这样一次查询至少一个顶点入度变成了1。如果一个强连通分量中所有顶点的绿边入度都变成了1，就删除这个强连通分量。重复这个操作，直到满足推出条件。

证明一下算法的正确性，首先找到的根由于绿边入度为0，其它顶点要么绿边入度为1，要么就能被根访问到。由于绿边不存在环，因此绿边入度为1的顶点都能被根访问到。

之后每次询问一个顶点入度从0变成1，因此最多发生$n-1$次查询。

一道CF[原题](https://codeforces.com/contest/1142/problem/E)。

# 参考文献

- [最小生成树的一些性质和理解](<https://blog.csdn.net/zengchen__acmer/article/details/17323245>)
- [斯坦福课件](http://web.stanford.edu/class/archive/cs/cs166/cs166.1146/lectures/05/Slides05.pdf)
- [https://pdfs.semanticscholar.org/a35c/cea03eb856b6f13908d8db78aeef47bc6819.pdf](https://pdfs.semanticscholar.org/a35c/cea03eb856b6f13908d8db78aeef47bc6819.pdf)
- [https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95](https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95)
- [https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93Gallai_theorem](https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93Gallai_theorem)
- [https://en.wikipedia.org/wiki/Havel%E2%80%93Hakimi_algorithm](https://en.wikipedia.org/wiki/Havel%E2%80%93Hakimi_algorithm)