---
categories: algorithm
layout: post
---

- Table
{:toc}
# 最小生成树

一个无向连通图的生成树是指该图的一个连通无环子图。而最小生成树就是所有生成树中总边权最小的。

因为之后的分析要用到最小生成树的一些性质，因此这里详细介绍下。

## prim和kruskal

最小生成树的求法不外乎两种，prim和kruskal。两个都是贪心算法，正确性基于最小生成树类似的性质。

随意取一个顶点u，记所有与u关联的最小权边为$e=(u,v)$，其中$u\neq v$。现在我们证明e一定属于一株最小生成树，用反证法。假设最小生成树T中不包含e。我们知道e是与u关联的最小边，因此可以将e加入到T中，这样就会出现一个包含点u的环。删除环上与u相连的另外一条边e'，得到了一株新的树T'，而T'的总权不可能大于T（加入e删除了e'，e的权重小于等于e')，因此weight(T')<=weight(T)。这样我们就得到了包含e的一株最小生成树。

由这个观察我们可以推出贪心的流程。

1. 创建一个空集T。

2. 任意取一个顶点u，找到与该顶点u相关联的最小权重边e=(u,v)，满足$u\neq v$，从点集V中删除u、v，并将e加入到空集T中，之后合并顶点u、v，将合并后的顶点加入到V中。
3. 如果V中只剩一个顶点了，那么就结束，此时T就是最小生成树。否则回到步骤2。

上面这个流程就是prim算法。由于并不限制步骤2的u的选择，因此你可以总是选择顶点1以及包含顶点1的合并顶点，这样整个流程就完全等价于dijkstra算法了，用最小堆优化后得到的时间复杂度为$O(\min((V+E)\log_2V, V^2))$。

prim算法是通过点去找边，也可以通过边去找点，下面的算法就是如此：

1. 创建一个空集T。
2. 从边集E中弹出权重最小的边e=(u,v)，如果在生成树T中u、v不处于相同连通块，就将e加入T中，否则忽略e。
3. 如果E为空集，那么就结束，此时T就是最小生成树。否则回到步骤2。

上面这个流程就是kruskal算法，我们可以提前对E进行排序，并用路径压缩并查集维护连通块，这样时间复杂度为$O(E+E\log_2E)$。

## 最小瓶颈路

一条路径中，权重最大的边称为路的瓶颈，而从起点到终点的所有路径中瓶颈最小的路径称为最小瓶颈路。

对于两个不同的顶点i,j，记$f_{ij}(x)$表示只保留图中权重不超过x的边的前提下，顶点i与j是否连通（连通为1，不连通为false）。很显然这样的函数$f\_{ij}$一定是非严格递增函数。假设i、j之间的最小瓶颈路的瓶颈权重为t，那么$t$一定是$f\_{ij}$最小的能令其返回1的入参。

因此我们可以先对边集按照权重从小到大进行排序，之后按序将边的两个端点所在连通块合并为一个连通块。这个过程持续直到i和j处于相同的连通块中。

这个流程实际上和kruskal是如同的，因此我们可以相信最小生成树中的任意两个端点i、j之间的唯一路径就是图上的最小瓶颈路。

# Euler Tour Tree

Euler Tour Tree也是动态树，支持$O(\log_2n)$的换根，加边，删边操作。类似于Link-Cut-Tree，但是底层原理是将树表示为DFS序，并将DFS序放到平衡树上去维护。

要了解更多，可以去阅读斯坦福大学的课件，地址如下：

[http://web.stanford.edu/class/archive/cs/cs166/cs166.1146/lectures/05/Slides05.pdf](http://web.stanford.edu/class/archive/cs/cs166/cs166.1146/lectures/05/Slides05.pdf)

Euler Tour Tree和Link Cut Tree的区别在于，后者是以Splay森林保存信息，每个森林中的树都代表一条树上的路径，因此Link Cut Tree非常适合用于处理路径问题。而前者是以一株平衡树进行维护的，因此可以很好的利用树的一些性质，比如处理子树问题。

# 连通性检测

对于一个含有n个顶点的无向图，一开始边集为空。你需要处理m个请求，请求内容为下面三类：

1. 增加一条边
2. 删除一条边
3. 判断两个顶点是否处于相同相同的连通块中

## 离线做法

如果题目可以允许我们离线，我们可以用Link-Cut-Tree轻松解决这个问题。按序处理请求：

1. 假设要加的边为e=(u,v)，我们先检查后面第一个删除边e的类型三请求出现的序号，记作t，将e的寿命设为t。假如此时u和v不连通，那么就直接插入e，用e将u和v连通。否则，我们判断u和v所在路径中寿命最短的边z，判断z的寿命是否小于e的寿命，如果小于，删除z加入e，否则忽略e。
2. 不处理。
3. 假设要处理的顶点对为u、v。先判断u、v是否连通，不连通，则必定不连通。如果连通，就判断u、v之间路径上寿命最短的顶点z，如果z的寿命小于当前请求的序号，则不连通，否则连通。

利用离线做法，我们每次请求都变成了常数次LCT操作，总的时间复杂度为$O((n+m)\log_2n)$。

## 在线做法

如果问题强制要求我们在线，那么就需要使用euler tour tree来解决问题。

首先我们将边分成$L=\log_2n$层。对于边e，记Level(e)表示e所在图的层级，边的层级只降不升。同时建立L个图$G_i$，其中$G_i$包含所有n个顶点和所有层级不超过i的边，我们维护它的最小生成树$F_i$，每个边的权重就是它们所在的级别。我们需要维护两个不变的性质：

1. $G_i$中的连通块大小不会超过$2^i$
2. $F_i=F_L \cap G_i$。

维护一个集合E用来保存所有的加入后没有删除的边的信息。接下来按先后顺序处理所有请求：

1. 设新增的边为e=(u,v)，将e加入E，将Level(e)设为L。之后检查$F_L$中u、v是否连通，如果不连通就向$F_L$插入e，否则忽略。

2. 设删除的边为e=(u,v)，先从集合E中删除e。首先如果e不出现在$F_L$中，那么流程直接结束，因为不会影响到连通性。下面考虑e出现在$F_L$中的情况：

   for i = Level(e) -> L:

   ​	从$F_i$中删除e

   删除了e并不能保证u、v就不连通了，因为可能存在替换边，我们可以保证假如替换边存在，那么替换边的级别至少是Level(e)，（由最小生成树性质得到）

   for i = Level(e) -> L:

   ​	由于删除了边e，我们将原先u、v所在连通块切分为了两部分，分别记作$B_u$和$B_v$。这里加色和$B_u$的大小不超过$B_v$，考虑到$\|B_u\|+\|B_v\|\leq 2^i$，因此$\|B_u\| \leq 2^{i-1}$，因此我们可以将$B_u$中的全部级别为i的边下推到级别i-1中去。

     下推$B_u$中的全部级别为i的边到级别i-1中去。

     for (x, y) in E where Level((x,y))=i and x in $B_u$:

   ​		if x、y在$F_L$中处于相同的连通块中：

   ​			将(u,v)的级别减少1

   ​		else:

   ​			将$(u,v)$加入到$F_i,F_{i+1},\ldots, F_L$中去。并结束过程。

3. 假设要查询的顶点对位u,v，只需要判断u、v是否在相同连通块中即可。



对于操作1，时间复杂度为$O(\log_2n)$。对于操作2，时间复杂度为$O((\log_2n)^2)$。由于每条边被下放最多$L$次，因此这部分的时间复杂度为$O(m(\log_2n)^2)$。总的时间复杂度为$O(m(\log_2n)^2)$。

# BZOJ1232

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1232](https://www.lydsy.com/JudgeOnline/problem.php?id=1232)

**题解**

发现USACO的题目质量好高啊。

首先容易发现，在移除多余的边后得到的是一株树。而无论从那个顶点出发遍历整颗树的最短距离为$2\sum_{e\in E}e.w$，即边权之和的两倍。这很容易理解，遍历以某个顶点为根的子树，我们需要依次遍历每个子结点为根的子树，这和深度优先搜索实际上是相同的实现。而每次我们从根下降访问子树，而访问完子树后需要原路返回，因此每条边都会被经历两次。

但是这距离我们最终结果还相距甚远，因为不仅边有权，点也有对应的权。如果点没有权的话这个问题实际上就是算最小生成树而已。

观察树，对于任意一个顶点u，如果顶点的度为d，那么这个顶点在遍历的整个过程中至少会被访问d次。一条边与父节点连接，这里会访问一次u，之后每次从u的子节点搜索返回，都会访问u一次。根结点比较特殊，因此一开始就位于根结点，因此根节点的访问次数会比它的度额外多1。

因此如果树选取好了，我们简单记作$T=(V,E')$。可以推出最小的要花的时间为：


$$
root.w + \sum_{u\in V}u.w\cdot u.d + \sum_{(u,v)\in E'}(u,v).w\cdot2
$$


因此我们实际上要做的是选取一株树，使得上面式子最小。我们可以将上面公式进行改写：


$$
root.w + \sum_{(u,v)\in E'}((u,v).w\cdot 2+u.w+v.w)
$$


由于root的选择仅影响上面式子中$root.w$这一部分，因此我们始终选择权最小的顶点作为根。而右边和式中，如果我们定义每个边的修正权为$(u,v).w'=(u,v).w\cdot 2+u.w+v.w$，和式就变成了：


$$
\sum_{(u,v)\in E'}(u,v).w'
$$


要使该式最小，只需要基于修正后的边权，生成最小生成树就可以了。

# BZOJ1977

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1977](https://www.lydsy.com/JudgeOnline/problem.php?id=1977)

**题解**

严格最小生成树。看别人博客说是严格次小生成树能和最小生成树只差一条边，我并不知道怎么证明。先记录一下吧。

我们需要维护路径上的最大权边和次大权边，这个用动态树就好了，时间复杂度$O(n\log_2n)$。

# BZOJ3699

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=3699](https://www.lydsy.com/JudgeOnline/problem.php?id=3699)

**题解**

好题。可以脑补一个网格图，左下角网格坐标为(0,0)，横坐标为a，纵坐标为b。之后将所有边按照其a、b分配到网格中。

对于每一个i，我们试图找到最小的一个数j，使得仅使用那些属性a不超过i，属性b不超过j的边，可以保证顶点1和n连通。我们记$f(i)=j$，容易发现f是一个递减函数。

因此，我们可以先从点(-1,50000)出发，之后，不断向右或向下移动一步。可以证明最多移动2L步，L是精灵数要求的上限，这里是50000。

在整个流程中，每条边最多加入图一次，最多被移除一次，因此加入和删除操作会分别发生最多m次。而每次一定后都要重新判断顶点1和n是否连通，即需要查询连通2L次。

可以发现，b越大的边越早被删除。我们以b作为删除时间，那么问题就转换为如何在线维护一副图，图中边有自己的删除时间，要求查询各个时间下的连通性。

这个可以通过动态树实现，我们用动态树维护图的一个生成树。当我们加入一条边时，如果边的两个顶点不连通，这代表加入边后图依旧是森林，即没有环存在。如果边的两个端点连通，那么找到两个端点之间的唯一路径，判断路径上删除时间最小的边，如果该边的删除时间早于我们要加入的边，那么我们可以用新边替换该条边，否则不处理。我们可以保证任意时刻，如果两个顶点在动态树中不连通，那么没有加入动态树的边一定被过期删除了，因此即使这些边加入图中，此时依旧不连通。当然如果连通自然是确实连通的。而用这种方法，并不需要真的执行删除操作，要判断两个顶点连通，只需要判断两条边之间删除时间最早的边是否以及过期。

# LOJ136

**题意**

[https://loj.ac/problem/136](https://loj.ac/problem/136)

**题解**

最小瓶颈路。做法比较简单，我们维护一个图，初始时没有边加入。之后按边的权重不断将边加入，如果因为边的加入导致两个顶点连通，那么这两个顶点在图中的最小瓶颈路的最大权边一定为该边。

这里可以将每个请求关联到两个端点，之后用并查集维护连通性。如果要合并两个连通块，需要将请求合并，合并之前还需要检查请求。这里可以利用启发式合并的思路，保证合并和检查仅发生$q\log_2q$次。总的时间复杂度是$O(m\log_2m+q\log_2q+n)$，空间复杂度为$O(n+m+q\log_2q)$。

# BZOJ1016

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1016](https://www.lydsy.com/JudgeOnline/problem.php?id=1016)

**题解**

按理来说，这道题是不可做的。但是由于相同权值的边数被限制在了10条，因此就有了一种暴力枚举的做法。

首先观察Kruskal的流程，我们可以发现，当我们交换相同权重的边的处理顺序时，才有可能获得新的生成树。因此我们可以将边按照权重分组，从小到大处理。

一种方案是枚举所有边的排列，但是这样的时间复杂度为$10!$，略大。还有一种方案是，我们枚举每条边是否出现在最终的生成树中，这样的时间复杂度为$2^{10}$，是可以接受的。用可撤销的并查集维护构建的生成树，并统计结果数。

这道题的图不一定连通，要小心。

# BZOJ2901

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2901](https://www.lydsy.com/JudgeOnline/problem.php?id=2901)

**题解**

K短路。但是题目中的路径是不允许过重复点的，但是题意中已经给出只能从高处到低处，因此路径上一定不会有重复点。

K短路可以用A star算法求解，空间复杂度为$O(kE)$，时间复杂度为$O(kE\log_2kE)$。

# BZOJ2429

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2429](https://www.lydsy.com/JudgeOnline/problem.php?id=2429)

**题解**

最小生成树或二分。时间复杂度为$O(nlog_2n)$。

# BZOJ1196

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1196](https://www.lydsy.com/JudgeOnline/problem.php?id=1196)

**题解**

可以如果发现在费用上界设为x时有方案，那么设为任意大于x的值也是有方案的。于是可以用二分，二分费用上界。

之后我们用贪心的方式尽可能多用不超过上界的一级道路。之后如果图还不连通，就用二级道路。最后校验是否用够了k条一级道路，以及最后图是否连通。

# BZOJ1715

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1715](https://www.lydsy.com/JudgeOnline/problem.php?id=1715)

**题解**

搜负环的模板题。用Spfa，递归版有奇效。

# BZOJ1050

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1050](https://www.lydsy.com/JudgeOnline/problem.php?id=1050)

**题解**

假如要求最小边的权一定为x，那么我们可以只考虑边权大于等于x的边，按边权从小到大加入到图中，直到s、t连通。这时候最大边的边权为y，则y/x为要求的最小比值。这里是一个贪心的做法。

我们可以枚举最终解中的最小边，提前排序边集，总共有$M$种可能。利用滑动窗口的技巧，我们不必在每次考虑新的最小边的时候重建整个图。这意味着我们只需要做$M$次加边、删边、判连通操作。

我们注意到后加的边一定后删，因此我们可以用LCT判连通。当新的边加入后会成环，那么就剔除环中最早加入的边即可。这样保证连通性检测时的结果不会变动，同时只处理树形结构。

总的时间复杂度为$O(Mlog(N+M))$。

# BZOJ1093

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1093](https://www.lydsy.com/JudgeOnline/problem.php?id=1093)

**题解**

首先我们可以对图中的环进行缩小点，一个点的点权表示该点由多少点缩点而来。我们希望找到一个最大的半连通图，点权和最大。缩完点后的图是有向无环图。

假设G=(V,E)为我们找到的最大半连通图，观察它满足的性质。首先G一定是有向无环连通图，同时我们一定可以找到一个唯一的顶点v，其入度为0（否则假如找到两个点u、v入度都为0，这意味着u、v之间不存在一条路径，这与G是半连通图相悖）。在移除v后得到的图还是半连通图。我们不断重复移除的过程得到了一个顶点序列$v_1,v_2,\ldots ,v_n$。我们可以保证它们构成一条路径。而一条路径一定是半连通图。因此我们得知一个图是半连通图当且仅当它的所有顶点序列可以构成一条路径。

故，我们实际上要找到的是图中的一个最大权路径，在DAG中，我们可以在顶点的拓扑序上使用动态规划技术得到。

# Codeforces1205D

**题意**

[https://codeforces.com/problemset/problem/1205/D](https://codeforces.com/problemset/problem/1205/D)

**题解**

如果我们为根结点赋予权重0，并且为其余结点均赋予不小于父结点权重的权重。那么我们可以通过差分得到连接父子结点的边的权重，并且权重非负。现在考虑要为一株树上的n个顶点赋予一组权重，我们可以遍历整棵树，按照遍历的顺序从小到大赋予权重，这样进行差分后得到的边的权重均非负，且从根结点到树中任意顶点v的路径总权等于v的顶点权重。

考虑星图，我们认为根结点下挂n-1个顶点。我们任意选择一个C，满足$n/3\leq C \leq 2n/3$。并为前C个子结点赋予权重$1,2,\ldots, C$，而后面的$n-C-1$个子结点赋予权重$(C+1),2(C+1),\ldots, (n-C-1)(C+1)$，这样利用前C个顶点和后n-C-1个顶点我们就可以组合得到$\[1,2n^2/9\]$之间的所有值了。

考虑一般的树，我们找到树的重心，可知重心下最大子树的大小不超过$n/2$。我们可以排序重心下的子顶点，并贪心找到一组子树，使得总大小C落在区间$\[n/3,2n/3\]$中。之和，我们为这组子树中顶点赋予权重1~C，而其余子树中顶点赋予权重$(C+1),2(C+1),\ldots, (n-C-1)(C+1)$。

# BZOJ3786

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=3786](https://www.lydsy.com/JudgeOnline/problem.php?id=3786)

**题解**

首先有换父操作，因此我们需要用到动态树。Link-Cut-Tree适合处理路径问题，但是题目中要求支持子树增强权重的操作。

考虑另外一个动态树实现Euler-Tour-Tree。我们利用DFS可以将树转换为括号序列，并用平衡树维护序列。这样将以x为根的子树移除出树，等价于将x的开闭括号从序列中删除。而将以x为根的子树连接到y下，等价于找到y的闭括号，并将x对应的括号序列加到y的闭括号之前。

之后查找x到根所有顶点的权重之和，可以用一种特殊的技巧统计路径信息。我们在遇到开括号时，执行加操作，在遇到闭括号时执行减操作。这样只需要统计根的开括号到x的开括号这段序列的权和即可。

# 参考文献

- [最小生成树的一些性质和理解](<https://blog.csdn.net/zengchen__acmer/article/details/17323245>)
- [斯坦福课件](http://web.stanford.edu/class/archive/cs/cs166/cs166.1146/lectures/05/Slides05.pdf)
- [https://pdfs.semanticscholar.org/a35c/cea03eb856b6f13908d8db78aeef47bc6819.pdf](https://pdfs.semanticscholar.org/a35c/cea03eb856b6f13908d8db78aeef47bc6819.pdf)