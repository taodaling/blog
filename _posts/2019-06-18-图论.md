---
categories: algorithm
layout: post
---

- Table
{:toc}
# 最小生成树

一个无向连通图的生成树是指该图的一个连通无环子图。而最小生成树就是所有生成树中总边权最小的。

因为之后的分析要用到最小生成树的一些性质，因此这里详细介绍下。

## prim和kruskal

最小生成树的求法不外乎两种，prim和kruskal。两个都是贪心算法，正确性基于最小生成树类似的性质。

随意取一个顶点u，记所有与u关联的最小权边为$e=(u,v)$，其中$u\neq v$。现在我们证明e一定属于一株最小生成树，用反证法。假设最小生成树T中不包含e。我们知道e是与u关联的最小边，因此可以将e加入到T中，这样就会出现一个包含点u的环。删除环上与u相连的另外一条边e'，得到了一株新的树T'，而T'的总权不可能大于T（加入e删除了e'，e的权重小于等于e')，因此weight(T')<=weight(T)。这样我们就得到了包含e的一株最小生成树。

由这个观察我们可以推出贪心的流程。

1. 创建一个空集T。

2. 任意取一个顶点u，找到与该顶点u相关联的最小权重边e=(u,v)，满足$u\neq v$，从点集V中删除u、v，并将e加入到空集T中，之后合并顶点u、v，将合并后的顶点加入到V中。
3. 如果V中只剩一个顶点了，那么就结束，此时T就是最小生成树。否则回到步骤2。

上面这个流程就是prim算法。由于并不限制步骤2的u的选择，因此你可以总是选择顶点1以及包含顶点1的合并顶点，这样整个流程就完全等价于dijkstra算法了，用最小堆优化后得到的时间复杂度为$O(\min((V+E)\log_2V, V^2))$。

prim算法是通过点去找边，也可以通过边去找点，下面的算法就是如此：

1. 创建一个空集T。
2. 从边集E中弹出权重最小的边e=(u,v)，如果在生成树T中u、v不处于相同连通块，就将e加入T中，否则忽略e。
3. 如果E为空集，那么就结束，此时T就是最小生成树。否则回到步骤2。

上面这个流程就是kruskal算法，我们可以提前对E进行排序，并用路径压缩并查集维护连通块，这样时间复杂度为$O(E+E\log_2E)$。

## 最小瓶颈路

一条路径中，权重最大的边称为路的瓶颈，而从起点到终点的所有路径中瓶颈最小的路径称为最小瓶颈路。

对于两个不同的顶点i,j，记$f_{ij}(x)$表示只保留图中权重不超过x的边的前提下，顶点i与j是否连通（连通为1，不连通为false）。很显然这样的函数$f\_{ij}$一定是非严格递增函数。假设i、j之间的最小瓶颈路的瓶颈权重为t，那么$t$一定是$f\_{ij}$最小的能令其返回1的入参。

因此我们可以先对边集按照权重从小到大进行排序，之后按序将边的两个端点所在连通块合并为一个连通块。这个过程持续直到i和j处于相同的连通块中。

这个流程实际上和kruskal是如同的，因此我们可以相信最小生成树中的任意两个端点i、j之间的唯一路径就是图上的最小瓶颈路。

## 求所有最小生成树的并集

给定一张无向连通图，求其所有最小生成树的并集。

有两种方法。

第一种方法，就是先任意构建一个最小生成树，显然最小生成树中的所有边都要被包含进去。考虑任意未被包含进最小生成树的边$e=(a,b)$，其连通两个顶点，考虑最小生成树中从a到b的唯一路径上权重最大的边$e'$，由于最小生成树具有最小瓶颈路的性质，因此$e'$的权重不可能大于$e$。如果$e'$的权重恰好等于$e$，那么我们可以从最小生成树中删除边$e'$并加入$e$来获取一颗新的最小生成树。

上面的总的时间复杂度为$O((n+m)\log_2n)$，路径操作可以用LCT实现。

第二种方法是，考虑kruskal算法，我们将边集按照边的权重进行分组，第i组就是所有权重为i的边组成的集合。注意到我们可以通过变换同组边之间的处理顺序得到所有的最小生成树。我们可以证明不管如何打乱同一组边的处理顺序，在处理完第i组的边后，所有的连通关系都是相同的，即在一种顺序下两个顶点是连通的，那么在另外一种处理顺序下亦然。这个可以利用归纳法进行证明，假设处理完前i-1类边后连通关系相同。那么考虑以任意顺序处理第i类边，如果第i组边中所有边最后都被加入最小生成树，那么连通关系肯定相同。如果不是所有边被加入，那么考虑任意一个未被加入的边$(a,b)$，那么我们可以断定a和b一定连通（否则我们可以将$(a,b)$纳入最小生成树中）。因此当我们处理完前i类边后，对于任意前i类边$(u,v)$，$(u,v)$一定是连通的。

而一条边是否有机会组成最小生成树，假设边的权重为k，那么我们只要观察，在处理完前$k-1$类边后，这条边的两个端点是否连通即可。第二种方法的时间复杂度也是$O((n+m)\log_2n)$，但是这边不需要用到LCT，只需要用到并查集即可。

## 求最小生成树的数目

最小生成树的数目可以通过kruskal算法求出。在求所有最小生成树的并集这一节中，已经说过了所有kruskal算法流程中，可以通过变换边的处理顺序得到所有的最小生成树。事实上，对于固定的图，要得到最小生成树，其中所有权重为i的边选取的数量也是固定的（和边的处理顺序无关）。假设最小生成树中权重为$i$的边共选择了$c_i$个，那么我们在处理第$i$类边的时候，可以暴力枚举选取$c_i$条边的，情况，去除其中成环的情况。不同权重的边可以独立处理。

# Euler Tour Tree

Euler Tour Tree也是动态树，支持$O(\log_2n)$的换根，加边，删边操作。类似于Link-Cut-Tree，但是底层原理是将树表示为DFS序，并将DFS序放到平衡树上去维护。

要了解更多，可以去阅读斯坦福大学的课件，地址如下：

[http://web.stanford.edu/class/archive/cs/cs166/cs166.1146/lectures/05/Slides05.pdf](http://web.stanford.edu/class/archive/cs/cs166/cs166.1146/lectures/05/Slides05.pdf)

Euler Tour Tree和Link Cut Tree的区别在于，后者是以Splay森林保存信息，每个森林中的树都代表一条树上的路径，因此Link Cut Tree非常适合用于处理路径问题。而前者是以一株平衡树进行维护的，因此可以很好的利用树的一些性质，比如处理子树问题。

# 连通性检测

对于一个含有n个顶点的无向图，一开始边集为空。你需要处理m个请求，请求内容为下面三类：

1. 增加一条边
2. 删除一条边
3. 判断两个顶点是否处于相同相同的连通块中

## 离线做法

如果题目可以允许我们离线，我们可以用Link-Cut-Tree轻松解决这个问题。按序处理请求：

1. 假设要加的边为e=(u,v)，我们先检查后面第一个删除边e的类型三请求出现的序号，记作t，将e的寿命设为t。假如此时u和v不连通，那么就直接插入e，用e将u和v连通。否则，我们判断u和v所在路径中寿命最短的边z，判断z的寿命是否小于e的寿命，如果小于，删除z加入e，否则忽略e。
2. 不处理。
3. 假设要处理的顶点对为u、v。先判断u、v是否连通，不连通，则必定不连通。如果连通，就判断u、v之间路径上寿命最短的顶点z，如果z的寿命小于当前请求的序号，则不连通，否则连通。

利用离线做法，我们每次请求都变成了常数次LCT操作，总的时间复杂度为$O((n+m)\log_2n)$。

## 在线做法

如果问题强制要求我们在线，那么就需要使用euler tour tree来解决问题。

首先我们将边分成$L=\log_2n$层。对于边e，记Level(e)表示e所在图的层级，边的层级只降不升。同时建立L个图$G_i$，其中$G_i$包含所有n个顶点和所有层级不超过i的边，我们维护它的最小生成树$F_i$，每个边的权重就是它们所在的级别。我们需要维护两个不变的性质：

1. $G_i$中的连通块大小不会超过$2^i$
2. $F_i=F_L \cap G_i$。

维护一个集合E用来保存所有的加入后没有删除的边的信息。接下来按先后顺序处理所有请求：

1. 设新增的边为e=(u,v)，将e加入E，将Level(e)设为L。之后检查$F_L$中u、v是否连通，如果不连通就向$F_L$插入e，否则忽略。

2. 设删除的边为e=(u,v)，先从集合E中删除e。首先如果e不出现在$F_L$中，那么流程直接结束，因为不会影响到连通性。下面考虑e出现在$F_L$中的情况：

   - for i = Level(e) -> L:

     - 从$F_i$中删除e
- 删除了e并不能保证u、v就不连通了，因为可能存在替换边，我们可以保证假如替换边存在，那么替换边的级别至少是Level(e)，（由最小生成树性质得到）
   - for i = Level(e) -> L:
     - 由于删除了边e，我们将原先u、v所在连通块切分为了两部分，分别记作$B_u$和$B_v$。这里加色和$B_u$的大小不超过$B_v$，考虑到$\|B_u\|+\|B_v\|\leq 2^i$，因此$\|B_u\| \leq 2^{i-1}$，因此我们可以将$B_u$中的全部级别为i的边下推到级别i-1中去
     - 下推$B_u$中的全部级别为i的边到级别i-1中去。
     - for (x, y) in E where Level((x,y))=i and x in $B_u$:
       - if x、y在$F_L$中处于相同的连通块中：
         - 将(u,v)的级别减少1
       - else:
         - 将$(u,v)$加入到$F_i,F_{i+1},\ldots, F_L$中去。并结束过程。

3. 假设要查询的顶点对位u,v，只需要判断在$F_L$中u、v是否在相同连通块中即可。



对于操作1，时间复杂度为$O(\log_2n)$。对于操作2，时间复杂度为$O((\log_2n)^2)$。由于每条边被下放最多$L$次，因此这部分的时间复杂度为$O(m(\log_2n)^2)$。总的时间复杂度为$O(m(\log_2n)^2)$。

# BZOJ1232

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1232](https://www.lydsy.com/JudgeOnline/problem.php?id=1232)

**题解**

发现USACO的题目质量好高啊。

首先容易发现，在移除多余的边后得到的是一株树。而无论从那个顶点出发遍历整颗树的最短距离为$2\sum_{e\in E}e.w$，即边权之和的两倍。这很容易理解，遍历以某个顶点为根的子树，我们需要依次遍历每个子结点为根的子树，这和深度优先搜索实际上是相同的实现。而每次我们从根下降访问子树，而访问完子树后需要原路返回，因此每条边都会被经历两次。

但是这距离我们最终结果还相距甚远，因为不仅边有权，点也有对应的权。如果点没有权的话这个问题实际上就是算最小生成树而已。

观察树，对于任意一个顶点u，如果顶点的度为d，那么这个顶点在遍历的整个过程中至少会被访问d次。一条边与父节点连接，这里会访问一次u，之后每次从u的子节点搜索返回，都会访问u一次。根结点比较特殊，因此一开始就位于根结点，因此根节点的访问次数会比它的度额外多1。

因此如果树选取好了，我们简单记作$T=(V,E')$。可以推出最小的要花的时间为：


$$
root.w + \sum_{u\in V}u.w\cdot u.d + \sum_{(u,v)\in E'}(u,v).w\cdot2
$$


因此我们实际上要做的是选取一株树，使得上面式子最小。我们可以将上面公式进行改写：


$$
root.w + \sum_{(u,v)\in E'}((u,v).w\cdot 2+u.w+v.w)
$$


由于root的选择仅影响上面式子中$root.w$这一部分，因此我们始终选择权最小的顶点作为根。而右边和式中，如果我们定义每个边的修正权为$(u,v).w'=(u,v).w\cdot 2+u.w+v.w$，和式就变成了：


$$
\sum_{(u,v)\in E'}(u,v).w'
$$


要使该式最小，只需要基于修正后的边权，生成最小生成树就可以了。

# BZOJ1977

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1977](https://www.lydsy.com/JudgeOnline/problem.php?id=1977)

**题解**

严格最小生成树。看别人博客说是严格次小生成树能和最小生成树只差一条边，我并不知道怎么证明。先记录一下吧。

我们需要维护路径上的最大权边和次大权边，这个用动态树就好了，时间复杂度$O(n\log_2n)$。

# BZOJ3699

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=3699](https://www.lydsy.com/JudgeOnline/problem.php?id=3699)

**题解**

好题。可以脑补一个网格图，左下角网格坐标为(0,0)，横坐标为a，纵坐标为b。之后将所有边按照其a、b分配到网格中。

对于每一个i，我们试图找到最小的一个数j，使得仅使用那些属性a不超过i，属性b不超过j的边，可以保证顶点1和n连通。我们记$f(i)=j$，容易发现f是一个递减函数。

因此，我们可以先从点(-1,50000)出发，之后，不断向右或向下移动一步。可以证明最多移动2L步，L是精灵数要求的上限，这里是50000。

在整个流程中，每条边最多加入图一次，最多被移除一次，因此加入和删除操作会分别发生最多m次。而每次一定后都要重新判断顶点1和n是否连通，即需要查询连通2L次。

可以发现，b越大的边越早被删除。我们以b作为删除时间，那么问题就转换为如何在线维护一副图，图中边有自己的删除时间，要求查询各个时间下的连通性。

这个可以通过动态树实现，我们用动态树维护图的一个生成树。当我们加入一条边时，如果边的两个顶点不连通，这代表加入边后图依旧是森林，即没有环存在。如果边的两个端点连通，那么找到两个端点之间的唯一路径，判断路径上删除时间最小的边，如果该边的删除时间早于我们要加入的边，那么我们可以用新边替换该条边，否则不处理。我们可以保证任意时刻，如果两个顶点在动态树中不连通，那么没有加入动态树的边一定被过期删除了，因此即使这些边加入图中，此时依旧不连通。当然如果连通自然是确实连通的。而用这种方法，并不需要真的执行删除操作，要判断两个顶点连通，只需要判断两条边之间删除时间最早的边是否以及过期。

# LOJ136

**题意**

[https://loj.ac/problem/136](https://loj.ac/problem/136)

**题解**

最小瓶颈路。做法比较简单，我们维护一个图，初始时没有边加入。之后按边的权重不断将边加入，如果因为边的加入导致两个顶点连通，那么这两个顶点在图中的最小瓶颈路的最大权边一定为该边。

这里可以将每个请求关联到两个端点，之后用并查集维护连通性。如果要合并两个连通块，需要将请求合并，合并之前还需要检查请求。这里可以利用启发式合并的思路，保证合并和检查仅发生$q\log_2q$次。总的时间复杂度是$O(m\log_2m+q\log_2q+n)$，空间复杂度为$O(n+m+q\log_2q)$。

# BZOJ1016

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1016](https://www.lydsy.com/JudgeOnline/problem.php?id=1016)

**题解**

按理来说，这道题是不可做的。但是由于相同权值的边数被限制在了10条，因此就有了一种暴力枚举的做法。

首先观察Kruskal的流程，我们可以发现，当我们交换相同权重的边的处理顺序时，才有可能获得新的生成树。因此我们可以将边按照权重分组，从小到大处理。

一种方案是枚举所有边的排列，但是这样的时间复杂度为$10!$，略大。还有一种方案是，我们枚举每条边是否出现在最终的生成树中，这样的时间复杂度为$2^{10}$，是可以接受的。用可撤销的并查集维护构建的生成树，并统计结果数。

这道题的图不一定连通，要小心。

# BZOJ2901

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2901](https://www.lydsy.com/JudgeOnline/problem.php?id=2901)

**题解**

K短路。但是题目中的路径是不允许过重复点的，但是题意中已经给出只能从高处到低处，因此路径上一定不会有重复点。

K短路可以用A star算法求解，空间复杂度为$O(kE)$，时间复杂度为$O(kE\log_2kE)$。

# BZOJ2429

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2429](https://www.lydsy.com/JudgeOnline/problem.php?id=2429)

**题解**

最小生成树或二分。时间复杂度为$O(nlog_2n)$。

# BZOJ1196

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1196](https://www.lydsy.com/JudgeOnline/problem.php?id=1196)

**题解**

可以如果发现在费用上界设为x时有方案，那么设为任意大于x的值也是有方案的。于是可以用二分，二分费用上界。

之后我们用贪心的方式尽可能多用不超过上界的一级道路。之后如果图还不连通，就用二级道路。最后校验是否用够了k条一级道路，以及最后图是否连通。

# BZOJ1715

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1715](https://www.lydsy.com/JudgeOnline/problem.php?id=1715)

**题解**

搜负环的模板题。用Spfa，递归版有奇效。

# BZOJ1050

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1050](https://www.lydsy.com/JudgeOnline/problem.php?id=1050)

**题解**

假如要求最小边的权一定为x，那么我们可以只考虑边权大于等于x的边，按边权从小到大加入到图中，直到s、t连通。这时候最大边的边权为y，则y/x为要求的最小比值。这里是一个贪心的做法。

我们可以枚举最终解中的最小边，提前排序边集，总共有$M$种可能。利用滑动窗口的技巧，我们不必在每次考虑新的最小边的时候重建整个图。这意味着我们只需要做$M$次加边、删边、判连通操作。

我们注意到后加的边一定后删，因此我们可以用LCT判连通。当新的边加入后会成环，那么就剔除环中最早加入的边即可。这样保证连通性检测时的结果不会变动，同时只处理树形结构。

总的时间复杂度为$O(Mlog(N+M))$。

# BZOJ1093

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1093](https://www.lydsy.com/JudgeOnline/problem.php?id=1093)

**题解**

首先我们可以对图中的环进行缩小点，一个点的点权表示该点由多少点缩点而来。我们希望找到一个最大的半连通图，点权和最大。缩完点后的图是有向无环图。

假设G=(V,E)为我们找到的最大半连通图，观察它满足的性质。首先G一定是有向无环连通图，同时我们一定可以找到一个唯一的顶点v，其入度为0（否则假如找到两个点u、v入度都为0，这意味着u、v之间不存在一条路径，这与G是半连通图相悖）。在移除v后得到的图还是半连通图。我们不断重复移除的过程得到了一个顶点序列$v_1,v_2,\ldots ,v_n$。我们可以保证它们构成一条路径。而一条路径一定是半连通图。因此我们得知一个图是半连通图当且仅当它的所有顶点序列可以构成一条路径。

故，我们实际上要找到的是图中的一个最大权路径，在DAG中，我们可以在顶点的拓扑序上使用动态规划技术得到。

# Codeforces1205D

**题意**

[https://codeforces.com/problemset/problem/1205/D](https://codeforces.com/problemset/problem/1205/D)

**题解**

如果我们为根结点赋予权重0，并且为其余结点均赋予不小于父结点权重的权重。那么我们可以通过差分得到连接父子结点的边的权重，并且权重非负。现在考虑要为一株树上的n个顶点赋予一组权重，我们可以遍历整棵树，按照遍历的顺序从小到大赋予权重，这样进行差分后得到的边的权重均非负，且从根结点到树中任意顶点v的路径总权等于v的顶点权重。

考虑星图，我们认为根结点下挂n-1个顶点。我们任意选择一个C，满足$n/3\leq C \leq 2n/3$。并为前C个子结点赋予权重$1,2,\ldots, C$，而后面的$n-C-1$个子结点赋予权重$(C+1),2(C+1),\ldots, (n-C-1)(C+1)$，这样利用前C个顶点和后n-C-1个顶点我们就可以组合得到$\[1,2n^2/9\]$之间的所有值了。

考虑一般的树，我们找到树的重心，可知重心下最大子树的大小不超过$n/2$。我们可以排序重心下的子顶点，并贪心找到一组子树，使得总大小C落在区间$\[n/3,2n/3\]$中。之和，我们为这组子树中顶点赋予权重1~C，而其余子树中顶点赋予权重$(C+1),2(C+1),\ldots, (n-C-1)(C+1)$。

# BZOJ3786

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=3786](https://www.lydsy.com/JudgeOnline/problem.php?id=3786)

**题解**

首先有换父操作，因此我们需要用到动态树。Link-Cut-Tree适合处理路径问题，但是题目中要求支持子树增强权重的操作。

考虑另外一个动态树实现Euler-Tour-Tree。我们利用DFS可以将树转换为括号序列，并用平衡树维护序列。这样将以x为根的子树移除出树，等价于将x的开闭括号从序列中删除。而将以x为根的子树连接到y下，等价于找到y的闭括号，并将x对应的括号序列加到y的闭括号之前。

之后查找x到根所有顶点的权重之和，可以用一种特殊的技巧统计路径信息。我们在遇到开括号时，执行加操作，在遇到闭括号时执行减操作。这样只需要统计根的开括号到x的开括号这段序列的权和即可。

# Codeforces1209F

**题意**

[https://codeforces.com/contest/1209/problem/F](https://codeforces.com/contest/1209/problem/F)

**题解**

我的做法和题解的不太一样。

首先观察问题，假设1到x的最短路径为1,..,y, x，那么x的数值则是在y的数值的尾部添加若干数字得到，即x的数值一定大于y的数值。我们发现这个性质有点类似于最短路问题，且在这种意义上，我们可以推出边权是非负的。这样我们就可以堂而皇之地使用Dijkstra算法解决它。

首先我们解决一个问题，如果进行比较操作，即如何判断离1所在连通块最近的顶点。

我们可以用一株前缀树维护所有顶点的最短距离，这样每个顶点所在的最短距离就是前缀树的某个顶点。这里我们需要使用动态开点技术，由于每条边最多建立$\log_2m$个前缀树顶点，因此前缀树的大小是$O(m\log_2m)$的。

之后如果比较两个顶点与1所在连通块的距离，我们知道距离已经被我们映射为了前缀树的顶点。因此就是比较两个顶点所代表的数值的大小。

由于边没有前置0，那么深度不同的顶点的大小，可以完全通过深度进行判断，深度较小的顶点代表的数值一定较小。

之后如何判断深度相同的顶点呢，我们必须找到两者的LCA。而要在一个动态加点的前缀树上找LCA，最简单的方式就是倍增技术，为每个顶点维护一个大小为20的数组bl，其中$bl[i]$表示距离当前顶点$2^i$的祖先顶点。这样判断操作就可以在$O(20)$时间内得到。

考虑总的时间复杂度，由于比较会发生$O((n+m)\log_2n)$次，因此总的时间复杂度为$O(20(n+m)\log_2n)$，是可以通过的。

# Atcoder jsc2019_qual_d

**题意**

[https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_d](https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_d)

**题解**

一个图，如果所有的环都是偶数长度当且仅当该图是二分图。

首先说方案，对于n，我们将其分为n层。如果两个顶点的标号i、j第一个不同的二进制位为第k位，那么边(i,j)属于第k类。由于第k个图中的边的两侧端点的第k二进制位都不同，因此一定是二分图。由此证明了方案是正确的划分。

下面证明最少要划分为
$$
\lceil \log_2n \rceil
$$
层。

一个图能的边如果能够被分类为k类，那么我们称该图满足k分，满足k分的显然也能满足k+1分。下面我们证明一个命题：

**命题：能被k分的最大完全图包含$2^k$个顶点。**

证明：

归纳法证明。当k为0和1的时候命题显然成立。下面考虑已知命题在$k=x$时成立，那么考虑大小为$2^x+1$的完全图。我们知道它至少得被x分，那么它能被x分吗？假设它能被x分，我们知道每个层级都是将图划分为左右两部分，图中共$2^x+1$个顶点，因此任意层的二分图的至少一侧有$2^{x-1}+1$个顶点。考虑我们第x层二分图，我们设左边有不少于$2^{x-1}+1$个顶点，那么我们将左边的顶点重新标号为$1,2,\ldots, 2^{x-1}+1$，接下来将其余所有顶点删除，这就转换成了大小为$2^{x-1}+1$的图的一个分类。考虑到第x层图只有左侧顶点，即没有边的存在，因此不需要第x层图。即我们证明了大小为$2^{x-1}+1$的图能被$x-1$分。但是由归纳法知道，这是不可能的。

至此，命题证明完毕。


# Floyd-Warshall算法

FW算法可以用于计算图中每个点对的最短距离。这个算法相较Dijkstra算法来说会简单一些，但是如果你会Dijkstra算法，那你应该知道计算单源最短路径的时间复杂度为O(min(V^2, (V+E)logV))，实际上将每个顶点作为源头跑一遍Dijkstra算法的时间复杂度是不逊色于FW算法的，因此非FW算法不可的场景几乎没有。FW算法和Dijkstra算法一样不适用于带负权边的图。

我们用动态规划来计算所有点对的最短距离。由于s与t的最短距离必定会对应至少一条最短路径s..t，而s..t中除了两个端点外序号最大的点记为M(s..t)，称为路径的最大点。利用函数M，我们可以将图中所有路径分类为n种，第i类路径，其最大点为i。

FW算法的原理就是按分类从小到大处理所有路径，并利用这些路径计算得到所有点对之间的最短距离。记D(i,j,k)表示所有从i到j的前k类路径中最短的路径长度。对于D(i,j,k+1)，很显然i与j之间的最短路要么是前k类路，要么就是第k+1类路。如果是第k+1类路，这条路中的最大点为k+1，将路以k+1为断点分裂为两条，i..k+1，k+1..j，很显然两条路都是前k类路。因此：


$$
D(i,j,k+1)=\min(D(i,j,k), D(i,k+1,k)+D(k+1,j,k))
$$

之后动态规划，O(n^3)可以解决。

```java
for(k = 1; k <= n; k++){
    for(i = 1; i <= n; i++){
        for(j = 1; j <= n; j++){
            D[i][j] = min(D[i][j], D[i][k]] + D[k][j]);
        }
    }
}
```

# 最小环算法

Floyd算法也可以用于解决最小环问题。所谓的最小环问题，是指在图中找到一个总边权最小的长度至少为3的简单环。

考虑最小环C，设C上编号最大的顶点为x，记x左右两边的顶点为u，v，C上边的总权重为c，那么必定有


$$
c=D(u,v,x-1)+D(v,x,x-1)+D(x,u,x-1)
$$


我们可以在Floyd流程套入计算最小环的过程。

```java
c = INF;
for(k = 1; k <= n; k++){
    for(i = 1; i <= n; i++){
        for(j = 1; j <= n; j++){
            if(i != j && edges[j][k] && edges[k][i]){
            	c = min(c, D[i][j]+D[j][k]+D[k][i]);
            }
        }
    }
    for(i = 1; i <= n; i++){
        for(j = 1; j <= n; j++){
            D[i][j] = min(D[i][j], D[i][k]] + D[k][j]);
        }
    }
}
```

# BZOJ1491

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1491](https://www.lydsy.com/JudgeOnline/problem.php?id=1491)

**题解**

Floyd+DP

# BZOJ1027

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1027](https://www.lydsy.com/JudgeOnline/problem.php?id=1027)

**题解**

由于a+b+c=1，因此若(a,b)一旦确定，那么c就随着确定。现在考虑两个点$(x_1,y_1),(x_2,y_2)$。对于$t\in [0,1]$，可以取到形如点$(x_1t+x_2(1-t), y_1t+y_2(1-t))$，这些点组成的实际是$(x_1,y_1)$与$(x_2,y_2)$之间的线段。之后继续加点，我们会得到凸多边形。

至此，我们知道了题目实际上的本意，将需求转换为二维平面上的点，我们要找到尽可能少的原料代表的点，使得这些点唯一确定的凸包能包含所有需求点。

一个点落于凸多边形中当且仅当这个点处于凸多边形的所有边的逆时针方向。

我们可以证明要寻找的n个原料点一定是凸包上的点，且由点数最少，可以推出边数最少。能够形成凸包的边一定满足所有顶点都落在凸包的逆时针方向。

我们将所有满足条件的边的边权设为1，不满足条件的边的边权设为无穷。那么可以得出最小环一定是最优解组成凸包上的边。

最小环可以通过FW算法得到。

# LUOGU2371

**题意**

[https://www.luogu.org/problem/P2371](https://www.luogu.org/problem/P2371)

**题解**

神奇的题目，很显然DP是不可能的，暴力也是不可能的。

真正的解法，是从$\{a_i\}$选取任意一个数，记作k。之后我们建立k个顶点，分别代表模k时余数为$0,1,\ldots,k-1$。

之后对于顶点$i$和数$a_j$，我们建立边$(i,(i+a_j)%k)$。之后我们寻找以顶点0为起点的单源最短路径。

对于数x，记$r=x%k$，如果顶点r距离顶点0的最短距离为d，那么根据d与x的大小关系，我们可以快速判断出是否能找到一组非负整数解$\{x_i\}$，使的$\sum_ia_ix_i=x$。如果$d<x$，不存在解，如果$d\geq x$，那么就有解。

# 欧拉迹

欧拉闭迹是指一条包含图中所有边的一条路径，每条边在路径中仅会出现一次，且路径的起点和终点是相同顶点。

一个无向图中包含欧拉闭迹，当且仅当下面两条性质同时满足：

- 图是连通的
- 图中每个顶点的度均为偶数

而一个有向图包含欧拉闭迹，当且仅当下面两条性质同时满足：

- 图是连通的
- 图中每个顶点入度和出度相同

欧拉开迹类似于欧拉闭迹，但是路径的起点和终点允许是不同的顶点。

我们可以发现欧拉开迹可以通过欧拉闭迹删除掉一条边后得到，因此我们也得到了判断欧拉开迹的条件。

一个无向图中包含欧拉开迹，当且仅当下面两条性质同时满足：

- 图是连通的
- 图中除了两个顶点外，其余每个顶点的度均为偶数

而一个有向图包含欧拉开迹，当且仅当下面两条性质同时满足：

- 图是连通的
- 图中除了两个顶点外（这两个顶点如果出度与入度不同，那么必定一个出度比入度少1，一个入度比出度少1），其余每个顶点入度和出度相同

Hierholzer算法用于在连通图寻找欧拉迹，其流程非常简单。

从一个可能的起点出发，进行深度优先搜索，但是每次沿着辅助边从某个顶点移动到另外一个顶点的时候，都需要删除这个辅助边。如果没有可移动的路径，则将所在结点加入到栈中，并返回。

```java
dfs(node, trace){
	while(!node.edges.isEmpty()){
		Node next = node.edges.removeLast();
		dfs(next, trace);
	}
	trace.addLast(node);
}
```

最后得到的栈中保存的就是整个欧拉闭迹中的顶点。

这个算法应用起来非常简单，下面我们先证明几条性质。

**性质1. 如果图中包含闭欧拉迹，则栈的底部存储的必定是起点。如果图中包含的是开欧拉轨迹，则栈底部存储的是与起点不同的另外一个奇度数端点。**

证明：当我们要入栈时，说明当前所在顶点没有任何边了。考虑到从起点出发到当前结点的路径中，除了起点和当前顶点外，所有的顶点都失去了偶数度数（在移除了途经的边后）。如果起点和当前顶点不同，那么两者都失去了奇数度数。如果图中包含闭欧拉迹，这意味着所有顶点的初始度数都是偶数，而当前顶点的剩余度数为0，表示当前顶点的初始度数必定是奇数，当然这是不可能的，因此假设不成立，当前顶点就是起点。同样的对于开欧拉迹，当前顶点不可能是起点，否则起点的度数就是偶数，而开欧拉迹中起点和终点的度数一定是奇数。这样就能推出当前顶点既不是起点度数也是偶数，因此一定是终点。



**性质2.如果图中包含闭欧拉迹，入栈的倒数第二个顶点一定是路径中的第二个顶点。**

证明：由于路径中的第二个顶点入栈，说明起点已经入栈过，换言之，起点已经没有多余的边了。

# 一类最小瓶颈路问题

**问题1：有无向图，有n个顶点，m条边。你从顶点1出发，去往顶点n。每条边上有一个机关，第i条边会使你损失$c_i$点血量。一旦你血量为负数，那么就会回到起点。每当你抵达一个顶点时，你的血量会完全恢复。问至少需要多少血量，才能保证你能顺利抵达顶点n。**

这个问题有比较简单的做法，二分血量，每次校验时，将所有伤害低于血量的边加入，之后判断顶点1和顶点n是否连通即可。时间复杂度为$O((n+m)\log_2m)$。

**问题2：有无向图，有n个顶点，m条边。每条边上有一个机关，第i条边会使你损失$c_i$点血量。一旦你血量为负数，那么就会回到起点。每当你抵达一个顶点时，你的血量会完全恢复。现在有Q个询问，每个询问指定一个起点和终点，问分别至少需要多少血量才能顺利从起点出发抵达终点。**

这个问题可以通过整体二分解决，总的时间复杂度为$O((m + q)\log_2n\log_2m)$。另外一种做法就是观察出对于起点是u，终点是v的时候，我们实际上要求的从$u$到$v$的最小瓶颈路，而已知最小生成树中每对顶点之间存在的唯一路径都是二者之间的最小瓶颈路，因此我们只需要找到最小生成树，之后用LCT维护整棵树，每个请求都可以以$O(log_2n)$的时间复杂度统计。

**问题3：有无向图，有n个顶点，m条边。每条边上有一个机关，第i条边会使你损失$c_i$点血量。一旦你血量为负数，那么就会回到起点。顶点分成两类，第一类顶点具有恢复生命的能力，第二类顶点则没有。现在有Q个询问，每个询问指定一个起点和终点（起点和终点都是第一类顶点），问分别至少需要多少血量才能顺利从起点出发抵达终点。**

首先为每个第二类顶点算出其距离最近的第一类顶点的最短距离（利用多源最短路算法）。之后记$d(u)$表示第二类顶点u到最近的第一类顶点的距离。之前我们判断一条边加不加入是靠边的伤害是否不高过血量，现在我们需要修改判断的标准，对于边$e_i=(a,b)$，当且仅当血量不低于$d(a)+d(b)+c_i$。之后问题转换为最小瓶颈路问题，用整体二分或者LCT都可以。

这边说明一下原因好了，假设血量上限为$x$。我们可以定义状态$(i,j)$表示位于顶点i上，并且有j滴血量。我们可以在图上进行搜索来判断是否可以从某个顶点移动到另外的顶点。如果i是第一类顶点，那么由于恢复的效果，因此$(i,x)$可以从$(i,j)$转移抵达，换言之，我们从$(i,j)$到$(i,x)$加上一条有向边。但是i是对于第二类顶点的情况，那么如果$j<d(i)$，那么很显然不能从$(i,j)$转移到血量更高的状态，这也意味着这些状态无法转移到任意顶点为终点的状态，我们可以直接无视这些状态。现在考虑$(i,j)$，其中$x-d(i)\geq j\geq d(i)$，那么我们可以先从这个顶点出发到达最近的第一类顶点之后再次回到当前顶点，从而血量提高到$x-d(i)$，因此我们从$(i,j)$向$(i,x-d(i))$连一条边。事实上，对于任意$(i,j)$，其中i是第二类点，$j>x-d(i)$，都是不可达的，因此我们也可以无视这些状态。

现在我们可以将上面提到的状态和转移进行压缩，我们可以认为顶点$i$对应的就是状态$(i,x-d(i))$（这是可达的并且可以通过后续转移抵达某个第一类顶点的最优状态）。现在我们考虑边$e_k=(a,b)$，我们是否可以从$(a,x-d(a))$转移到$(b,x-d(b))$呢，这要求我们经过边$e_k$从a到b后剩余的血量至少不少于$d(b)$，即$x-d(a)-c_k\geq d(b)\Rightarrow x\geq d(a)+d(b)+c_k$。这就是题解中公式的由来。

# CF1253F

**题意**

[https://codeforces.com/contest/1253/problem/F](https://codeforces.com/contest/1253/problem/F)

**题解**

一类最小瓶颈路问题，问题3。

# Erdos-Gallai定理与Havel–Hakimi算法

给定一个包含$n$个顶点的无向简单图（无重边），以及每个顶点的度$d_1,d_2,\ldots,d_n$，问是否存在这样的图，如果存在就构造出来。

如何判断图是否存在.首先有解的前提是度数之和为偶数且所有度数非负。

Erdos-Gallai定理给出了一种$O(n)$时间复杂度的检查方法。其命题如下：

假设度数从大到小排序，$d_1\geq d_2\geq \ldots \geq d_n$，那么如果对于所有$1\leq k\leq n$，下面公式都成立，那么就有解，否则无解。

$$
\sum_{i=1}^kd_i\leq k(k-1)+\sum_{i=k+1}^n\min(d_i,k)
$$

这个公式可以通过一些预先处理，在$O(n)$时间复杂度内计算完成。

那么现在知道有有没有解后，如何构造一组解呢。

很显然构造一组解的时间复杂度至少为$O(D)$，其中$D$是所有顶点的度数的和。我们可以用
Havel–Hakimi递归算法来实现。方法如下，我们将所有顶点按度数从小到大排序后，顶点$1$与$2,3,\ldots, d_1+1$建立一条边。之后我们递归解决剩下的包含$n-1$个顶点且度数分别为$d_2-1,d_3-1,\ldots, d_{d_1+1}-1, d_{d_1+2}, \ldots, d_n$的无向图构建问题。

Havel–Hakimi算法的总的时间复杂度为$O(n^2)$，排序可以选择将修改部分和未修改部分合并或基数排序。

# 参考文献

- [最小生成树的一些性质和理解](<https://blog.csdn.net/zengchen__acmer/article/details/17323245>)
- [斯坦福课件](http://web.stanford.edu/class/archive/cs/cs166/cs166.1146/lectures/05/Slides05.pdf)
- [https://pdfs.semanticscholar.org/a35c/cea03eb856b6f13908d8db78aeef47bc6819.pdf](https://pdfs.semanticscholar.org/a35c/cea03eb856b6f13908d8db78aeef47bc6819.pdf)
- [https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95](https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95)
- [https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93Gallai_theorem](https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93Gallai_theorem)
- [https://en.wikipedia.org/wiki/Havel%E2%80%93Hakimi_algorithm](https://en.wikipedia.org/wiki/Havel%E2%80%93Hakimi_algorithm)