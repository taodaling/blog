---
categories: algorithm
layout: post
---

- Table
{:toc}
# 最小生成树

一个无向连通图的生成树是指该图的一个连通无环子图。而最小生成树就是所有生成树中总边权最小的。

最小生成树的算法有prim和kruskal算法。这里只简单介绍kruskal算法，我们需要做的是对边集按边权从小到大排序，之后遍历处理所有边。如果边的两个端点未连通，那么就将边加入结果中。最后结果中的边就组成了最小生成树。

最小生成树有一些特殊的性质：

1. 最小生成树也是所有生成树中最大边的边权最小的生成树。
2. 最小生成树中任意两个不同端点u，v之间的唯一路径，正好是原无向连通图中u与v之间的最小瓶颈路。（最小瓶颈路是指路径上最大权边的权最小的路径）
3. 同一副图的两个最小生成树的所有边的边权从小到大排序的序列一定相同。
4. 所有生成树，将边权从小到大排成序列，那么最小生成树的边权序列的字典序一定最小。

# BZOJ1232

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1232](https://www.lydsy.com/JudgeOnline/problem.php?id=1232)

**题解**

发现USACO的题目质量好高啊。

首先容易发现，在移除多余的边后得到的是一株树。而无论从那个顶点出发遍历整颗树的最短距离为$2\sum_{e\in E}e.w$，即边权之和的两倍。这很容易理解，遍历以某个顶点为根的子树，我们需要依次遍历每个子结点为根的子树，这和深度优先搜索实际上是相同的实现。而每次我们从根下降访问子树，而访问完子树后需要原路返回，因此每条边都会被经历两次。

但是这距离我们最终结果还相距甚远，因为不仅边有权，点也有对应的权。如果点没有权的话这个问题实际上就是算最小生成树而已。

观察树，对于任意一个顶点u，如果顶点的度为d，那么这个顶点在遍历的整个过程中至少会被访问d次。一条边与父节点连接，这里会访问一次u，之后每次从u的子节点搜索返回，都会访问u一次。根结点比较特殊，因此一开始就位于根结点，因此根节点的访问次数会比它的度额外多1。

因此如果树选取好了，我们简单记作$T=(V,E')$。可以推出最小的要花的时间为：


$$
root.w + \sum_{u\in V}u.w\cdot u.d + \sum_{(u,v)\in E'}(u,v).w\cdot2
$$


因此我们实际上要做的是选取一株树，使得上面式子最小。我们可以将上面公式进行改写：


$$
root.w + \sum_{(u,v)\in E'}((u,v).w\cdot 2+u.w+v.w)
$$


由于root的选择仅影响上面式子中$root.w$这一部分，因此我们始终选择权最小的顶点作为根。而右边和式中，如果我们定义每个边的修正权为$(u,v).w'=(u,v).w\cdot 2+u.w+v.w$，和式就变成了：


$$
\sum_{(u,v)\in E'}(u,v).w'
$$


要使该式最小，只需要基于修正后的边权，生成最小生成树就可以了。

# BZOJ1977

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1977](https://www.lydsy.com/JudgeOnline/problem.php?id=1977)

**题解**

严格最小生成树。看别人博客说是严格次小生成树能和最小生成树只差一条边，我并不知道怎么证明。先记录一下吧。

我们需要维护路径上的最大权边和次大权边，这个用动态树就好了，时间复杂度$O(n\log_2n)$。

# BZOJ3699

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=3699](https://www.lydsy.com/JudgeOnline/problem.php?id=3699)

**题解**

好题。可以脑补一个网格图，左下角网格坐标为(0,0)，横坐标为a，纵坐标为b。之后将所有边按照其a、b分配到网格中。

对于每一个i，我们试图找到最小的一个数j，使得仅使用那些属性a不超过i，属性b不超过j的边，可以保证顶点1和n连通。我们记$f(i)=j$，容易发现f是一个递减函数。

因此，我们可以先从点(-1,50000)出发，之后，不断向右或向下移动一步。可以证明最多移动2L步，L是精灵数要求的上限，这里是50000。

在整个流程中，每条边最多加入图一次，最多被移除一次，因此加入和删除操作会分别发生最多m次。而每次一定后都要重新判断顶点1和n是否连通，即需要查询连通2L次。

可以发现，b越大的边越早被删除。我们以b作为删除时间，那么问题就转换为如何在线维护一副图，图中边有自己的删除时间，要求查询各个时间下的连通性。

这个可以通过动态树实现，我们用动态树维护图的一个生成树。当我们加入一条边时，如果边的两个顶点不连通，这代表加入边后图依旧是森林，即没有环存在。如果边的两个端点连通，那么找到两个端点之间的唯一路径，判断路径上删除时间最小的边，如果该边的删除时间早于我们要加入的边，那么我们可以用新边替换该条边，否则不处理。我们可以保证任意时刻，如果两个顶点在动态树中不连通，那么没有加入动态树的边一定被过期删除了，因此即使这些边加入图中，此时依旧不连通。当然如果连通自然是确实连通的。而用这种方法，并不需要真的执行删除操作，要判断两个顶点连通，只需要判断两条边之间删除时间最早的边是否以及过期。

# LOJ136

**题意**

[https://loj.ac/problem/136](https://loj.ac/problem/136)

**题解**

最小瓶颈路。做法比较简单，我们维护一个图，初始时没有边加入。之后按边的权重不断将边加入，如果因为边的加入导致两个顶点连通，那么这两个顶点在图中的最小瓶颈路的最大权边一定为该边。

这里可以将每个请求关联到两个端点，之后用并查集维护连通性。如果要合并两个连通块，需要将请求合并，合并之前还需要检查请求。这里可以利用启发式合并的思路，保证合并和检查仅发生$q\log_2q$次。总的时间复杂度是$O(m\log_2m+q\log_2q+n)$，空间复杂度为$O(n+m+q\log_2q)$。

# BZOJ1016

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1016](https://www.lydsy.com/JudgeOnline/problem.php?id=1016)

**题解**

按理来说，这道题是不可做的。但是由于相同权值的边数被限制在了10条，因此就有了一种暴力枚举的做法。

首先观察Kruskal的流程，我们可以发现，当我们交换相同权重的边的处理顺序时，才有可能获得新的生成树。因此我们可以将边按照权重分组，从小到大处理。

一种方案是枚举所有边的排列，但是这样的时间复杂度为$10!$，略大。还有一种方案是，我们枚举每条边是否出现在最终的生成树中，这样的时间复杂度为$2^{10}$，是可以接受的。用可撤销的并查集维护构建的生成树，并统计结果数。

这道题的图不一定连通，要小心。

# BZOJ2901

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2901](https://www.lydsy.com/JudgeOnline/problem.php?id=2901)

**题解**

K短路。但是题目中的路径是不允许过重复点的，但是题意中已经给出只能从高处到低处，因此路径上一定不会有重复点。

K短路可以用A star算法求解，空间复杂度为$O(kE)$，时间复杂度为$O(kE\log_2kE)$。

# BZOJ2429

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2429](https://www.lydsy.com/JudgeOnline/problem.php?id=2429)

**题解**

最小生成树或二分。时间复杂度为$O(nlog_2n)$。

# BZOJ1196

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1196](https://www.lydsy.com/JudgeOnline/problem.php?id=1196)

**题解**

可以如果发现在费用上界设为x时有方案，那么设为任意大于x的值也是有方案的。于是可以用二分，二分费用上界。

之后我们用贪心的方式尽可能多用不超过上界的一级道路。之后如果图还不连通，就用二级道路。最后校验是否用够了k条一级道路，以及最后图是否连通。

# BZOJ1715

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1715](https://www.lydsy.com/JudgeOnline/problem.php?id=1715)

**题解**

搜负环的模板题。用Spfa，递归版有奇效。

# 参考文献

- [最小生成树的一些性质和理解](<https://blog.csdn.net/zengchen__acmer/article/details/17323245>)