---
layout: post
categories: math
description:  今天晚上又翻开了算法导论，重新阅读了一下摊还分析章节...
---

 - 目录
{:toc}

# 简介

> 摊还分析用于求数据结构的一个操作序列中所执行的所有操作的平均时间，来评价操作的代价。

# 聚合分析

假设有一个n步骤的操作序列，其时间复杂度上界为T(n)，那么每个操作的平均时间复杂度上界为T(n)/n。

聚合分析实际上是先统计出n步骤操作序列的总时间复杂度上界，之后除去步骤数，从而得到一个可能比预估更好的平均时间复杂度。

引用算法导论中的例子：

> 假设有n个步骤：对于步骤i，如果i为2的幂，则i的时间费用为i，否则为1。

我们利用聚合分析来证明每个操作的摊还代价为O(1)。

显然T(n)是递增函数，那么我们可以始终假设n为2的幂。

```
T(n)=1+2+1*1+4+1*3+8+...+(n/2-1)*1+n<=2/2+2+4/2+4+8/2+8+...+n/2+n=(2+4+8+...+n)*(3/2)=(2n-2)*(3/2)=3(n-1)
```

因此：
```
T(n)/n=3(n-1)/n<=O(3)=O(1)
```
# 核算法

核算法为每个元素提供一个信用额度。在对数据结构做操作时由涉及到的元素的信用来支付操作费用。我们需要保证每个元素的预留信用非负。这样实际操作的总费用的上界为提供的信用之和。

继续解决上面这个问题：
我们每做一个操作，提供3的信用。3的信用中取出1用于支付该操作的实际费用。而对于任意为2的幂的特殊操作i，我们将之前加入的i/2+1～i共i/2个操作
的剩余费用全部提取出来用于支付该次操作的费用。

很显然每次操作的信用始终非负。而由于做了n个操作，故提供的总信用为3n。这样我们就能推出摊还费用为O(3n)/n=O(3)。

# 势能法

势能法可以认为是核算法的一个进阶版本，核算法仅仅着眼于数据结构的每个元素，而势能法则着眼于整个数据结构。势能法要求我们提供一个函数F:N->R，其中N为自然数集，R为实数集。F可以认为是计算数据结构势能的函数，F(i)表示前i次操作完成后数据结构的势能。而我们第i次操作的摊还费用`c'[i]=c[i]+F(i)-F(i-1)`，其中c\[i]为第i次操作的实际操作费用。

```
c'[1]+...+c'[n]=c[1]+F(1)-F(0)+...+c[n]+F(n)-F(n-1)=c[1]+...+c[n]+F(n)-F(0)
```

因此一旦我们能保证F(n)>=F(0)，那么我们得到的摊还费用之和是实际费用之和的一个上界，即 摊还费用是正确的。

继续考虑上面这个问题，我们定义$$ F\left( i \right) =i-2^{\lfloor \log _2i \rfloor} $$

那么对于一般的i，我们有:
```
c'[i]=c[i]+F(i)-F(i-1)=1+2(i-(i-1))=3
```
对于为2的幂的i，我们有：
```
c'[i]=c[i]+F(i)-F(i-1)=i+2(0-(i-1-i/2))=2
```
很显然F(n)>=0=F(0)，因此我们得出了一般操作的摊还费用为O(3)，而2的幂的操作的摊还费用为O(2)。

比较核算法和势能法的结果，容易发现核算法为不同的操作赋予相同的摊还费用，而势能法却可以为不同的操作赋予不同的摊还费用。一般势能法的功能会大大高于核算法，所以掌握势能法是非常重要的。
