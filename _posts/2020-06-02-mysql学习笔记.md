---
categories: technology
layout: post
---

- Table
{:toc}

# 安装配置

## 下载安装

去[官网](https://dev.mysql.com/downloads/)下载社区版本的MySQL软件

## 启动服务器

MySQL的服务器是`bin/mysqld`文件，启动它就好了。

## 登陆客户端

MySQL的bin目录下提供了客户端文件`mysql`，因此输入

```shell
$ mysql -u root -p
```

就可以以`root`的身份登陆。

## MySQL Workbench

### windows

去[官网](https://dev.mysql.com/downloads/workbench/)下载Windows安装包，安装完成后即可使用。


# 事务和并发

可以用`START TRANSACTION`开启事务，用`COMMIT`或`ROLLBACK`分别提交或回滚事务。

一个良好的事务处理系统，应该具有ACID四个特征：

- 原子性(A)：事务中的所有操作要么同时成功，要么同时失败。
- 一致性(C)：数据库仅从一个一致性的状态转移到另外一个一致性的状态。
- 隔离性(I)：一般来说，事务在提交之前，其修改对于其它事务是不可见的。但是这取决于你设置的隔离级别。
- 持久性(D)：一旦事务提交，则其所做的所有修改都会永久保存到数据库中。

## 隔离级别

隔离级别分成四种：

- READ UNCOMMITED（未提交读）： 事务的修改即使没有提交，对其它事务也是可见的。
- READ COMMITED（提交读）：事务直到提交后，其做的修改才对其它事务可见。但是这里会出现两次读结果不同的脏读问题。
- REPEATABLE READ（可重复读）：该级别保证同一个事务中多次读操作得到的结果是一致的。这个级别中可能会出现读取到其余事务提交后的插入的新行的幻读问题。
- SERIALIZABLE（可串行化）：强制事务串行执行，避免了幻读问题。

可以通过下面语句修改隔离级别：

```sql
show  variables like 'transaction_isolation'; #查看隔离级别
set [ global | session ] transaction isolation level Read uncommitted | Read committed | Repeatable | Serializable;
```

## 死锁问题

事务通过加锁来占用资源，但是如果两个事务以不同的顺序加锁，则可能会出现死锁问题。

死锁可以通过数据库系统实现死锁检测来解决，这种方法比较有效。还有一种解决方案就是获取锁时加上超时机制，如果超时了就回滚事务并释放锁，InnoDB目前让拥有最少拥有最少行级排他锁的事务回滚。

## 事务日志

事务日志可以提高事务的处理效率。存储引擎在修改数据的时候可以只修改内存中的拷贝，同时把修改行为记录到硬盘的事务日志中。由于日志是以追加的方式写入的，因此性能很高（顺序I/O不需要频繁移动磁头），之后内存中修改的数据可以慢慢刷回磁盘中。因此修改数据需要写两次磁盘。

由于日志的存在，即使是宕机，也可以恢复修改操作。

## 提交和回滚事务

MySQL默认使用自动提交模式，也就是说每一条SQL都被当成一个事务被执行提交。可以通过设置`AUTOCOMMIT`变量来改变提交模式：

```sql
SHOW VARIABLES LIKE 'AUTOCOMMIT';


+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+

SET AUTOCOMMIT = 1; #0表示禁用，1表示启用
```

需要注意当执行一些DDL语句的时候，会强制提交当前的事务。

由于事务是由存储引擎实现的，因此在同一个事务中同时使用多个存储引擎是不可靠的。

## 加锁

InnoDB采用两阶段锁定协议（two-phase locking protocol）。在事务执行的过程中，随时都可以执行锁定，锁只有在事务提交或回滚后才会被释放，并且所有的锁是同时释放的。

InnoDB会根据隔离级别在需要的时候自动加锁，这类锁称为隐式锁定。

另外我们可以通过一些特殊SQL语句进行显式锁定（不属于SQL规范）：

- `SELECT ... LOCK IN SHARE MODE`
- `SELECT ... FOR UPDATE`

## MVCC

大部分支持事务的存储引擎都实现了MVCC，可以用于规避一些原本需要的加锁操作，降低开销。

InnoDB的MVCC实现，实在每一行后面都加上隐藏的两列实现的，一列保存这条记录的创建版本，一列保存这条记录的删除版本。每个事务在开始的时候都会得到一个自增的版本号。

- SELECT：查询操作只会查找创建版本小于等于事务版本且删除版本为空或大于事务版本的记录，因为这些记录对当前事务是可见的。
- INSERT：插入一行记录，同时设置创建版本为当前事务版本。
- DELETE：将该行记录的删除版本号修改为当前事务版本。
- UPDATE：分解为一次DELETE和INSERT操作。

MVCC仅工作在READ COMMITTED和REPEATABLE READ两个隔离级别下。因为READ UNCOMMITTED和SERIALIZABLE都不需要进行版本控制。

同时MVCC可以解决REPEATABLE READ中的幻读问题。

# 索引

## 单列和多列索引

MySQL支持单列的索引和多列的索引，但是注意多列的索引中，列的顺序非常重要，因为mysql只能使用多列索引的某些前缀列。

## 索引类型

MySQL支持的索引类型如下：

- B-Tree索引：使用B-Tree存储索引，可以减少对磁盘的读取次数。读取次数与树的高度相同，树的高度与表大小有关。
- 哈希索引：基于哈希表实现，仅用于精确匹配。对于每一行记录，存储索引会为所有索引列计算一个哈希码，而哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向数据行的指针。只有Memory存储引擎显式支持哈希索引，且支持非唯一哈希索引（即允许多行拥有相同的哈希值）。注意多列索引中必须所有列全部命中才会使用哈希索引，且哈希索引只支持等于、不等于和IN条件。
- 空间数据索引（R-Tree）：用于地理数据存储，支持的不是很完善。
- 全文索引：类似于搜索引擎，用倒排索引的方式实现。

索引可以加快检索数据，但是需要额外的存储空间和维护成本。

## 伪哈希索引

InnoDB有一个特殊功能叫做`自适应哈希索引`。当InnoDB注意到某些索引值别使用的特别频繁的时候，它会在B-Tree索引之外再加一创建一个哈希索引。

如果我们查询条件中需要使用很长的字符串列，我们可以利用相同的思路优化我们的查询。比如我们要根据一个很长的url字段检索数据，那么我们可以额外加上一列叫做url_crc，存储url的CRC32哈希值。于是之后的查询可以这样写：

```sql
CREATE TABLE `t_urls` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `url` varchar(1024) NOT NULL,
  `url_crc` int(10) unsigned NOT NULL,
  PRIMARY KEY (`id`),
  KEY `index_url_crc` (`url_crc`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

CREATE TRIGGER `t_urls_BEFORE_INSERT` BEFORE INSERT ON `t_urls` FOR EACH ROW BEGIN
	SET NEW.url_crc=crc32(NEW.url);
END

CREATE TRIGGER `t_urls_BEFORE_UPDATE` BEFORE UPDATE ON `t_urls` FOR EACH ROW BEGIN
	SET NEW.url_crc=crc32(NEW.url);
END
```

这里使用触发器自动更新url_crc列。可以发现我们在url_crc列上建立B-Tree索引，而非在url列上，由于url_crc是整数，因此比较速度远快于url的比较，因此可以得到很大的性能优化。

注意由于存在哈希碰撞，因此查询条件必须包含url列：

```sql
SELECT * FROM t_urls where url='https://flink.apache.org/zh/' and url_crc=crc32('https://flink.apache.org/zh/');
```

由于生日悖论，哈希碰撞在数据量上万后很容易发生，因此可以使用`FNV64`函数来生成64位的哈希值。

## 索引的使用

要使用索引，需要满足一些条件。

### 独立的列

如果查询中的列不是独立的，那么MySQL就不会使用索引。其中独立指这个列不能是表达式的一部分，也不能是函数的参数。比如下面条SQL就不会用到age列上加的索引。

```sql
SELECT * FROM t_user where age + 1 = 26;
```

当然很显然条件等价于`age = 25`，但是MySQL无法自动解析这个公式。因此需要我们自己将索引列单独放在比较符号的一侧。

同样，下面的SQL也不会用到birth_day列上的索引，因为索引列不能作为函数参数。

```sql
SELECT * FROM t_user where YEAR(birth_day) <= YEAR(CURRENT_DATE);
```

### 前缀索引

对于很长的字符列，建立完整的索引会浪费很多空间且使得性能降低，一般的解决方案是仅为字符列的固定长度的前缀建立索引。

这样做与哈希索引是类似的（我们可以把字符列的前缀视作它的一个不均匀的哈希值），好处是降低了维护索引和使用索引的成本，但是缺点是有时无法通过索引定位到某条数据，可能定位到某块数据，我们必须遍历这块数据。

前缀索引使用的前缀越长，搜索越精确，但是成本也越高。

前缀索引不能用于ORDER BY和GROUP BY。

### 合并索引

如果你查询条件中出现多个列都可以作为索引。老版本（5.0之前）的MySQL不会使用合并索引，比如下面SQL：

```sql
SELECT * FROM t_user where region='wenzhou' and age=25 ;
```

这种情况下使用单独的region和age索引效果都不好，因此会转而使用全表扫描。但是如果我们改写SQL成下面的样子，就可以同时使用两个索引了：

```sql
SELECT * FROM t_user where region='wenzhou' 
union
SELECT * FROM t_user where age=25 and region!='wenzhou';
```

在5.0版本及之后，MySQL可以同时使用多列索引并将结果合并。但是如果你在explain界面看到使用了合并索引的技术，这往往说明表的索引建立的非常糟糕，使用合并索引的性能有时甚至不如全表扫描。

- 当服务器对多个索引做相交操作时（多个AND条件），通常意味着你需要建立一个包含所有相关列的多列索引。
- 当服务器对多个索引做联合操作时（多个OR条件），需要花费大量的时间用于合并得到的数据（去重，重新排序等）。
