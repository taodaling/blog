---
categories: algorithm
layout: post
---

树上DP有很多种形式，下面给出一个树上DP的题目：

n个结点，每个结点有一个颜色，要求我们计算每个结点作为根的子树中不同的颜色数目。

这个问题，你可以通过哈希表以及启发合并来实现，这样的时间复杂度就为$O(n\log_2{n})$。

当然由于哈希表的常数和消耗的空间会略大，你可以使用莫队算法，这样的时间复杂度为$O(n\sqrt{n})$。

还有一种就是使用一种树上启发合并的方式，其起源于Codeforce的一篇博客[Sack (dsu on tree)](<https://codeforces.com/blog/entry/44351>)。Dsu on tree算法适用于有根树的所有子树的DP。下面说一下流程：

首先我们要对有根树进行轻重链剖分。

之后我们对树进行深度优先搜索，计算DP值。计算DP值分成三步，对由轻链连接的子树递归调用当前过程，但是要清除它们带来的影响（我们会维护一个全局的数组，记录子树的状态，在这个问题中就是一个布尔数组，记录颜色是否出现，这里消除影响的意思是将数组恢复到对这些子树调用递归过程之前的状态）。之后我们对重链边连接的子树进行递归调用，但是保留它们的状态，并用在当前结点的状态计算上。之后分别对轻链连接的子树调用一次递归过程，但是这个过程既不是为了计算子树的DP，也不要求清除状态，但是要把原来的状态附加到现有的状态上。

因此我们可以将DFS分成两种，第一种我们称为动态规划流程，其目的是为了利用子树的状态计算当前结点的DP值，我们称为计算过程；第二种是不计算自己的DP值，而只是贡献自己的状态信息，我们称为贡献流程。

而我们会为每个结点调用一次计算流程，会为每条轻链连接的子树调用一次贡献流程。当然你可能会问，为什么不在计算流程中把计算结果保存下来呢，这样只需要合并一下，而不需要使用慢的多的贡献流程。原因是这样的，味为每个结点都保存状态，考虑所有的结点仅于根结点有一条连接的边，那么我们在计算跟结点的状态的同时，还需要保存(n-1)份状态信息，而每份状态信息的大小都是|C|，C是可能的颜色的集合。当然你会说我们可以使用哈希表来节省内存，但是使用哈希表的话性能会大幅度恶化，而且同样也会占用大量的空间，这样对于时间和空间限制比较严格的情况下是很难通过的。

下面聊聊时间复杂度。在我们上面的问题中，计算流程的时间复杂度为$O(n)$，而贡献流程，每个结点最多会参加与自己到根结点的路径上轻边数目相同次数的贡献流程（在任意一颗大小为$n$的树中，每条一个端点为根结点的路径最多有$\log_2{n}$个轻边），而每次参加的时间复杂度为$O(1)$，共$n$个结点，因此贡献流程的总时间复杂度为$O(n\log_2{n})$。轻重链剖分的时间复杂度为$O(n)$，因此总的时间复杂度为$O(n\log_2{n})$。





