---
categories: technology
layout: post
---

- Table
{:toc}

# 内存分区

JVM内存分区分为：

- 程序计数器：存储当前线程执行的字节码地址，每个线程私有，用于实现跳转等。  如果执行的是Native方法，计数器则为空。
- 虚拟机栈：每个方法执行时，都会创建一个栈帧，栈帧中存储了局部变量表，操作数栈，动态连接，方法出口等信息。局部变量表中一个double，long类型对象占两个slot，其余类型占一个slot。如果线程请求的栈深度大于虚拟机允许的深度，会抛出StackOverflowError，如果栈申请不到足够的内存，则会抛出OutOfMemoryError。
- 本地方法栈：与虚拟机栈类似，只不过是为本地方法服务的。由于Java虚拟机规范没有对其进行严格规定，所以很多虚拟机直接将本地方法栈和虚拟机栈合二为一。
- Java堆：虚拟机所管理的内存最大的一块。Java堆是线程共享的一块内存区域，此区域的唯一用处就是存放对象实例，Java中几乎所有的对象都是在这里分配内存的。如果堆无法完成实例的分配且无法进一步无法扩展，则会抛出OutOfMemoryError。
- 方法区：类似于Java堆，是各个线程共享的一块内存区域，用于存储已经被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
- 直接内存：在JDK1.4中加入了NIO类，引入了基于通道与缓冲区的IO方式，它可以使用Native方法直接分配堆外内存，从而避免在堆外内存和Java堆之间来回拷贝。直接内存受物理内存限制，当动态扩展失败时，会抛出OutOfMemoryError。

# 内存分配

Java的实例分配的算法一般分为两种。

- 指针碰撞：维护一块大的内存，之后每次分配都从内存头部切出一小块内存。
- 空闲列表：将空闲的内存块放入列表中。每次分配内存的时候就从中挑选一个足够大的内存划分给对象实例。

一般指针碰撞的方式更加高效，但是对垃圾回收算法提出了更高的要求，垃圾回收器必须带有空间压缩整理的能力，比如使用Serial、ParNew等待压缩整理过程的收集器时，系统采用的分配算法是指针碰撞；而当使用CMS这种基于清理算法的收集器时，理论上只能采用空闲列表算法。

但是由于Java是支持并发的，并发的分配对象，也就意味着我们的实例分配算法需要是线程安全的。有两种解决方案：

- 对分配内存的动作进行同步处理（实际HotSpot的实现方案）。
- 为每个线程分配一个小块的分配缓冲区，每次线程分配对象先从自己的缓冲区中通过指针碰撞算法进行分配。分配新的缓冲区时才需要同步操作。

注意对于空闲列表，也可以使用我们上面提到的分配线程缓冲区技术，这样大部分情况下，实际上是在用指针碰撞算法。

# 对象内存布局

对象在堆内存中的存储布局可以划分为三个部分：对象头、实例数据和对齐填充。

对象头中包括两类数据：

- 对象自身的运行数据（Mark Word）：哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳。这部分的长度为机器的字长相同。
- 类型指针：指向对象所属的类实例的元数据。此外如果对象是数组，则还会记录数据的长度。

实例数据中，存储所有类中定义的字段以及父类中继承得到的字段。默认的顺序是按照字段占用空间的大小从大到小排序，在满足这个前提下，等宽类型的字段父类中的字段放在子类之前。


由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8的整数倍，对齐填充是放在对象尾部的一段起占位符作用的内存。

# 引用

Java程序会通过栈上的reference来操作堆上的数据，由于引用类型在《Java虚拟机规范》里面只规定了它是指向对象的引用，而没有定义如何引用，所以也取决于虚拟机的具体实现。主流的方式是句柄引用和直接指针两种。

- 句柄访问：Java堆中会划出一块内存作为句柄池，reference中存储的是句柄地址，而句柄中存储的实际对象地址。
- 直接指针访问：reference存储的对象在堆上的地址。

句柄访问的优势是在移动对象的时候只需要修改句柄中的数据即可，而需要操作程序栈。而直接指针访问的优势是一步到位，比句柄访问少一次内存访问，性能更加快。HotSpot中使用的是直接指针访问。

JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用，软引用、弱引用、虚引用，强度递减。

- 一般我们的变量就是强引用，被强引用的对象是不能被回收的。
- 软引用描述的是有用但不是必要的对象。在系统发生内存溢出前，会将这些对象列入回收范围之中进行二次回收，只有二次回收还没有足够的内存，才会p抛出内存溢出异常。
- 弱引用用来描述那些非必须的对象，它的强度要比软引用更弱。弱引用只能存活到下一次垃圾回收发生为止。当垃圾收集器工作时，不管内存是否足够，都会把仅被弱引用所引用的对象回收掉。
- 虚引用时最弱的引用。一个对象是否有虚引用在引用它，都不影响它的生存时间，也无法通过虚引用获得一个对象实例。虚引用的用处是在这个对象被回收的时候收到一个系统通知。

# 内存回收

Java栈空间会随着线程的消亡而消亡，而栈帧在方法返回后就会被销毁，因此不需要回收。

真正需要内存回收的是Java堆和方法区。哪些对象应该被回收，这只有在运行期间才能得知。垃圾回收期器关心的就是这部分内存的管理。

## 判断垃圾

要实现垃圾回收，垃圾回收器一定要有能力确定哪些对象是垃圾。下面是几种传统的方案：

引用计数法：为每个对象增加一个计数器，如果一个reference指向某个对象，这个对象计数器就加1，而原来对象的计数器就减少1。如果一个对象的引用为0，则它就不再可能被访问，可以作为垃圾回收。引用计数法的优势是实现简单，实时回收，但是缺点是无法解决循环引用的问题（a引用b，b引用a，这两个对象永远不会被释放）。微软的COM技术，Python语言等用的就是引用计数算法来实现对象内存回收。

可达性分析法：基于图论，一个对象可以再次被访问，当且仅当从GC根可以通过引用链抵达这个对象。可以作为GC根的对象包括：

- 栈中的引用的对象
- 类静态变量
- 方法区中的常量
- 本地方法栈中JNI引用的对象
- 所有被同步锁持有的对象
- 本地代码缓存
- JMXBean、JVMTI中注册的回调

上面的GC根并不完全，还可以加入一些其它对象。比如在执行分代回收的时候，虽然我们仅清理某个内存区域，但是这个内存区域中的对象可能被其它内存区域中的对象所引用，因此我们需要将其它内存区域中的对象也加入作为GC根。

实际上即使是在可达性分析中判定不可达的对象，也不是必定会被回收的。在可达性分析中被确定为不可达的对象，它将会被第一次标记，随后进行一次筛选，如果对象覆盖了finalize方法且方法未被调用过，那么对象就会被放置在一个名字为F-Queue的队列中，之后由一个虚拟机自动建立的、低调用优先级的Finalizer线程去执行它们的finalize方法。这里说的执行是虚拟机会触发这个方法开始运行，但是不保证会等待它运行完成。稍后收集器会对F-Queue中的对象进行第二次小规模的标记，如果此时对象依旧不可达，则就会被回收，否则逃过一劫。

除了上面提到的堆空间的内存回收外，实际上方法区也会进行内存回收。《Java虚拟机规范》中并不强制要求虚拟机在方法区中实现垃圾回收。且方法区即使进行回收，一般由于回收条件的严苛，也是收效甚微的。

方法区中可以回收的内容如下：

- 废弃的常量：如果常量不再被引用，且虚拟机中没有其它字面量引用它，就可以被回收。
- 不再被使用的类型：类及所有派生子类的所有实例都被回收，类的类加载器被回收，java.lang.Class对象不再被引用。满足上面这三个条件，类型就可以被回收。

## 分代回收

当前商业虚拟机的垃圾收集器，大多数都遵循了分代收集的理论仅设计，它建立在两个假说上：

- 弱分代假说：绝大多数对象都是朝生夕灭的。
- 强分代假说：经历过越多次垃圾回收过程的对象越难消亡。

根据这两个假说，收集器应该将Java堆按照年龄划分为若干个区域。这样对存储对象年级较小的分区，可以更加高频的进行垃圾回收（能释放出更多的空间），而对于对象年级较大的分区，则可以低频的进行垃圾回收。

设计者一般会将Java堆至少划分为新生代、老年代。每次新生代没有被回收的对象移动到老年代中去。

由于即使进行了分代，但是可能存在跨代引用，因此即使仅回收新生代，也需要遍历所有老年代的对象，这样和全局回收差别不大。因此需要下面的假说：

- 跨代引用假说：跨代引用相对于同代引用占极少数。

根据上面这个假说，只需要在新生代建立一个全局的数据结构（该结构称为记忆集），这个结构把老年代划分成若干个小块，并标志哪些块中存在跨带引用。之后对新生代进行回收的时候，就可以跳过大部分老年代的块，仅将少部分块中的对象加入到GC根中即可。这种方式增加了一些运行时的开销，但是比起收集时扫描整个老年代来说仍然很划算。

一般垃圾回收过程根据其回收区域分成：

- Young GC：仅回收新生代
- Old GC：仅回收老年代
- Mixed GC：回收老年代和新生代
- Full GC：回收整个Java堆和方法区

## 回收算法

基础的回收算法是标记-清除算法，算法分成标记和清除两个阶段。第标记阶段标记所有需要回收的对象，在清除阶段回收掉所有被标记的对象。标记-清除算法的缺点如下：

- 执行效率低：如果需要回收的对象很多，则算法执行时间很长。
- 内存碎片化：清除完后会产生大小内存碎片，内存碎片多会导致之后分配时无法找到足够大的内存，导致另外一次GC的发生。

标记-复制算法解决了标记-清除算法的问题。其使用一种半区复制的技术，将内存分为两个等大的块，每次仅一块被使用，另外一块闲置。当使用的那块内存被耗尽的时候，就将使用的块中的所有存活对象全部拷贝到闲置的块中，在拷贝的过程中，进行内存的整理。这样的好处是实现简单，且运行高效，但是缺点是将可用内存变为了原来的一半。

现在的商用Java虚拟机大多都采用标记-复制算法去收集新生代。

IBM曾经做法专门研究发现：新生代中的$98\%$对象熬不过第一轮收集。因此有一种更优半区复制分代策略，现在称为Appel式回收的算法：将新生代分为一个较大的Eden空间和Survivor空间，每次分配内存只使用其中的一块Eden和Survivor空间。然后在垃圾回收的时候，将Eden和在用的Survivor中的存活对象复制到另外一个Survivor块中，之后清理掉原来的Eden和Survivor空间。HotSpot中默认的Eden和Survivor的大小比为8:1，因此空间的可用率是$90\%$。

但是上面的仅仅是经验，并不能保证真的每次回收存活的对象都能被放入Survivor块而不会溢出。在这种情况下就需要依赖其它内存区域（实际上大多是老年代）进行分配担保。这样的话，无法放入一块Survivor块的对象会直接晋升到老年代中去。

标记-复制算法在对象存活率较高的时候要进行较多的复制操作，且有效空间只有原来的一半（如果使用Appel式回收，则会导致分配担保）。因此在老年代一般不能选择这种算法。

针对老年代，有一种标记-整理算法。其和标记-清理算法的区别在于完成清理后它会将存活的对象移动到内存的一端，从而去除内存碎片。

老年代有大量的存活对象，移动存活对象和更新所有引用这些对象的地方将会是很大的负担。而且这种对象移动操作需要暂停用户程序才能进行。这样的停顿被虚拟机设计者描述为Stop The World。

是否移动内存，有好处也有坏处。移动内存的好处是分配内存的时候更加简单，而移动内存的坏处是使垃圾回收需要长时间暂停用户程序。移动内存会增加对象分配回收的吞吐量，但是会增加延迟。HotSpot中关注吞吐量的Parallel Scavenge收集器就是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法。

