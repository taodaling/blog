---
categories: algorithm
layout: post
---

- Table
{:toc}


# BZOJ1016

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1016](https://www.lydsy.com/JudgeOnline/problem.php?id=1016)

**题解**

按理来说，这道题是不可做的。但是由于相同权值的边数被限制在了10条，因此就有了一种暴力枚举的做法。

首先观察Kruskal的流程，我们可以发现，当我们交换相同权重的边的处理顺序时，才有可能获得新的生成树。因此我们可以将边按照权重分组，从小到大处理。

一种方案是枚举所有边的排列，但是这样的时间复杂度为$10!$，略大。还有一种方案是，我们枚举每条边是否出现在最终的生成树中，这样的时间复杂度为$2^{10}$，是可以接受的。用可撤销的并查集维护构建的生成树，并统计结果数。

这道题的图不一定连通，要小心。

# BZOJ2901

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2901](https://www.lydsy.com/JudgeOnline/problem.php?id=2901)

**题解**

K短路。但是题目中的路径是不允许过重复点的，但是题意中已经给出只能从高处到低处，因此路径上一定不会有重复点。

K短路可以用A star算法求解，空间复杂度为$O(kE)$，时间复杂度为$O(kE\log_2kE)$。

# BZOJ2429

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2429](https://www.lydsy.com/JudgeOnline/problem.php?id=2429)

**题解**

最小生成树或二分。时间复杂度为$O(nlog_2n)$。

# BZOJ1196

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1196](https://www.lydsy.com/JudgeOnline/problem.php?id=1196)

**题解**

可以如果发现在费用上界设为x时有方案，那么设为任意大于x的值也是有方案的。于是可以用二分，二分费用上界。

之后我们用贪心的方式尽可能多用不超过上界的一级道路。之后如果图还不连通，就用二级道路。最后校验是否用够了k条一级道路，以及最后图是否连通。

# BZOJ1715

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1715](https://www.lydsy.com/JudgeOnline/problem.php?id=1715)

**题解**

搜负环的模板题。用Spfa，递归版有奇效。

# BZOJ1050

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1050](https://www.lydsy.com/JudgeOnline/problem.php?id=1050)

**题解**

假如要求最小边的权一定为x，那么我们可以只考虑边权大于等于x的边，按边权从小到大加入到图中，直到s、t连通。这时候最大边的边权为y，则y/x为要求的最小比值。这里是一个贪心的做法。

我们可以枚举最终解中的最小边，提前排序边集，总共有$M$种可能。利用滑动窗口的技巧，我们不必在每次考虑新的最小边的时候重建整个图。这意味着我们只需要做$M$次加边、删边、判连通操作。

我们注意到后加的边一定后删，因此我们可以用LCT判连通。当新的边加入后会成环，那么就剔除环中最早加入的边即可。这样保证连通性检测时的结果不会变动，同时只处理树形结构。

总的时间复杂度为$O(Mlog(N+M))$。

# BZOJ1093

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1093](https://www.lydsy.com/JudgeOnline/problem.php?id=1093)

**题解**

首先我们可以对图中的环进行缩小点，一个点的点权表示该点由多少点缩点而来。我们希望找到一个最大的半连通图，点权和最大。缩完点后的图是有向无环图。

假设G=(V,E)为我们找到的最大半连通图，观察它满足的性质。首先G一定是有向无环连通图，同时我们一定可以找到一个唯一的顶点v，其入度为0（否则假如找到两个点u、v入度都为0，这意味着u、v之间不存在一条路径，这与G是半连通图相悖）。在移除v后得到的图还是半连通图。我们不断重复移除的过程得到了一个顶点序列$v_1,v_2,\ldots ,v_n$。我们可以保证它们构成一条路径。而一条路径一定是半连通图。因此我们得知一个图是半连通图当且仅当它的所有顶点序列可以构成一条路径。

故，我们实际上要找到的是图中的一个最大权路径，在DAG中，我们可以在顶点的拓扑序上使用动态规划技术得到。


# BZOJ3786

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=3786](https://www.lydsy.com/JudgeOnline/problem.php?id=3786)

**题解**

首先有换父操作，因此我们需要用到动态树。Link-Cut-Tree适合处理路径问题，但是题目中要求支持子树增强权重的操作。

考虑另外一个动态树实现Euler-Tour-Tree。我们利用DFS可以将树转换为括号序列，并用平衡树维护序列。这样将以x为根的子树移除出树，等价于将x的开闭括号从序列中删除。而将以x为根的子树连接到y下，等价于找到y的闭括号，并将x对应的括号序列加到y的闭括号之前。

之后查找x到根所有顶点的权重之和，可以用一种特殊的技巧统计路径信息。我们在遇到开括号时，执行加操作，在遇到闭括号时执行减操作。这样只需要统计根的开括号到x的开括号这段序列的权和即可。


# BZOJ1491

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1491](https://www.lydsy.com/JudgeOnline/problem.php?id=1491)

**题解**

Floyd+DP

# BZOJ1027

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1027](https://www.lydsy.com/JudgeOnline/problem.php?id=1027)

**题解**

由于a+b+c=1，因此若(a,b)一旦确定，那么c就随着确定。现在考虑两个点$(x_1,y_1),(x_2,y_2)$。对于$t\in [0,1]$，可以取到形如点$(x_1t+x_2(1-t), y_1t+y_2(1-t))$，这些点组成的实际是$(x_1,y_1)$与$(x_2,y_2)$之间的线段。之后继续加点，我们会得到凸多边形。

至此，我们知道了题目实际上的本意，将需求转换为二维平面上的点，我们要找到尽可能少的原料代表的点，使得这些点唯一确定的凸包能包含所有需求点。

一个点落于凸多边形中当且仅当这个点处于凸多边形的所有边的逆时针方向。

我们可以证明要寻找的n个原料点一定是凸包上的点，且由点数最少，可以推出边数最少。能够形成凸包的边一定满足所有顶点都落在凸包的逆时针方向。

我们将所有满足条件的边的边权设为1，不满足条件的边的边权设为无穷。那么可以得出最小环一定是最优解组成凸包上的边。

最小环可以通过FW算法得到。


# BZOJ1232

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1232](https://www.lydsy.com/JudgeOnline/problem.php?id=1232)

**题解**

发现USACO的题目质量好高啊。

首先容易发现，在移除多余的边后得到的是一株树。而无论从那个顶点出发遍历整颗树的最短距离为$2\sum_{e\in E}e.w$，即边权之和的两倍。这很容易理解，遍历以某个顶点为根的子树，我们需要依次遍历每个子结点为根的子树，这和深度优先搜索实际上是相同的实现。而每次我们从根下降访问子树，而访问完子树后需要原路返回，因此每条边都会被经历两次。

但是这距离我们最终结果还相距甚远，因为不仅边有权，点也有对应的权。如果点没有权的话这个问题实际上就是算最小生成树而已。

观察树，对于任意一个顶点u，如果顶点的度为d，那么这个顶点在遍历的整个过程中至少会被访问d次。一条边与父节点连接，这里会访问一次u，之后每次从u的子节点搜索返回，都会访问u一次。根结点比较特殊，因此一开始就位于根结点，因此根节点的访问次数会比它的度额外多1。

因此如果树选取好了，我们简单记作$T=(V,E')$。可以推出最小的要花的时间为：


$$
root.w + \sum_{u\in V}u.w\cdot u.d + \sum_{(u,v)\in E'}(u,v).w\cdot2
$$


因此我们实际上要做的是选取一株树，使得上面式子最小。我们可以将上面公式进行改写：


$$
root.w + \sum_{(u,v)\in E'}((u,v).w\cdot 2+u.w+v.w)
$$


由于root的选择仅影响上面式子中$root.w$这一部分，因此我们始终选择权最小的顶点作为根。而右边和式中，如果我们定义每个边的修正权为$(u,v).w'=(u,v).w\cdot 2+u.w+v.w$，和式就变成了：


$$
\sum_{(u,v)\in E'}(u,v).w'
$$


要使该式最小，只需要基于修正后的边权，生成最小生成树就可以了。

# BZOJ1977

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1977](https://www.lydsy.com/JudgeOnline/problem.php?id=1977)

**题解**

严格最小生成树。看别人博客说是严格次小生成树能和最小生成树只差一条边，我并不知道怎么证明。先记录一下吧。

我们需要维护路径上的最大权边和次大权边，这个用动态树就好了，时间复杂度$O(n\log_2n)$。

# BZOJ3699

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=3699](https://www.lydsy.com/JudgeOnline/problem.php?id=3699)

**题解**

好题。可以脑补一个网格图，左下角网格坐标为(0,0)，横坐标为a，纵坐标为b。之后将所有边按照其a、b分配到网格中。

对于每一个i，我们试图找到最小的一个数j，使得仅使用那些属性a不超过i，属性b不超过j的边，可以保证顶点1和n连通。我们记$f(i)=j$，容易发现f是一个递减函数。

因此，我们可以先从点(-1,50000)出发，之后，不断向右或向下移动一步。可以证明最多移动2L步，L是精灵数要求的上限，这里是50000。

在整个流程中，每条边最多加入图一次，最多被移除一次，因此加入和删除操作会分别发生最多m次。而每次一定后都要重新判断顶点1和n是否连通，即需要查询连通2L次。

可以发现，b越大的边越早被删除。我们以b作为删除时间，那么问题就转换为如何在线维护一副图，图中边有自己的删除时间，要求查询各个时间下的连通性。

这个可以通过动态树实现，我们用动态树维护图的一个生成树。当我们加入一条边时，如果边的两个顶点不连通，这代表加入边后图依旧是森林，即没有环存在。如果边的两个端点连通，那么找到两个端点之间的唯一路径，判断路径上删除时间最小的边，如果该边的删除时间早于我们要加入的边，那么我们可以用新边替换该条边，否则不处理。我们可以保证任意时刻，如果两个顶点在动态树中不连通，那么没有加入动态树的边一定被过期删除了，因此即使这些边加入图中，此时依旧不连通。当然如果连通自然是确实连通的。而用这种方法，并不需要真的执行删除操作，要判断两个顶点连通，只需要判断两条边之间删除时间最早的边是否以及过期。

# BZOJ 1098

**题意**

[http://www.lydsy.com/JudgeOnline/problem.php?id=1098](http://www.lydsy.com/JudgeOnline/problem.php?id=1098)

**题解**

经典题。我们将员工建立顶点，两个员工有联系方式，那么我们就加入一条边。可以发现，如果两个人没有边，那么他们必须住在一个办公楼里。我们将图反转（两个顶点若之前有边，就删掉，否则加一条边），可以发现题目要求我们求的是有多少个连通块以及每个连通块的大小。

那么怎么求呢，有个技巧，就是发现被删除的边是有限的。我们可以随意从任意一个顶点开始找它所在的连通块，遍历所有其余没有处理过的顶点，查询是否二者之间存在边。成功，就将这个顶点合并进当前连通块，否则就跳过，处理直到当前连通块中所有顶点都被处理过了一次。

我们估计一下时间复杂度，可以发现时间复杂度取决于上面查询发生的次数。由于查询成功的次数不会超过$2m$，而每次失败都会将某个未处理的顶点删除，因此失败最多发生$n$次。总共时间复杂度为$O(2m+n)$。

# BZOJ4043

题目要求我们能判断路径的总权值，以及动态更新单点权值和子树权值。

如果只有单点权值，可以使用LCT来维护整颗树，复杂度为$O(nlog_2n)$。但是这里有子树权值，所以还是需要使用树链剖分的。

这题实际上考察的是树链剖分的一个特性，我们为每个结点重新分配序号时，同一条重链上的所有结点的序号是连续的，同时一颗子树下的所有结点的序号恰好形成一个连续的区间。

因此我们只需要寻找轻重链，之后为每个结点分配序号，按照序号创建一个线段树。之后的所有操作都在线段树上完成，实际的时间复杂度为$O(nlog_2^2n)$。

# BZOJ4196

将软件表示为结点，软件安装对应结点权值为1，未安装对应权值为0。题目实际上要我们求的是计算子树的总权值和，计算路径权值和，设置路径权值，设置子树权值。之后问题同BZOJ4043。

# BZOJ3531

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=3531](https://www.lydsy.com/JudgeOnline/problem.php?id=3531)

**题解**

我一开始写的是带修改树上莫队，但是，TLE了。本地测了一下，速度还行的啊，10w的数据也就几秒。

正解貌似是用轻重链剖分，只是维护100000+1个动态开点的线段树，每个线段树仅记录一种颜色的顶点的信息。这样时间空间复杂度为$O((n+q)(\log_2n)^2)$。

# BZOJ4552

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=4552](https://www.lydsy.com/JudgeOnline/problem.php?id=4552)

**题解**

线段树分裂合并的模板题。


# BZOJ1699

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1699](https://www.lydsy.com/JudgeOnline/problem.php?id=1699)

**题解**

裸题，可以用来测模板。St或线段树。

# BZOJ1251

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1251](https://www.lydsy.com/JudgeOnline/problem.php?id=1251)

**题解**

裸题，可以用来测模板。Treap、Splay都行。

# BZOJ2243

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2243](https://www.lydsy.com/JudgeOnline/problem.php?id=2243)

**题解**

由于是路径操作，路径操作的题目基本解法都是树链剖分、动态树、树上莫队。

考虑线性结构。类似于这类统计区间不同段数的问题，我们可以维护一个值tag，对于某个段，设置开头元素的tag为1，后续的元素的tag为0。这样，一个区间$[l,r]$存在多少个不同的段，可以统计区间$[l+1,r]$中tag的和，加上1后就是正确结果。

在处理树上路径的时候，也可以同样处理。如果u与其父节点在同一条重链上，且u与父节点的颜色不同，就设置u的tag为1。使用树链剖分，我们每次操作只需要处理$\log_2n$条重链，统计重链上tag的和，并且统计所有处于路径上的连接两个不同的重链的边，如果边的两端颜色不同，那么我们还需要在向结果加1。

而更新操作只需要处理路径上的重链就好了。

# BZOJ1036

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1036](https://www.lydsy.com/JudgeOnline/problem.php?id=1036)

**题解**

水题，树链剖分或动态树。

# BZOJ2038

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2038](https://www.lydsy.com/JudgeOnline/problem.php?id=2038)

**题解**

裸的莫队

# BZOJ2120

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2120](https://www.lydsy.com/JudgeOnline/problem.php?id=2120)

**题解**

裸的带修改莫队

# BZOJ1878

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1878](https://www.lydsy.com/JudgeOnline/problem.php?id=1878)

**题解**

莫队应该也能过，但是这题有O(nlogn)的解法。

我们从左到右扫描整个贝壳序列，假设当前扫描到i。我们为同类贝壳中最靠近i的贝壳的打上标记，而其余贝壳不打标记，统计以i为右边界的区间中不同贝壳数，可以转为统计区间中打上标记的贝壳数。

提前排序请求，并用BIT维护标记状态即可。

# BZOJ2743

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2743](https://www.lydsy.com/JudgeOnline/problem.php?id=2743)

**题解**

与BZOJ1878相同，但是需要打标记的花朵是距离扫描点第二近的花朵。

# BZOJ1146

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1146](https://www.lydsy.com/JudgeOnline/problem.php?id=1146)

**题解**

裸的带修改树上莫队。


# BZOJ1109

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1109](https://www.lydsy.com/JudgeOnline/problem.php?id=1109)

**题解**

用动态规划，dp(i)表示仅考虑前i个数，并保留第i个数最多有多少满足的块。简单推推可以转移公式：


$$
dp(i)=\max_{j<i}([a[j]<a[i]\land i-j\geq a[i]-a[j]]dp(i))+1
$$


后面部分我们可以做个转换得到：


$$
i-j\geq a[i]-a[j]\Rightarrow i-a[i]\geq j-a[j]
$$


我们可以定义$x_i=a[i]$，$y_i=i-a[i]$，$z_i=i$，那么问题就转换了三维最长递增子序列问题。

注意到由前两个条件可以保证第三个条件的成立，因此可以忽略第三个条件，问题转换为二维最长递增子序列问题。

随便写吧。一开始没有想这么多，就直接DP+树套树，结果TLE了。


 # BZOJ1040

**问题**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1040](https://www.lydsy.com/JudgeOnline/problem.php?id=1040)

**题解**

首先把骑士作为结点，将讨厌关系作为边建立。容易发现两个连通分量之间的选择是独立的，因此我们只要为每一个连通分量选择最大的总权，之后加总就好了。

一个连通分量有k个骑士，则必定有k条边。我们知道这样的图本质是一个树加上一条边，即树中最多只有一个环。记X，Y为环的两个顶点，且X讨厌Y。那么我们知道X与Y不能同时出现，那么最优结果要么X不出现，要么Y不出现。我们分别尝试删除X以及删除Y两种策略，计算树形DP，就可以得到最优质值。



# BZOJ1079

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1079](https://www.lydsy.com/JudgeOnline/problem.php?id=1079)

**题解**

一开始以为是容斥，捂脸。

一种很简单的思路就是定义函数$f(i_1, i_2, \ldots, i_k, c)$表示用$i_j$种颜色j，有多少种有效排列，排列以颜色c作为结尾。但是函数的状态有$5^15\cdot k$种，这样的动态规划会超时。

实际上颜色具体是什么并不重要，重要的是数量为1的颜色有多少种，数量为2的颜色有多少种...因此我们定义的动态规划公式为$f(i_1,i_2,i_3,i_4,i_5, c)$，表示数量为j的颜色有$i_j$种，其中以数量为c的某种颜色作为开头的有效排列数目。这样总共状态为$15^5\cdot 5$，是可以求解的。



# BZOJ1010

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1010](https://www.lydsy.com/JudgeOnline/problem.php?id=1010)

**题解**

利用动态规划，定义$f(i)$表示要打包前i个物品的最小费用。容易推出：


$$
f(i)=\min_{j=0}^{i-1}(f(j)+(\sum_{k=j+1}^ic_k+(i-j-1)-L)^2)
$$


用原始的动态规划时间复杂度为$O(n^2)$，会超时。我们稍微简化一下公式，记$pre_i=\sum_{i=1}^nc_i$，$a_i=pre_i+i-L$，$b_i=pre_i+i+1$。代入上面式子中：


$$
f(j)+(\sum_{k=j+1}^ic_k+(i-j-1)-L)^2\\
=f(j)+(pre_i+i-L-(pre_j+j+1))\\
=f(j)+(a_i-b_j)^2\\
=f(j)+a_i^2+b_j^2-2a_ib_j
$$


我们可以改写递推公式：


$$
f(i)=a_i^2+\min_{j=0}^{i-1}(-2b_ja_i+f(j)+b_j^2)
$$


由于我们在计算$f(i)$的时候与j关联的变量都是已知的，因此可以视作常量，换一种表示，我们就会发现有min中的表达式对应一条直线，即$y=ax+b$，其中x需要我们用$a_i$代入。如果我们为这些直线维护一个上凸包，就可以利用凸包优化以$O(\log_2i)$的时间复杂度直接得到最优的j，而不需要以$O(i)$的时间复杂度遍历。这样时间复杂度就优化到$O(n\log_2n)$。

但是由于java没有long double类型，而数值的数据范围过大，所以精度不足会给出约莫的值，会WA。所以需要换种方法。

下面我们考虑使用斜率优化的方式。若存在$j>k$，且$-2b_ja_i+f(j)+b_j^2 \leq -2b_ka_i+f(k)+b_k^2$。继续推导：


$$
-2b_ja_i+f(j)+b_j^2 \leq -2b_ka_i+f(k)+b_k^2\\
\Rightarrow (f(j)+b_j^2)-(f(k)+b_k^2)\leq (2b_j-2b_k)a_i\\
\Rightarrow \frac{(f(j)+b_j^2)-(f(k)+b_k^2)}{2b_j-2b_k}\leq a_i
$$


记$Y(i)=f(i)+b_i^2$，记$X(i)=2b_i$，那么公式就转换为


$$
\frac{Y(j)-Y(k)}{X(j)-X(k)}\leq a_i
$$


而由于$a_i$是递增函数，因此可以利用斜率优化，时间复杂度为$O(n)$。

# BZOJ1222

**问题**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1222](https://www.lydsy.com/JudgeOnline/problem.php?id=1222)

**题解**

一开始以为是最大流，没想到解法。容易发现每个任务的费时都非常小，最多为5，因此需要在这里动手脚。

定义动态规划f(i,j,k)，表示是否有可能完成前i个任务，任务占用了机器A时间不超过j，任务占用了机器B时间不超过k，f(i,j,k)的返回值是布尔值。很显然当i和j固定时，f随着k的增大从false变为true，即$f_{ij}(k)=f(i,j,k)$使单调增函数。类似这类函数，我们只需要记录变为true的最小的k。因此我们将函数优化到了二维$g(i,j)=minarg_{k}f(i,j,k)=true$。这时候函数的整个状态只有$O(5n^2)$，是可以通过时限的。

我们将$g(i,j)$解读为当使用机器A时间少于等于j时，完成前i个任务至少需要占用机器B时间多少。这样就可以很容易推出递推公式。

# BZOJ1030

**问题**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1030](https://www.lydsy.com/JudgeOnline/problem.php?id=1030)

**题解**

要算有多少字符串合法，可以通过算多少字符串非法得到。首先对所有的子串通过AC自动机状态压缩，之后利用动态规划解决。$f(i,j)$表示有多少长度为i并处于状态j的字符串，之后递推就好了。

# BZOJ2326

**问题**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2326](https://www.lydsy.com/JudgeOnline/problem.php?id=2326)

**题解**

一开始想要使用数学公式推导。


$$
\sum_{i=1}^nix^i=x\sum_{i=1}^nix^{i-1}=x(\sum_{i=1}^nx^i)'\\
=x\cdot (\frac{x^{n+1}-x}{x-1})'=\frac{nx^{n+2}-(n+1)x^{n+1}+x}{(x-1)^2}
$$


但是模数m不一定是素数，因此除法不能实现。当然如果m是不同的素数的乘积，那么可以分解因子后对因子计算出结果，之后用中国余数定理恢复。但是这里也不能保证m一定是不同素数的乘积，捂脸。

但是实际上，公式是非常简单的，所以用动态规划试一下：


$$
f(i)=10^{D(i)+1}f(i-1)+i
$$


这里是一个线性方程。那么我们用矩阵乘法来表示：


$$
\left( \begin{array}{ccc}
10^{D(i)+1} & 1 & 0 \\
0 & 1 & 1 \\
0 & 0 & 1
\end{array} \right)
\left( \begin{array}{c}
f(i-1)\\
i\\
1
\end{array} \right)
=
\left( \begin{array}{c}
f(i)\\
i+1\\
1
\end{array} \right)
$$


用矩阵快速幂，分段处理就好了。


# BZOJ1037

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1037](https://www.lydsy.com/JudgeOnline/problem.php?id=1037)

**题解**

这个问题有一个弱化的版本，不允许出现k个连续男孩或女孩的情况，问有多少种方案。这个问题比较简单，令$f(i,j,t)$表示排列i个男孩和j个女孩，使得不出现k个男孩或女孩连坐，且以t个男孩连坐作为结尾的情况下的方案数。同时令$g(i,j,t)$，表示排列i个男孩和j个女孩，使得不出现k个男孩或女孩连坐，且以t个女孩连坐作为结尾的情况下的方案数。计算所有结果，并最后加总就好了。

这个问题稍微有点绕。现在再简化成另外一个问题，给出一个排列，判断该排列是否出现某个连续段男孩与女孩数的差大于k。这可以通过动态规划实现。用同样的思路，我们记$f(i,j,a,b)$表示排列i个男孩和j个女孩，且该排列有效，且排列的所有的后缀中，男孩最多比女孩多a个，女孩最多比男孩多b个。之后统计即可。

# BZOJ1898

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1898](https://www.lydsy.com/JudgeOnline/problem.php?id=1898)

**题解**

题面比较复杂。记$f(i,j)$表示从起点出发，经过i秒后，落脚于j处的方案数。当鱼的位置都是固定的时候，可以发现存在一个复杂的动态规划关系，但好歹也是可以推导的。

再看看K特别的大，即动态规划需要迭代非常多轮，自然会想到用矩阵来做优化。

但是每个时刻食人鱼的位置也会变动该怎么办呢，题目给出了鱼的位置的周期仅为2，3，4，而对于三者的公倍数12来说，鱼一定会归位。因此容易想到分段DP的思路。

先将代表前面12秒的12个矩阵连乘，之后用快速幂进行迭代。最后会余下不超过12次的迭代，这时候暴力即可。

时间复杂度为$O(12\cdot n^3)$。

# BZOJ1260

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1260](https://www.lydsy.com/JudgeOnline/problem.php?id=1260)

**题解**

首先很容易发现连续的相同颜色可以合并。

之后定义$f(l,r,d)$表示绘制区间$[l,r]$所需要的最少步骤，且区间此时的默认色为$d$。很显然，在处理区间$[l,r]$时，点$l$可以第一个绘制。假设最优策略中我们将区间$[l,m]$绘制成点$l$所需的颜色，那么能够保证区间$[l+1,m]$上点的着色一定发生在该步骤之后（因为之前会浪费步骤）。

之后记忆化搜索就好了。好像别人的解法是$O(n^2)$的。。

# BZOJ1096

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1096](https://www.lydsy.com/JudgeOnline/problem.php?id=1096)

**题解**

很显然得用动态规划来解决。记$dp(i)$表示仅考虑前i个工厂，在第i个工厂建仓库的最小费用。可以得到递推公式：


$$
dp(i)=\min_{j<i}dp(j)+C(i)+\sum_{k=j+1}^{i-1}(X(i)-X(k))P(k)\\
=\min_{j<i}dp(j)+C(i)+X(i)\sum_{k=j+1}^{i-1}P(k)-\sum_{k=j+1}^{i-1}X(k)P(k)\\
=\min_{j<i}dp(j)+C(i)+X(i)(S(i-1)-S(j))-(F(i-1)-F(j))\\
=C(i)+X(i)S(i-1)-F(i-1)+\\
\min_{j<i}dp(j)-X(i)S(j)+F(j)
$$


很显然最后的min里面的内容可以用凸包技巧或斜率优化给优化掉。这里考虑斜率优化：


$$
dp(j)-X(i)S(j)+F(j)\leq dp(k)-X(i)S(k)+F(k)\\
\Rightarrow \frac{(dp(j)+F(j))-(dp(k)+F(k))}{S(j)-S(k)}\leq X(i)
$$



# BZOJ1057

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1057](https://www.lydsy.com/JudgeOnline/problem.php?id=1057)

**题解**

首先我们记R(i,j)表示网格(i,j)右侧最多可以扩展的长度，这个可以通过递推在O(nm)时间复杂度内计算完成。

记T(i,j)表示网格(i,j)上方可以扩展的长度，这里可以扩展还有一个条件，上方的网格的R必须大于等于当前网格的R。

同理定义B(i,j)表示网格(i,j)下方可以扩展的长度。

T(i,j)和B(i,j)都可以通过单调队列以$O(nm)$的时间复杂度完成。

记H(i,j)=T(i,j)+B(i,j)+1。

我们注意到一个最大的矩形，其左侧边缘网格中，记R最小的网格为(i,j)，那么我们可以保证矩形的长度为R(i,j)，且高度为H(i,j)，否则我们可以扩大矩形。

同理对于一个最大的正方形，其左侧边缘网格中，记R最小的网格为(i,j)，同时我们一定能得出H(i,j)是所有左侧边缘网格中最小的。而此时正方形的边长为min(R(i,j), H(i,j))，否则我们可以扩大正方形。

找最大的矩形和最大的正方形都可以通过遍历所有的网格得到。

总的时间复杂度为O(nm)。


# BZOJ1063

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1063](https://www.lydsy.com/JudgeOnline/problem.php?id=1063)

**题解**

首先题目保证了无环，并且在不连通的情况下不需要处理。因此我们实际上要处理的是以首都为根的树形结构。

很容易能想到树上DP，利用树上DP我们可以以$O(n)$的时间复杂度，计算最少需要的不便利值。

但是方案数如何统计呢？？？

首先我们知道轻重链剖分，是一个合法的方案（重链代表铁路），因此不便利值最多为$O(\log_2n)$。

之后我们可以就可以用DP来处理了。记$f(i,j,k)$表示以i为根，i与不多于j个子结点之间修了铁路，此时子树的不便利值不超过k的方案数。记$g(i,j,k)$表示以i为根，i与正好j个子结点之间修了铁路，此时子树的不便利值不超过k的方案数。可以推出公式：


$$
g(i,0,j)=\sum_{c}^{children(i)}f(c,2,j-1)\\
g(i,1,j)=\sum_{x}^{children(i)}f(x,1,j)\sum_{c\neq x}^{children(i)}f(c,2,j-1)\\
g(i,2,j)=\sum_{x\neq y}^{children(i)}f(x,1,j)f(y,1,j)\sum_{c\neq x,y}^{children(i)}f(c,2,j-1)\\
f(i,k,j)=\sum_{t=0}^kg(i,t,j)
$$


每个等式都可以以线性的时间复杂度计算完成，因此，总的时间复杂度为$O(n\log_2n)$。

# BZOJ1095

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1095](https://www.lydsy.com/JudgeOnline/problem.php?id=1095)

**题解**

好题。

首先，假如不考虑修改，我们可以直接用树上DP算出结果。但是由于有修改的存在，因此我们需要利用特殊的技术实现可修改动态规划。

输入是一颗树，我们可以求出其括号序列。比如一个跟结点带两个子结点的括号序列为`(0(1)(2))`。

选择两个顶点u，v，并找到其lca(u,v)=x，记d(u)表示u的深度。那么u与v之间的距离为$d(u)+d(v)-2d(x)$。我们可以这样理解括号序列，每遇到一个左括号，我们深度加1，遇到一个右括号，深度减少1，这样我们就可以将括号序列的每个元素映射为一个深度。这样我们实际上要找的是两个左括号，其在括号序列中的下标为l,r，且$l\leq r$。我们记M(l,r)表示括号序列的第l个元素到第r个元素中深度的最小值。那么l、r对应的结点的距离为$d(l)+d(r)-2M(l,r)$。

对于一个括号序列，我们可以将其均分为两部分，并分治处理。这样最大的好处就是可以使用线段树结构进行维护，从而支持$O(\log_2n)$时间复杂度的修改和查询。

在分治的时候，假设括号序列分为两部分A和B，我们希望能求$d(l)+d(r)-2M(l,r)$，有三种可能：

- l, r均属于A
- l, r均属于B
- l, r分别属于A、B

下面仅讨论第三种情况，我们知道l、r之间拥有最小深度的元素或者落在A中，或者落在B中，枚举两种情况求解就好了。记dlr表示一个块中的最大元素，dlSub表示一个块能提供的最大d(l)-2M(l..)，drSub表示一个块能提供的最大的d(r)-2M(..r)。那么在第三种下答案应该为：


$$
\max(A.dlr+B.drSub,A.dlSub+B.dlr)
$$


我们可以在pushUp的时候维护这些属性，整体的时间复杂度为$O(m\log_2n)$。



# BZOJ1025

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1025](https://www.lydsy.com/JudgeOnline/problem.php?id=1025)

**题解**

记$f(x,y,n)$表示将边长为x，y的矩形分给n个人的最优解。容易知道


$$
f(x,y,n)=\min(\\
\min_i(\max(f(x\cdot \frac{i}{n},y,i),f(x\cdot \frac{n-i}{n},y,n-i))),\\
\min_i(\max(f(x,y\cdot \frac{i}{n},i),f(x\cdot \frac{n-i}{n},y\cdot \frac{i}{n},n-i)))\\
)
$$


记$T(n)$表示执行形如$f(x,y,n)$所需要的时间。那么有


$$
T(n)=2nT(n-1)+1=\ldots\approx 2^n\cdot n!
$$


注意到


$$
\max(f(x\cdot \frac{i}{n},y,i),f(x\cdot \frac{n-i}{n},y,n-i))
=\max(f(x\cdot \frac{n-i}{n},y,n-i),f(x\cdot \frac{i}{n},y,i))
$$


我们在遍历$i$时，只需要遍历$1~\frac{n}{2}$。利用这个优化可以得到修正后的时间复杂度：


$$
T(n)=nT(n-1)+1\approx n!
$$


由于n只能取到10，而$10!=3628800$，因此足够通过题目了。

# BZOJ1029

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1029](https://www.lydsy.com/JudgeOnline/problem.php?id=1029)

**题解**

解法是贪心，我们先对t2按从小到大排序，之后按序处理所有建筑。

1. 如果还有多余的时间分配给当前建筑用于修复，那么就修复建筑。
2. 否则如果之前修复的建筑的中修复时间最长的建筑的修复时间多余当前建筑的修复时间，则取消对该建筑的修复，转而将时间分配给当前建筑。
3. 否则，就跳过当前建筑。

在处理完第i个建筑后，得到的策略是能修复最多建筑的策略中花费总时间最少的。如果单独将策略中前k个费用最小的建筑提出来，那么提出来的建筑会组成新的策略，是处理完前i个建筑后，共修复k个建筑且费用最小的策略。

# BZOJ1106

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1106](https://www.lydsy.com/JudgeOnline/problem.php?id=1106)

**题解**

记i的出现的左边坐标为l(i)，右边坐标为r(i)。

那么如果l(i)<l(j)<r(j)<r(i)，那么先消除j会让之后消除i少交换两次，而先消除i并不会减少j消除需要的交换次数。其余的值对没有明显先后要求。

我们可以对r(i)-l(i)的大小对所有的值对位置进行排序，从区间较小的开始消除就可以了。

# BZOJ1854

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1854](https://www.lydsy.com/JudgeOnline/problem.php?id=1854)

**题解**

一开始想的是二分图匹配，但是数据量太大，会TLE。
可以用并查集，如果一个联通块中存在环，则联通块必定可以全选，否则至少有一个结点可以选。

# BZOJ1854

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1854](https://www.lydsy.com/JudgeOnline/problem.php?id=1854)

**题解**

一开始想的是二分图匹配，但是数据量太大，会TLE。
可以用并查集，如果一个联通块中存在环，则联通块必定可以全选，否则至少有一个结点可以选。


# BZOJ1345

**题意**
[https://www.lydsy.com/JudgeOnline/problem.php?id=1345](https://www.lydsy.com/JudgeOnline/problem.php?id=1345)

**题解**

很显然最后留下的是序列中的最大值。选择最大值，处于最大值左侧区间中的最大值最后只能与全局最大值合并，对于右侧同理。这提示了我们可以以全局最大值为根建立一棵树，根的左节点是左侧区间最大值，右节点是右侧区间最大值。建树可以通过递归实现。而对于每个结点，其提供的费用是结点对应的值乘上结点的子节点数目，汇总所有结点的费用就是结果。

还有注意如果你利用递归建树，那么就需要用到一些平衡树结构，这样时间复杂度为$O(n\log_2n)$。但是实际上我们建出的是一个树堆，而建立树堆是可以通过单调栈实现的，这样时间复杂度就优化到了$O(n)$。

# BZOJ1816

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1816](https://www.lydsy.com/JudgeOnline/problem.php?id=1816)

**题解**

如果能组成k+1副牌，那么组成k副牌肯定不是难事。因此二分可以组成的牌数。

如果组成k组牌，需要x张joker，x满足x<=k且x<=m，那么我们就一定能组成k组牌。

# BZOJ1863

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1816](https://www.lydsy.com/JudgeOnline/problem.php?id=1816)

**题解**

对于分配给将军1的奖牌，我们称为特殊奖牌。假设我们我们造好了k种颜色，那么是不是存在一种符合需求的分配方案。这里可以用贪心的方法，对于将军i，如果i与n同奇偶性，则分配尽可能少的特殊奖牌，否则分配尽可能多的特殊奖牌。如果最后将军n得到了至少一个特殊奖牌，那么方案不存在，否则存在。

贪心也可以替换为动态规划，记f(i)、g(i)表示分配前i个人后，第i个人可以得到最多多少特殊奖牌以及最少多少特殊奖牌。这里不考虑第1个人和第n个人的邻接关系。很显然$f(i)=\min(a_1-g(i-1), a_i)$，$g(i)=\max(0, a_i-(k-a_1-(a_{i-1}-f(i-1))))$。如果$g(n)>0$那必定无解，否则有解。

由于方案的存在性随着k的增加递增，因此可以用二分法优化。

# BZOJ3293

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=3293](https://www.lydsy.com/JudgeOnline/problem.php?id=3293)

**题解**

咋一看，最小费用最大流。但是看看数据量，10w级别，再见。

这个问题可以转换为另外一个耳熟能详的形式。记$s_i$表示第i个人初始的金币，$x_i$表示第i个人给后面那个人的金币数，记t为平均金币。那么在进行交换后，第i个人持有的金币应该满足：


$$
s_i+x_{i-1}-x_i=t
$$


$x_1$一旦确认，其他几个未知变量也会对应确认。将所有的变量用$x_1$来表示，可以得出：


$$
x_i=\sum_{j=2}^i(s_j-t)+x_1
$$


我们要做的就是最小化式子


$$
\sum_{i=1}^n|x_i|=\sum_{i=1}^n|\sum_{j=2}^i(s_j-t)+x_1|=\sum_{i=1}^n|x_1-p_i|
$$


这个问题，可以转化为这样的形式：在x轴上放置n个点$p_1,p_2,\ldots ,p_n$，要求我们选择一个点，这个点到其它所有点距离和最小。

很显然无论在哪个位置，当$x_1$向中点靠近时，距离和会递减。因此我们可以选择$x_1$为中点即可。

# BZOJ1150

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1150](https://www.lydsy.com/JudgeOnline/problem.php?id=1150)

**题解**

比较奇怪的一道题。很容易发现电线只会连接邻近的两个点，我们可以根据点下标的奇偶性生成二分图，之后要求的实际上是这副二分图上的最小费用最大流。但是数据量有点大，费用流是过不了的。

仔细观察，可以发现这幅二分图是很特殊的，每个顶点的度都不超过2。我们知道费用流是不断找最短费用路进行增广，最短费用路在这里一定是交错路，我们可以动态维护所有的路径，再手动模拟增广，就可以在不使用费用流算法时达到费用流的效果。

我的方法的时间复杂度是$O(n\log_2n)$。记$d_t$表示第$t$与$t+1$的距离，那么从$i$到$j$的交错路的费用为$\sum_{k=i}^{j-1}(-1)^{k-i}d_k$，这个可以通过前缀和技术预先处理。之后我们将所有的路径维护在一个树集中，并维护一个左结点的可行点集合和右结点的可行点集合。每次我们增广后，都可能会向路径集合增加四条路径。

# BZOJ1053

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1053](https://www.lydsy.com/JudgeOnline/problem.php?id=1053)

**题解**

要计算一个数$x$的因子数，我们需要先利用算术基本定理将其分解为若干个不同的素数的幂的乘积。


$$
x=p_1^{c_1}\ldots p_k^{c_k}
$$


而$x$的因子数可以表示为$g(x)=\prod_{i=1}^k(1+c_i)$。

而我们要找的是小于等于N的因子数最多的x，如果有多个拥有相同因子数的数，那么需要取最小的。很显然要让因子数尽可能多，那么我们可以选择较小的几个素数组成x，实际上较小的素数可以获得的x也是较小的，这与我们目标吻合。

这里只需要小于等于23的所有素数即可，之后深搜暴力，时间复杂度这种东西不重要。

# BZOJ1112

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1112](https://www.lydsy.com/JudgeOnline/problem.php?id=1112)

**题解**

枚举所有可能的区间，共n-k+1种。之后对于每个区间，我们将其中的高度从小到大排序，而在最终高度取到区间高度的中位数时费用最小。

因此用平衡树维护一下区间，之后找一下中位数就好了。
