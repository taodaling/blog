---
categories: problems
layout: post
---

- Table
{:toc}
# CF1175D

**题意**
[https://codeforces.com/contest/1175/problem/D](https://codeforces.com/contest/1175/problem/D)

**题解**

记S(i)=a(i)+a(i+1)+...+a(n)。分别记最优解的划分下，第i个分块的第一个元素下标为f(i)。那么问题下面式子在最优解下一定取最大值。


$$
1\cdot (S(f(1))-S(f(2)))+2\cdot (S(f(2)) - S(f(3)))\\+\ldots + (n-1)(S(f(n-1))-S(f(n)))+nS(f(n))\\
=\sum_{i=1}^nS(f(i))
$$


由于f(1)一定是取到1，我们可以将S(2),S(3),...,S(n)排序后取前面最大的k-1个的和加上S(1)就是结果。

# CF1175F

**题意**
[https://codeforces.com/contest/1175/problem/F](https://codeforces.com/contest/1175/problem/F)

**题解**

我们可以逐个统计每个有效子排列。寻找所有1出现的位置，很显然一个有效排列必定包含且只保护其中之一的1。

我们维护一个函数R，R(i)表示形如a(i),a(i+1),...的无重复元素的最长序列的长度。

之后我们遍历每个1出现的位置i。之后包含i的序列的右边界只可能为j=i,i+1,..., i+R(i)-1。之后假设序列中最大的元素落在i的右边，因此我们只需要知道m=max(a(i),a(i+1),...,a(j))，而序列有效的必要条件是长度等于m，因此我们可以推出左边界k=j-m+1。之后只需要快速判断子序列a(k),...,a(j)是否是一个有效序列就可以了。判断的方法很简单，首先要求R(k)>=max，其次min(a(k),...,a(j))=1且max(a(k),...,a(j))=m。

对于最大元落在左边的情况，只要翻转序列后重新用上面过程处理一次就可以了。

利用线段树就可以在O(nlogn)的时间复杂度内解决。

# BZOJ1345

**题意**
[https://www.lydsy.com/JudgeOnline/problem.php?id=1345](https://www.lydsy.com/JudgeOnline/problem.php?id=1345)

**题解**

很显然最后留下的是序列中的最大值。选择最大值，处于最大值左侧区间中的最大值最后只能与全局最大值合并，对于右侧同理。这提示了我们可以以全局最大值为根建立一棵树，根的左节点是左侧区间最大值，右节点是右侧区间最大值。建树可以通过递归实现。而对于每个结点，其提供的费用是结点对应的值乘上结点的子节点数目，汇总所有结点的费用就是结果。

还有注意如果你利用递归建树，那么就需要用到一些平衡树结构，这样时间复杂度为$O(n\log_2n)$。但是实际上我们建出的是一个树堆，而建立树堆是可以通过单调栈实现的，这样时间复杂度就优化到了$O(n)$。

# BZOJ1816

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1816](https://www.lydsy.com/JudgeOnline/problem.php?id=1816)

**题解**

如果能组成k+1副牌，那么组成k副牌肯定不是难事。因此二分可以组成的牌数。

如果组成k组牌，需要x张joker，x满足x<=k且x<=m，那么我们就一定能组成k组牌。

# BZOJ1863

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1816](https://www.lydsy.com/JudgeOnline/problem.php?id=1816)

**题解**

对于分配给将军1的奖牌，我们称为特殊奖牌。假设我们我们造好了k种颜色，那么是不是存在一种符合需求的分配方案。这里可以用贪心的方法，对于将军i，如果i与n同奇偶性，则分配尽可能少的特殊奖牌，否则分配尽可能多的特殊奖牌。如果最后将军n得到了至少一个特殊奖牌，那么方案不存在，否则存在。

贪心也可以替换为动态规划，记f(i)、g(i)表示分配前i个人后，第i个人可以得到最多多少特殊奖牌以及最少多少特殊奖牌。这里不考虑第1个人和第n个人的邻接关系。很显然$f(i)=\min(a_1-g(i-1), a_i)$，$g(i)=\max(0, a_i-(k-a_1-(a_{i-1}-f(i-1))))$。如果$g(n)>0$那必定无解，否则有解。

由于方案的存在性随着k的增加递增，因此可以用二分法优化。

# BZOJ3293

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=3293](https://www.lydsy.com/JudgeOnline/problem.php?id=3293)

**题解**

咋一看，最小费用最大流。但是看看数据量，10w级别，再见。

这个问题可以转换为另外一个耳熟能详的形式。记$s_i$表示第i个人初始的金币，$x_i$表示第i个人给后面那个人的金币数，记t为平均金币。那么在进行交换后，第i个人持有的金币应该满足：


$$
s_i+x_{i-1}-x_i=t
$$


$x_1$一旦确认，其他几个未知变量也会对应确认。将所有的变量用$x_1$来表示，可以得出：


$$
x_i=\sum_{j=2}^i(s_j-t)+x_1
$$


我们要做的就是最小化式子


$$
\sum_{i=1}^n|x_i|=\sum_{i=1}^n|\sum_{j=2}^i(s_j-t)+x_1|=\sum_{i=1}^n|x_1-p_i|
$$


这个问题，可以转化为这样的形式：在x轴上放置n个点$p_1,p_2,\ldots ,p_n$，要求我们选择一个点，这个点到其它所有点距离和最小。

很显然无论在哪个未知，当$x_1$向中点靠近时，距离和会递减。因此我们可以选择$x_1$为中点即可。