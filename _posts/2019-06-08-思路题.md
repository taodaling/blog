---
categories: problems
layout: post
---

- Table
{:toc}
# CF1175D

**题意：**
[https://codeforces.com/contest/1175/problem/D](https://codeforces.com/contest/1175/problem/D)

**题解：**

记S(i)=a(i)+a(i+1)+...+a(n)。分别记最优解的划分下，第i个分块的第一个元素下标为f(i)。那么问题下面式子在最优解下一定取最大值。


$$
1\cdot (S(f(1))-S(f(2)))+2\cdot (S(f(2)) - S(f(3)))\\+\ldots + (n-1)(S(f(n-1))-S(f(n)))+nS(f(n))\\
=\sum_{i=1}^nS(f(i))
$$


由于f(1)一定是取到1，我们可以将S(2),S(3),...,S(n)排序后取前面最大的k-1个的和加上S(1)就是结果。

# CF1175F

**题意：**
[https://codeforces.com/contest/1175/problem/F](https://codeforces.com/contest/1175/problem/F)

**题解：**

我们可以逐个统计每个有效子排列。寻找所有1出现的位置，很显然一个有效排列必定包含且只保护其中之一的1。

我们维护一个函数R，R(i)表示形如a(i),a(i+1),...的无重复元素的最长序列的长度。

之后我们遍历每个1出现的位置i。之后包含i的序列的右边界只可能为j=i,i+1,..., i+R(i)-1。之后假设序列中最大的元素落在i的右边，因此我们只需要知道m=max(a(i),a(i+1),...,a(j))，而序列有效的必要条件是长度等于m，因此我们可以推出左边界k=j-m+1。之后只需要快速判断子序列a(k),...,a(j)是否是一个有效序列就可以了。判断的方法很简单，首先要求R(k)>=max，其次min(a(k),...,a(j))=1且max(a(k),...,a(j))=m。

对于最大元落在左边的情况，只要翻转序列后重新用上面过程处理一次就可以了。

利用线段树就可以在O(nlogn)的时间复杂度内解决。

# BZOJ1345

**题意：**
[https://www.lydsy.com/JudgeOnline/problem.php?id=1345](https://www.lydsy.com/JudgeOnline/problem.php?id=1345)

**题解：**

很显然最后留下的是序列中的最大值。选择最大值，处于最大值左侧区间中的最大值最后只能与全局最大值合并，对于右侧同理。这提示了我们可以以全局最大值为根建立一棵树，根的左节点是左侧区间最大值，右节点是右侧区间最大值。建树可以通过递归实现。而对于每个结点，其提供的费用是结点对应的值乘上结点的子节点数目，汇总所有结点的费用就是结果。

还有注意如果你利用递归建树，那么就需要用到一些平衡树结构，这样时间复杂度为$O(n\log_2n)$。但是实际上我们建出的是一个树堆，而建立树堆是可以通过单调栈实现的，这样时间复杂度就优化到了$O(n)$。