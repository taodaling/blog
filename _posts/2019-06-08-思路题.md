---
categories: problems
layout: post
---

- Table
{:toc}
# CF1175D

**题意**
[https://codeforces.com/contest/1175/problem/D](https://codeforces.com/contest/1175/problem/D)

**题解**

记S(i)=a(i)+a(i+1)+...+a(n)。分别记最优解的划分下，第i个分块的第一个元素下标为f(i)。那么问题下面式子在最优解下一定取最大值。


$$
1\cdot (S(f(1))-S(f(2)))+2\cdot (S(f(2)) - S(f(3)))\\+\ldots + (n-1)(S(f(n-1))-S(f(n)))+nS(f(n))\\
=\sum_{i=1}^nS(f(i))
$$


由于f(1)一定是取到1，我们可以将S(2),S(3),...,S(n)排序后取前面最大的k-1个的和加上S(1)就是结果。

# CF1175F

**题意**
[https://codeforces.com/contest/1175/problem/F](https://codeforces.com/contest/1175/problem/F)

**题解**

我们可以逐个统计每个有效子排列。寻找所有1出现的位置，很显然一个有效排列必定包含且只保护其中之一的1。

我们维护一个函数R，R(i)表示形如a(i),a(i+1),...的无重复元素的最长序列的长度。

之后我们遍历每个1出现的位置i。之后包含i的序列的右边界只可能为j=i,i+1,..., i+R(i)-1。之后假设序列中最大的元素落在i的右边，因此我们只需要知道m=max(a(i),a(i+1),...,a(j))，而序列有效的必要条件是长度等于m，因此我们可以推出左边界k=j-m+1。之后只需要快速判断子序列a(k),...,a(j)是否是一个有效序列就可以了。判断的方法很简单，首先要求R(k)>=max，其次min(a(k),...,a(j))=1且max(a(k),...,a(j))=m。

对于最大元落在左边的情况，只要翻转序列后重新用上面过程处理一次就可以了。

利用线段树就可以在O(nlogn)的时间复杂度内解决。

# BZOJ1345

**题意**
[https://www.lydsy.com/JudgeOnline/problem.php?id=1345](https://www.lydsy.com/JudgeOnline/problem.php?id=1345)

**题解**

很显然最后留下的是序列中的最大值。选择最大值，处于最大值左侧区间中的最大值最后只能与全局最大值合并，对于右侧同理。这提示了我们可以以全局最大值为根建立一棵树，根的左节点是左侧区间最大值，右节点是右侧区间最大值。建树可以通过递归实现。而对于每个结点，其提供的费用是结点对应的值乘上结点的子节点数目，汇总所有结点的费用就是结果。

还有注意如果你利用递归建树，那么就需要用到一些平衡树结构，这样时间复杂度为$O(n\log_2n)$。但是实际上我们建出的是一个树堆，而建立树堆是可以通过单调栈实现的，这样时间复杂度就优化到了$O(n)$。

# BZOJ1816

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1816](https://www.lydsy.com/JudgeOnline/problem.php?id=1816)

**题解**

如果能组成k+1副牌，那么组成k副牌肯定不是难事。因此二分可以组成的牌数。

如果组成k组牌，需要x张joker，x满足x<=k且x<=m，那么我们就一定能组成k组牌。

# BZOJ1863

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1816](https://www.lydsy.com/JudgeOnline/problem.php?id=1816)

**题解**

对于分配给将军1的奖牌，我们称为特殊奖牌。假设我们我们造好了k种颜色，那么是不是存在一种符合需求的分配方案。这里可以用贪心的方法，对于将军i，如果i与n同奇偶性，则分配尽可能少的特殊奖牌，否则分配尽可能多的特殊奖牌。如果最后将军n得到了至少一个特殊奖牌，那么方案不存在，否则存在。

贪心也可以替换为动态规划，记f(i)、g(i)表示分配前i个人后，第i个人可以得到最多多少特殊奖牌以及最少多少特殊奖牌。这里不考虑第1个人和第n个人的邻接关系。很显然$f(i)=\min(a_1-g(i-1), a_i)$，$g(i)=\max(0, a_i-(k-a_1-(a_{i-1}-f(i-1))))$。如果$g(n)>0$那必定无解，否则有解。

由于方案的存在性随着k的增加递增，因此可以用二分法优化。

# BZOJ3293

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=3293](https://www.lydsy.com/JudgeOnline/problem.php?id=3293)

**题解**

咋一看，最小费用最大流。但是看看数据量，10w级别，再见。

这个问题可以转换为另外一个耳熟能详的形式。记$s_i$表示第i个人初始的金币，$x_i$表示第i个人给后面那个人的金币数，记t为平均金币。那么在进行交换后，第i个人持有的金币应该满足：


$$
s_i+x_{i-1}-x_i=t
$$


$x_1$一旦确认，其他几个未知变量也会对应确认。将所有的变量用$x_1$来表示，可以得出：


$$
x_i=\sum_{j=2}^i(s_j-t)+x_1
$$


我们要做的就是最小化式子


$$
\sum_{i=1}^n|x_i|=\sum_{i=1}^n|\sum_{j=2}^i(s_j-t)+x_1|=\sum_{i=1}^n|x_1-p_i|
$$


这个问题，可以转化为这样的形式：在x轴上放置n个点$p_1,p_2,\ldots ,p_n$，要求我们选择一个点，这个点到其它所有点距离和最小。

很显然无论在哪个位置，当$x_1$向中点靠近时，距离和会递减。因此我们可以选择$x_1$为中点即可。

# BZOJ1150

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1150](https://www.lydsy.com/JudgeOnline/problem.php?id=1150)

**题解**

比较奇怪的一道题。很容易发现电线只会连接邻近的两个点，我们可以根据点下标的奇偶性生成二分图，之后要求的实际上是这副二分图上的最小费用最大流。但是数据量有点大，费用流是过不了的。

仔细观察，可以发现这幅二分图是很特殊的，每个顶点的度都不超过2。我们知道费用流是不断找最短费用路进行增广，最短费用路在这里一定是交错路，我们可以动态维护所有的路径，再手动模拟增广，就可以在不使用费用流算法时达到费用流的效果。

我的方法的时间复杂度是$O(n\log_2n)$。记$d_t$表示第$t$与$t+1$的距离，那么从$i$到$j$的交错路的费用为$\sum_{k=i}^{j-1}(-1)^{k-i}d_k$，这个可以通过前缀和技术预先处理。之后我们将所有的路径维护在一个树集中，并维护一个左结点的可行点集合和右结点的可行点集合。每次我们增广后，都可能会向路径集合增加四条路径。

# BZOJ1053

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1053](https://www.lydsy.com/JudgeOnline/problem.php?id=1053)

**题解**

要计算一个数$x$的因子数，我们需要先利用算术基本定理将其分解为若干个不同的素数的幂的乘积。


$$
x=p_1^{c_1}\ldots p_k^{c_k}
$$


而$x$的因子数可以表示为$g(x)=\prod_{i=1}^k(1+c_i)$。

而我们要找的是小于等于N的因子数最多的x，如果有多个拥有相同因子数的数，那么需要取最小的。很显然要让因子数尽可能多，那么我们可以选择较小的几个素数组成x，实际上较小的素数可以获得的x也是较小的，这与我们目标吻合。

这里只需要小于等于23的所有素数即可，之后深搜暴力，时间复杂度这种东西不重要。

# BZOJ1112

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1112](https://www.lydsy.com/JudgeOnline/problem.php?id=1112)

**题解**

枚举所有可能的区间，共n-k+1种。之后对于每个区间，我们将其中的高度从小到大排序，而在最终高度取到区间高度的中位数时费用最小。

因此用平衡树维护一下区间，之后找一下中位数就好了。

# TIMUS1032

**题意**

[http://acm.timus.ru/problem.aspx?space=1&num=1032](http://acm.timus.ru/problem.aspx?space=1&num=1032)

**题解**

组合数学书上一道用于介绍鸽巢定理的例题。如果以前没看过，我应该也做不出来。

首先给出n个值a1,a1+a2,...,a1+a2+...+an，如果其中有一个模n为0，那么就找到了解。否则由于有n个值落在1~n-1之间，因此至少有两个数有相同值，找到这两个数，其中一个必定是另外一个的前缀，从较长的序列中移除较短的序列那部分就找到解了。

# BZOJ1025

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1025](https://www.lydsy.com/JudgeOnline/problem.php?id=1025)

**题解**

记$f(x,y,n)$表示将边长为x，y的矩形分给n个人的最优解。容易知道


$$
f(x,y,n)=\min(\\
\min_i(\max(f(x\cdot \frac{i}{n},y,i),f(x\cdot \frac{n-i}{n},y,n-i))),\\
\min_i(\max(f(x,y\cdot \frac{i}{n},i),f(x\cdot \frac{n-i}{n},y\cdot \frac{i}{n},n-i)))\\
)
$$


记$T(n)$表示执行形如$f(x,y,n)$所需要的时间。那么有


$$
T(n)=2nT(n-1)+1=\ldots\approx 2^n\cdot n!
$$


注意到


$$
\max(f(x\cdot \frac{i}{n},y,i),f(x\cdot \frac{n-i}{n},y,n-i))
=\max(f(x\cdot \frac{n-i}{n},y,n-i),f(x\cdot \frac{i}{n},y,i))
$$


我们在遍历$i$时，只需要遍历$1~\frac{n}{2}$。利用这个优化可以得到修正后的时间复杂度：


$$
T(n)=nT(n-1)+1\approx n!
$$


由于n只能取到10，而$10!=3628800$，因此足够通过题目了。

# BZOJ1029

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1029](https://www.lydsy.com/JudgeOnline/problem.php?id=1029)

**题解**

解法是贪心，我们先对t2按从小到大排序，之后按序处理所有建筑。

1. 如果还有多余的时间分配给当前建筑用于修复，那么就修复建筑。
2. 否则如果之前修复的建筑的中修复时间最长的建筑的修复时间多余当前建筑的修复时间，则取消对该建筑的修复，转而将时间分配给当前建筑。
3. 否则，就跳过当前建筑。

在处理完第i个建筑后，得到的策略是能修复最多建筑的策略中花费总时间最少的。如果单独将策略中前k个费用最小的建筑提出来，那么提出来的建筑会组成新的策略，是处理完前i个建筑后，共修复k个建筑且费用最小的策略。