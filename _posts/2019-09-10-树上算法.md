---
categories: algorithm
layout: post
---

- Table
{:toc}

# dsu on tree

树上DP有很多种形式，下面给出一个树上DP的题目：

n个结点，每个结点有一个颜色，要求我们计算每个结点作为根的子树中不同的颜色数目。

这个问题，你可以通过哈希表以及启发合并来实现，这样的时间复杂度就为$O(n\log_2{n})$。

当然由于哈希表的常数和消耗的空间会略大，你可以使用莫队算法，这样的时间复杂度为$O(n\sqrt{n})$。

还有一种就是使用一种树上启发合并的方式，其起源于Codeforce的一篇博客[Sack (dsu on tree)](<https://codeforces.com/blog/entry/44351>)。Dsu on tree算法适用于有根树的所有子树的DP。下面说一下流程：

首先我们要对有根树进行轻重链剖分。

之后我们对树进行深度优先搜索，计算DP值。计算DP值分成三步，对由轻链连接的子树递归调用当前过程，但是要清除它们带来的影响（我们会维护一个全局的数组，记录子树的状态，在这个问题中就是一个布尔数组，记录颜色是否出现，这里消除影响的意思是将数组恢复到对这些子树调用递归过程之前的状态）。之后我们对重链边连接的子树进行递归调用，但是保留它们的状态，并用在当前结点的状态计算上。之后分别对轻链连接的子树调用一次递归过程，但是这个过程既不是为了计算子树的DP，也不要求清除状态，但是要把原来的状态附加到现有的状态上。

因此我们可以将DFS分成两种，第一种我们称为动态规划流程，其目的是为了利用子树的状态计算当前结点的DP值，我们称为计算过程；第二种是不计算自己的DP值，而只是贡献自己的状态信息，我们称为贡献流程。

而我们会为每个结点调用一次计算流程，会为每条轻链连接的子树调用一次贡献流程。当然你可能会问，为什么不在计算流程中把计算结果保存下来呢，这样只需要合并一下，而不需要使用慢的多的贡献流程。原因是这样的，味为每个结点都保存状态，考虑所有的结点仅于根结点有一条连接的边，那么我们在计算跟结点的状态的同时，还需要保存(n-1)份状态信息，而每份状态信息的大小都是$\|C\|$，C是可能的颜色的集合。当然你会说我们可以使用哈希表来节省内存，但是使用哈希表的话性能会大幅度恶化，而且同样也会占用大量的空间，这样对于时间和空间限制比较严格的情况下是很难通过的。

下面聊聊时间复杂度。在我们上面的问题中，计算流程的时间复杂度为$O(n)$，而贡献流程，每个结点最多会参加与自己到根结点的路径上轻边数目相同次数的贡献流程（在任意一颗大小为$n$的树中，每条一个端点为根结点的路径最多有$\log_2{n}$个轻边），而每次参加的时间复杂度为$O(1)$，共$n$个结点，因此贡献流程的总时间复杂度为$O(n\log_2{n})$。轻重链剖分的时间复杂度为$O(n)$，因此总的时间复杂度为$O(n\log_2{n})$。

# 边分治

边分治类似于点分治，区别在于点分治找的是重心点，而边分治找的是重心边。

树T的重心边是指这样一条边e，使得删除e后得到的两个连通块大小的最大值最小，我们记作$effect(e)$。

由于对于菊花图，任何边得到的连通分块的大小都是1和n-1，因此边分治不能得到很好的效果。我们可以插入一些假的顶点，使得每个顶点下只挂两条边（不包括与父亲相连的边）。

现在在已知树中每个顶点的度都不超过3的前提下，我们证明假如e是树T的重心，且T的大小为n，那么$effect(e)\leq \frac{2}{3}n$。实际上假设e是树T的重心，连接两个顶点u、v。不妨认u所在连通块的大小大于$\frac{2}{3}n$。考虑到u至多还能连接两条边，因此至少有一条边e'的另外一端所在连通块的大小能达到$\frac{1}{3}n$。e'是比e更好的重心。

边分治的优势在于边连接的一定是父子，因此可以将树分成两部分，包含根的记作R，不含根的记作B。而R中任意顶点x，与B中所有顶点的LCA是相同的，因此可以提前计算并用于后面的处理。

# 边分树

考虑要处理这样的问题，有两棵树T1和T2，对于某个不同顶点对u、v，定义它们的距离为：


$$
dist(u,v)=dist_1(u,v)+dist_2(u,v)
$$


其中$dist_1$为第一颗树上的距离，$dist_2$是第二颗树上的距离。这个问题可以通过边分数来消除第一颗树上LCA带来的影响，之后为第二颗树建立虚树，可以消除第二颗树上LCA的影响，之后就成为一般的DFS统计最远顶对问题，时间复杂度是$O(n(\log_2n)^2)$。

可以用另外一种叫做边分树的技术来优化。我们为每个顶点额外维护一个二叉树，初始时只有一个顶点。在对第一个树进行边分治时，删除边重心后，会得到两个连通块，记作a、b。我们将a上的顶点二叉树深度最大的叶结点下加上一个左孩子，为b上顶点二叉树深度最大的叶结点下加上一个右孩子。完成了边分治后，每个顶点所对应的二叉树实际上都是一条弯曲的链表（长度为$O(\log_2n)$），之后我们在第二颗树上进行DP操作。对于每个顶点，当递归处理完一个子结点时，就将它的二叉树和自己的二叉树进行合并，合并的时候对于处于二叉树左右不同分支的顶点，可以统计其贡献。这样就能在$O(n\log_2n)$的时空复杂度下解决问题。

# 树上最远点对

**命题1：如果树上边权非负，对于两个顶点集合A、B，设A中最远点对为$a_1,a_2$，而B中最远点对为$b_1,b_2$，那么在A、B合并后，其中最远点对一定可以从$\{a_1,a_2,b_1,b_2\}$中得到。**

**命题2：如果树上边权非负，并定义树上距离为路径距离加上两点的点权，对于两个顶点集合A、B，设A中最远点对为$a_1,a_2$，而B中最远点对为$b_1,b_2$，那么在A、B合并后，其中最远点对一定可以从$\{a_1,a_2,b_1,b_2\}$中得到。**

**命题3：如果树上边权非负，那么以任意顶点为根，从最深的顶点中选择一个顶点，这个顶点一定是某个树上直径的端点。**

# 树上中点（边）

如果一颗树的直径为$D$。

如果$D$是偶数，那么树上一定存在一个顶点，到其它所有顶点的距离不超过$D/2$，这个顶点称为树的中点。

如果$D$是奇数，那么树上一定存在一条边，使得其它所有顶点到边的某一端的顶点的距离不超过$(D-1)/2$，这条边称为树的中边。

任意取一条树上直径，如果直径长度为偶数，那么直径中心的顶点就是树的中点，假如直径长度为奇数，那么直径中心的边就是树的中边。

如果树上有多个直径，那么树上所有直径都一定过中点（中边）。

# 相邻元素最少交换次数

现在给定等长且含有相同数量1的两个二进制序列，记作A、B。

我们可以对序列A做如下操作，交换两个相邻的位的值。问最少需要多少次操作，可以将A转换为B。

譬如：

A=0110

B=1001

很显然将第一位和第二位交换，将第三位和第四位交换就可以得到想要的结果，且任意可能的方案都至少要进行两次交换，因此答案是2。

这个问题的解法非常简单，我们记A中1出现的位置从小到大为
$$
a_1,a_2,\ldots,a_k
$$
，B中1出现的位置从小到大为
$$
b_1,b_2,\ldots,b_k
$$
。可以证明A中原本位于$a_i$的1会最终被放置在$b_i$。

事实上，我们永远不会交换两个相同的值，因此$a_{i+1}$永远不会交换到$a_1$之前。因此我们可以直接证明$a_1$与$b_1$相匹配（这里匹配的意思是A中原本$a_1$处的1最终会移动到$b_1$）。同理可以证明其它1的匹配。

因此答案为：
$$
\sum_{i=1}^k|a_i-b_i|
$$
。



这个问题可以在树上进行定义。对于一颗树，我们为顶点的初始值赋值为1或0，接下来，每个顶点还有一个目标值。我们可以交换两个之间存在一条边的顶点的值，我们的目的是使得最终树上每个顶点的值和目标值相同，并要求步骤数最少。

很显然，如果目标值中的1和初始值中的1的数目不同（简单说目标值的和和初始值的和不同），那么问题是无解的。下面考虑相同的情况。

对于树中的任意一条边，该边会将树分成两个连通块。我们称连通块的不平衡度为连通块中值的和与目标值的和的差的绝对值。很显然删除边e后，两个连通块的不平衡度是相同的。记$f(e)$为树失去边e后形成的连通块的不平衡度，称为边两端不平衡度。
很显然式子
$$
\sum_{e\in E}f(e)
$$
是结果的一个下界。我们可以这样理解这个式子，由于删除$e$后，两个连通块的不平衡度均为$f(e)$，那么必定至少有$f(e)$个1从一个连通块中经过边$e$转移到另外一个连通块中。

下面我们设计一个算法，可以在下界次操作中完成转换。

首先我们从图中删除所有两端不平衡度为0的边，仅保留不平衡度非0的边。假如连通块大小都为1，这意味着没有边存在，即所有顶点的值和目标值是相同的，这时候我们自然可以在下界次（0）操作中完成转换。

利用反证法，假设不存在这样的边e，使得e的两端顶点的值一个为1，一个为0，且为1的顶点所在连通块的值和减去目标值和是正数。任意考虑一个大小非1的连通块。连通块一定是树，因此一定存在度数为1的叶子结点$v$。叶子结点的值和目标值必定不同，我们不妨设叶子结点的值为0，目标值为1。之后考虑$v$的父结点$u$，很显然父结点一定也是0（否则与假设相悖）。利用归纳法我们可以推广证明对于任意高度的树，树中的值必定都是相同的。当然这样的话，就意味着连通块的不平衡度非0，这是不可能的。因此假设不成立，存在这样的一条边，两端顶点值不同且1所在的连通块的值减去目标值和是正数。

我们将上面提到的边两端的顶点的值交换，发现除了$e$两端不平衡度减少了1以外，其余边的不平衡度都没有发生变化。

而上面的操作最多发生下界次，因此就证明了存在一种方案可以在下界次交换中使得每个顶点的值和目标值是相同的。

# 最小子树统计

对于一株树
$$
T=(V,E)
$$
，对于任意$V$的子集$S$，包含$S$的顶点最少的子树的顶点数目记作$f(S)$。

要求：


$$
\sum_{S\subset V}f(S)
$$


这个问题站在顶点的角度看，是很难解决的。但是如果站在边的角度看问题就很简单了，记
$$
g(S)
$$
表示包含$S$的顶点最少的子树中的边集。那么我们可以推出：


$$
\sum_{S\subset V}f(S)\\
=\sum_{S\subset V}(\sum_{e\in g(S)}1+1)\\
=\sum_{S\subset V}\sum_{e\in g(S)}1+2^{|V|}\\
=\sum_{e\in E}\sum_{S\subset V}[e\in g(S)]+2^{|V|}
$$


其中
$$
[e\in g(S)]
$$
为1，当且仅当$S$中包含从$T$中删除$e$后得到的两个子树中顶点至少一个。因此我们利用容斥，从所有可能的$V$的子集中删除仅覆盖$e$一侧顶点的集合数即可得到，记$L(x)$表示边左侧子树大小，$R(x)$表示边右侧子树大小，那么结果就是：


$$
\sum_{S\subset V}[e\in g(S)]=2^{|V|}-2^{L(e)}-2^{R(e)}+2^{0}
$$


因此最终结果可以表示为：


$$
\sum_{S\subset V}f(S)=\sum_{e\in E}\sum_{S\subset V}[e\in g(S)]+2^{|V|}\\
=\sum_{e\in E}(2^{|V|}-2^{L(e)}-2^{R(e)}+2^{0})+2^{|V|}
$$


这个可以通过dfs线性统计出来。

# LUOGU4565

**题意**

[https://www.luogu.org/problem/P4565](https://www.luogu.org/problem/P4565)

**题解**

首先用边分治将树1分为两块，包含根的记作R，不含根的记作B。给R中顶点上黑色，B中顶点上白色，之后根据树2建立虚树。

记一个顶点x在树中到树根的路径的总边权记作prefix(x)，记B中深度最浅的顶点为y。

那么黑色顶点a的点权为：weight(a)=prefix(a)-prefix(lca(a, y))

白色顶点b的点权为：weight(b)=prefix(b)

建立好虚树后，我们要找到虚树上距离最远的一对黑白点，其中虚树中a,b距离的定义为：$weight(a)+weight(b)-weight(lca(a,b))$。这个问题dfs就能解决了。

总的时间复杂度为$O(n(\log_2n)^2)$。

# LUOGU4220

**题意**

[https://www.luogu.org/problem/P4220](https://www.luogu.org/problem/P4220)

**题解**

我们先理解题目要我们求的到底是个啥，定义$dist(i,j)=dist_1(i,j)+dist_2(i,j)+dist_3(i,j)$，其中$dist_k(i,j)$表示在第k树中i、j的距离。可以进行简化：


$$
\max\quad dist(i,j)=\sum_{k=1}^3dist_k(i,j)=\sum_{k=1}^3depth_k(i)+depth_k(j)-2\cdot depth_k(L_k(i,j))
$$


这里$depth_k(i)$表示的是i在第k颗树中的深度，$L_k(i,j)$表示i、j在第k个树中的LCA。我们记$depth(i)=depth_1(i)+depth_2(i)+depth_3(i)$，之后公式为：


$$
\max\quad dist(i,j)=depth(i)+depth(j)-2depth_1(L_1(i,j))-2depth_2(L_2(i,j))-2depth_3(L_3(i,j))
$$


利用边分治处理第一颗树，删除边重心后，得到两个连通块，包含根的记作A，不含根的记作B。将A中顶点全部染成白色，B中染成黑色，记边的。记录$w_A(i)=depth(i)-2depth_1(L_1(i,B))$，$w_B(i)=depth(i)$。之后为这些点按照第二颗树的结构建立虚树。现在我们要求的是：


$$
\max \quad dist(i,j)=w_A(i)+w_B(j)-2depth_2(L_2(i,j))-2depth_3(L_3(i,j))
$$


在虚数上处理第t个顶点时，由于LCA一定是t，因此可以认为$2depth_2(L_2(i,j))$是常数。此时我们要计算的是


$$
\max \quad dist'(i,j)=w_A(i)+w_B(j)-2depth_3(L_3(i,j))
$$


这里需要用到一个在树上所有边非负的时候成立的命题。

**命题1：如果树上边权非负，对于两个顶点集合A、B，设A中最远点对为$a_1,a_2$，而B中最远点对为$b_1,b_2$，那么在A、B合并后，其中最远点对一定可以从$\{a_1,a_2,b_1,b_2\}$中得到。**

我们可以继续扩展这个命题得到：

**命题2：如果树上边权非负，并定义树上距离为路径距离加上两点的点权，对于两个顶点集合A、B，设A中最远点对为$a_1,a_2$，而B中最远点对为$b_1,b_2$，那么在A、B合并后，其中最远点对一定可以从$\{a_1,a_2,b_1,b_2\}$中得到。**

转换公式令其得到符合命题2：


$$
\max \quad dist'(i,j)=(w_A(i)-depth_3(i))+(w_B(j)-depth_3(j))+dist_3(i,j)
$$

因此在递归处理虚树的同时维护子树dist'最大的白点对、黑点对，在向上贡献的时候合并到父结点的信息中。

# Atcoder AGC001C

**题意**

[https://atcoder.jp/contests/agc001/tasks/agc001_c](https://atcoder.jp/contests/agc001/tasks/agc001_c)

给定一颗树，删除最少的顶点，保证剩余顶点组成一颗直径不超过k的树的前提下，要求树尽可能大。

**题解**

先学习了一下树的中点和中边的概念。

如果原树半径就小于等于k，那么结果就是原树。

否则，那么结果的半径一定是k。如果k是偶数，那么可以寻找结果的中点，如果找到，那么结果一定是距离中点小于k/2的顶点集合（很显然这是一个满足条件的树，并且结果是这类树构成集合的一个元素）。

如果k是奇数，那么对应的求结果中的中边即可。

时间复杂度为$O(n^2)$。

# 长链剖分

长链剖分可以用于解决一些树上与高度相关的DP问题。

长链剖分类似于dsu on tree。

首先我们要处理出一颗树中的长链。记Len(x)表示顶点x到以x为根的子树中最深的叶节点的距离。对于任意结点x，设y为x直接子结点中Len最大的（如果有多个最大，则仅选择其中一个），那么我们将x和y之间的边称为长边，由长边组成的路径称为长链。这样操作后，整颗树将包含若干条链，这些链没有公共顶点和公共边，并且每个结点唯一属于一条链。



**性质1：由于没有公共边，所有长链的总长度不超过n。**

**性质2：顶点x的k级祖先y所在链的长度一定不小于k**

证明：

如果x和y处于同一长链，很显然成立。

否则由于x在y的子树中，故Len(y)>=k，因此可知y所在长链一定不小于k。



## 在线查询树上某个结点的k级祖先

我们可以使用倍增算法找到每个顶点的所有2次幂祖先顶点。之后对于所有长链顶部结点x，为其创建两个两个大小为L=Len(x)-1的数组A、B，其中A保存x上面L个顶点，而B保存x沿着长链向下的L个顶点。之后还需要预先计算1~n中每个数的二进制最高位。上面的所有过程总的时间复杂度为$O(n\log_2n)$，空间复杂度为$O(n\log_2n)$。

之后对于诸如询问询问x的k级祖先，我们用倍增先找到x的$highestBit(k)$级祖先y，之后对于$k'=k-highestBit(k)$，可以推出$k'<highestBit(k)$，而我们由性质2得到y所在的长链的长度至少为$O(highestBit(k))$，因此我们可以直接利用y所在长链顶部顶点的A、B数组直接查表得到。



## 查询树上最长k边路径

为每个长链顶部顶点创建一个与其所在长链的长度相同的数组，这里总的空间复杂度为$O(n)$。

之后我们处理非顶部顶点x时，我们就复用顶部顶点的预分配的数组，第i个元素记录x子树中由i条边组成总权最大路径的总权。

首先我们先递归处理长边连接的顶点，之后和通过短边连接的顶点的数组合并。

由于只有长链顶部顶点会对父元素产生与其长度相同的贡献，因此时间复杂度为$O(n)$。



# LUOGU4292

**题意**

[https://www.luogu.org/problem/P4292](https://www.luogu.org/problem/P4292)

**题解**

先用分数规划将问题转换为二分+长链剖分。

由于允许的路径边数是范围，所以需要用线段树维护。时间复杂度为$O(n(\log_2n)^2)$。


# BZOJ4043

题目要求我们能判断路径的总权值，以及动态更新单点权值和子树权值。

如果只有单点权值，可以使用LCT来维护整颗树，复杂度为$O(nlog_2n)$。但是这里有子树权值，所以还是需要使用树链剖分的。

这题实际上考察的是树链剖分的一个特性，我们为每个结点重新分配序号时，同一条重链上的所有结点的序号是连续的，同时一颗子树下的所有结点的序号恰好形成一个连续的区间。

因此我们只需要寻找轻重链，之后为每个结点分配序号，按照序号创建一个线段树。之后的所有操作都在线段树上完成，实际的时间复杂度为$O(nlog_2^2n)$。

# BZOJ4196

将软件表示为结点，软件安装对应结点权值为1，未安装对应权值为0。题目实际上要我们求的是计算子树的总权值和，计算路径权值和，设置路径权值，设置子树权值。之后问题同BZOJ4043。

# Codeforces 1110F

**题意**

[https://codeforces.com/contest/1110/problem/F](https://codeforces.com/contest/1110/problem/F)

**题解**

我竟然想要用ETT来解决这个问题，重点是我也不会ETT，菜得真实。

我们先求出每个顶点到顶点1的距离。之后以顶点1位根进行深度优先搜索。当我们沿着一条边从父结点移动到子结点的时候，容易发现，所有的顶点可以分成三类，第一类是不属于子结点的子树中ID小于子结点的顶点，第二类是属于子结点的子树中的顶点，第三类是不属于子结点的子树中ID大于子结点的顶点。这三类顶点的ID都是连续的区间，这意味着三次区间修改操作，就可以将距离修正。

维护一个线段树，进入子结点时修正距离，离开子结点的时候恢复距离。访问到某个顶点时顺带处理掉所有与它相关的请求即可。

NOTE：非常多的树上查询问题都可以通过将问题挂载到对应的顶点上，并且利用深度优先搜索进行解决。

# 树上卷积问题

考虑一株树，每个顶点$v$都对应一个一阶多项式$f(v)$。现在我们为每个顶点$v$定义一个新的多项式$g(v)$，其定义为：

$$
g(v)=f(v)\prod_{u \in children(v)}g(u)
$$

现在我们为每个顶点提交一个查询，关联与顶点$i$的查询为$q_i$，其询问$g(v)$的$x^{q_i}$项的系数。

很显然我们可以DFS计算每个顶点关联的查询。现在问题是时间复杂度是多少。

我们这里可以直接暴力计算多项式，即用$O(n^2)$的算法。那么时间复杂度为多少呢。

我们知道时间复杂度肯定不会超过$O(n^3)$，但是具体是多少呢。

可以考虑这样的问题，考虑任意两个顶点$u,v$，及其最低公共祖先$a$，很显然在计算$g(a)$时，$u$和$v$会产生一次贡献。而任意一对顶点的唯一一次贡献仅发生在LCA上，因此时间复杂度为$O(n^2)$。

# Codeforces1260F

**题意**

[https://codeforces.com/contest/1260/problem/F](https://codeforces.com/contest/1260/problem/F)

**题解**

毒瘤题。

仅考虑颜色c。我们记V(i)为一个指示器，如果$l_i\leq c\leq r_i$，那么$V(i)$为真，否则为假。记$g(i)=r_i-l_i+1$，记$p=\prod_{i=1}^n g(i)$。

于是单独考虑颜色c的贡献，为：

$$
\sum_{V(i)\land V(j)\land i<j}dist(i,j)\frac{p}{g(i)g(j)}=p\sum_{V(i)\land V(j)\land i<j}dist(i,j)\frac{1}{g(i)g(j)}
$$

这里我们可以稍微变更一下，记$dep(i)$表示顶点i在树中的深度，那么有

$$
dist(i,j)=dep(i)+dep(j)-2dep(lca(i,j))
$$

其中$lca(i,j)$为顶点i和顶点j的最近公共祖先。代入之前的公式得到：

$$
\sum_{V(i)\land V(j)\land i<j}dist(i,j)\frac{1}{g(i)g(j)}\\
=\sum_{V(i)\land V(j)\land i<j}(dep(i)+dep(j)-2dep(lca(i,j)))\frac{1}{g(i)g(j)}\\
=\sum_{V(i)\land V(j)\land i<j}dep(i)\frac{1}{g(i)g(j)}+\sum_{V(i)\land V(j)\land i<j}dep(j)\frac{1}{g(i)g(j)}
+\sum_{V(i)\land V(j)\land i<j}2dep(lca(i,j))\frac{1}{g(i)g(j)}\\
=\sum_{V(i)}dep(i)\frac{1}{g(i)}(\sum_{V(j)}\frac{1}{g(j)})-\sum_{V(i)}dep(i)\frac{1}{g(i)^2}+2\sum_{V(i)\land V(j)\land i<j}dep(lca(i,j))\frac{1}{g(i)g(j)}
$$

现在我们考虑从颜色c转移到c+1，这时候我们会删除一些顶点，同时加入一些顶点。我们希望能在删除加入顶点的同时维护整个公式。事实上，前两项是很容易维护的，这里不另外讨论。最后一项，我们可以这样统计：

$$
\sum_{V(i)\land V(j)\land i<j}dep(lca(i,j))\frac{1}{g(i)g(j)}\\
=\sum_{V(i)}\frac{1}{g(i)}\sum_{V(j)\land i<j}dep(lca(i,j))\frac{1}{g(j)}
$$


我们维护一棵树，每次加入一个顶点x时，结果需要增加从顶点x到根顶点的路径上所有顶点的值，同时我们将顶点x到根节点的路径上所有顶点的值加上$\frac{1}{g(x)}$。（这里我们用到了，考虑两个顶点a和b，二者的公共前缀长度为dep(lca(a,b))，因此我们可以路径加总来替代$dep$函数的使用）。这涉及到路径操作，轻重链剖分或者LCT都可以。

# Codeforces 1111E

**题意**

[https://codeforces.com/contest/1111/problem/E](https://codeforces.com/contest/1111/problem/E)

**题解**

挺不错的问题。首先可以发现这个问题是树上DP问题，但是DP非常难推，且推出来的效率也很低。

我们可以换个思路，一个顶点$u$其只有$x$个禁止加入的分组（与集合中祖先数目相同），如果我们按照顶点的深度从小到大处理，那么如果此时已经存在$k$个分组，那么$u$或者加入已经存在的$k-x$个分组，或者重新创立一个分组。

剩下的就是如何快速确认每个顶点到根有多少个祖先顶点被选中，很简单，动态树即可。将选中的顶点的值全部设置为1，其余的设置为0，那么顶点到根之间祖先数目等于顶点到根这条路径上的值之和减去1（顶点自身）。（同时动态树还支持换根操作）

这个问题实际上还可以引出更加有趣的一种组合数学问题，第二类斯特林数，对于$n$个不同的元素，我们希望将它们分成不空的$k$组，有多少种分法。

# Codeforces 1083C

**题意**

[https://codeforces.com/contest/1083/problem/C](https://codeforces.com/contest/1083/problem/C)

**题解**

我们可以将整棵树放到线段树上维护，线段树上`[l,r]`表示的是从`l`到`r`排列对应的所有顶点，是否处于一条路径上。于是我们要找的结果就是最大的`k`使得`[0,k-1]`对应的顶点都处于一条路径上。这里满足二分的性质，所以我们可以在线段树上二分即可。

下面还需要提到一个问题，如何合并两个区间A和B。如果一个区间的所有顶点处于同一条路径上，我们只需要路径的两个端点就可以得到路径的所有信息了，我们可以在区间中保存路径的两个端点。现在考虑当区间A与B都满足所有顶点处于一条路径上时，是否能将两条路径合并为一条。如果能合并，最后得到的路径的两个端点必定是这四个端点中距离最远的两个，我们可以暴力枚举，找到距离最远的两个端点即可，之后判断所有四个端点是否都落于得到的新的路径上。

这里还可以提一下，线段树是自然支持二分的，因此我们可以在从上向下遍历线段树的时候完成二分过程，因此，总的时间复杂度为$O(n+q\log_2n)$。

# 两棵树的换边问题

**题型1：给定两颗均包含$n$个顶点的树，第一颗树的边的颜色都为白色，第二颗树的边的颜色都是黑色。现在要求我们每次从第一颗树删除一条白边，并从第二颗树删除一条黑边，并将删除的黑边加入到第一颗树中，要求每次操作完成后第一颗树依旧是树（连通无环）。重复上述操作只到第一颗树的边全为黑，第二颗树无边。要求输出每次删除的白边和黑边。**

这个问题有一个构造算法：

1. 如果树2不存在黑边，则退出，否则进入步骤2。
2. 从树2中任意删除一条黑边，边记作$b$。
3. 将$b$加入树1，此时树1会出现一个唯一的环。出现的环中一定有白边（否则黑边成环意味着树2初始时一定有环），任意选择一条白边$w$，并移除。
4. 回到步骤1。

很显然上面的算法是正确的，我们可以用LCT实现这个算法，时间复杂度为$O(n\log_2n)$。

**题型2：给定两颗均包含$n$个顶点的树，第一颗树的边的颜色都为白色，第二颗树的边的颜色都是黑色。现在要求我们计算白边和黑边的最大匹配，白边和黑边相连当且仅当我们从将树1的这条白边和树2的这条黑边交换，两颗树依旧是树（连通无环）。要求输出最大匹配以及配对的白边和黑边。**

考虑对于树2中的任意一条边$e_2=(u,v)$，从树2中删除并加入树1后，树2出现两个连通块，而树1出现一个环。

命题1：此时树1中从$u$到$v$的唯一路径上一定有一条边$e_1$，满足将$e_1$加入树2后树2连通。

证明：考虑从$u$到$v$的唯一路径，路径的两个端点在树2中处于不同的连通分块，因此，我们一定可以找到路径上一对相邻的顶点（又是间隙二分哦），顶点在树2中处于不同的连通分块。找到了这两个顶点，我们也就确定了$e_1$。

利用命题1，我们可以每次选择一条黑边，同时找到对应的白边。但是这时候问题出现了，同一条白边可能被多条黑边所匹配。解决方法就是我们每次找一条黑边，再在树1中找到一条可交换的白边，达成匹配后，我们将黑边从树2删除，并用白边代替它（但是我们始终保持树1不变）。这样我们能保证下一条树2中的黑边还能在树1中找到可以交换的白边，且这条白边一定没有被匹配过（否则再次被加入树2，出现了重边，此时一定有环）。

上面的流程保证了我们最大匹配一定是完美匹配。

暴力的做法就是$O(n^2)$。但是我们发现每次树1是不变的，因此我们可以提前在树1上计算倍增，之后在树1上查询路径的时候就可以二分路径找到端点属于不同连通块的边了。但是由于树2会不断变动，要维护它的连通关系，我们可以使用LCT或则动态图判连通算法，这样总的时间复杂度均为$O(n(\log_2n)^2)$。

但是这里有一个额外的技巧，我们发现每次选择一个端点为叶子的黑边，我们可以非常简单的判断连通性。对应的，当加入白边到树2中时，考虑到白边永远不会再被删除，因此我们可以保证白边的两个端点之后将一直保持连通，我们可以将两个顶点合并（合并并查集）。于是乎我们就提供了一个$O(1)$维护连通性的算法，总的时间复杂度降低到$O(n\log_2n)$。

Codeforces上有一道[原题](https://codeforces.com/contest/1284/problem/F)。

# 一类树上分割问题

**题目1：给定一颗有$n$个顶点的树，其中$n\leq 10^5$，之后定义$f(i)$表示将树分解为若干个连通块，问最多能分解出多少个大小正好为$i$的连通块。要求输出$f(1),f(2),\ldots,f(n)$**

这是[Blogewoosh #3](https://codeforces.com/blog/entry/61331)提出的问题和解法，我这里只是搬运而已。但是一部分内容是我自己的，与原文可能有些出入。

我们可以定义另外一个函数，记$g(i)$表示将树分解为若干个连通块，其中最多能分解出来大小至少为$i$的连通块数目。很显然$g(i)\geq f(i)$，但是由于任意大于等于$i$的连通块都可以从中切割出一个大小正好为$i$的连通块，因此$f(i)\geq g(i)$。因此总结得出$f(i)=g(i)$，即$f=g$。

于是乎问题就变成了我们希望将树分解为大小至少为$i$的若干个连通块。

首先很显然，我们对树进行dfs，并且同时做出贪心选择，如果子树中未分配的顶点总数加上自己，大小大于等于$i$，那么我们将自己与父亲的连边删除并得到一个大小不小于$i$的新连通块。这是一种贪心做法。

现在我们来证明贪心的正确性，假如存在最优解，使得存在这样一个顶点，其与父亲的连边未删除，且子树中未分配的顶点数目加上自己不小于$i$，那么我们可以删除与父亲的连边（如果操作后父亲大小不足，我们可以舍弃父亲），这样绝对不会使得最优解劣化。因此我们证明了贪心的正确性。

于是乎我们就得到了一个$O(n^2)$的暴力做法。

现在让我们来优化一下，注意到不等式$f(i)\leq \lfloor \frac{n}{i}\rfloor$一定成立，因此当$i\geq \sqrt{n}$时，$f(i)$只可能有$\sqrt{n}$种取值。因此我们可以分两种情况处理，对于$i\leq \sqrt{n}$，我们可以暴力计算，这里花的时间为$n\sqrt{n}$，而对于$i>\sqrt{n}$，由于$f$是递减函数，因此一定存在一个区间$\[l,r\]$（可能为空）和某个数$x<\sqrt{n}$，使得$f(l)=f(r)=x$。我们可以用二分来加速计算。

上面的优化后的算法的时间复杂度为$O(n\sqrt{n}\log_2n)$，但是实际上我们可以选择暴力计算到$\sqrt{n\log_2n}$，这样真实的时间复杂度就会降低到$n\sqrt{n\log_2n}$。

上面提供了一种有通过可能性的算法。

下面我们再来讨论一种更快速的方式。

考虑当树是毛毛虫状的，即除了叶子结点外，其余顶点恰好形成一条路径（主干），这时候我们就可以用线段树维护它，之后对于块大小至少为$i$时，我们可以用最多$\frac{n}{i}$次二分法（在线段树上二分），找到树最多能切分为多少段，这样所需的时间复杂度为$O(\frac{n}{i}\log_2n)$。很显然，当$i$很小的时候，算法的速度反而变慢了，但是观察总的性能，我们会发现为$O(n(\log_2n)\sum_{i=1}^n\frac{1}{i})=O(n(\log_2n)^2)$，反而变快了有木有。

当然上面这个算法仅适用于毛毛虫状树。但是仔细思考普通树和毛毛虫状树区别是什么，实际上在贪心的过程中，毛毛虫状树我们只需要处理主干，但是普通树，如果存在另外一个分支大小超过$k$，那么我们必须同时处理这个分支。因此我们可以将所有大小超过$i$的分支从原来的树中分离出来，独立计算贡献，最后统计到结果中去。那么分支不会很多吗？不会多的，在要求连通块大小至少为$i$的前提下，一棵树的分支数最多为$\frac{n}{i}$，而总的流程中，最多存在$O(n\log_2n)$个分支。

因此到此我们就得到了整个算法。我们可以对树进行轻重链剖分，之后将每条重链放到线段树上进行维护。每当我们发现分支小于当前的要求的时候，我们就将分支合并回原本分出的位置。在线段树上我们可以维护动态规划，来支持二分操作。每次二分的时间复杂度为$O(\log_2n)$，而每次分支对主干的贡献也为$O(\log_2n)$，因此总共的时间复杂度为$O(n(\log_2n)^2)$。