---
categories: algorithm
layout: post
---

- Table
{:toc}
# 边分治

边分治类似于点分治，区别在于点分治找的是重心点，而边分治找的是重心边。

树T的重心边是指这样一条边e，使得删除e后得到的两个连通块大小的最大值最小，我们记作$effect(e)$。

由于对于菊花图，任何边得到的连通分块的大小都是1和n-1，因此边分治不能得到很好的效果。我们可以插入一些假的顶点，使得每个顶点下只挂两条边（不包括与父亲相连的边）。

现在在已知树中每个顶点的度都不超过3的前提下，我们证明假如e是树T的重心，且T的大小为n，那么$effect(e)\leq \frac{2}{3}n$。实际上假设e是树T的重心，连接两个顶点u、v。不妨认u所在连通块的大小大于$\frac{2}{3}n$。考虑到u至多还能连接两条边，因此至少有一条边e'的另外一端所在连通块的大小能达到$\frac{1}{3}n$。e'是比e更好的重心。

边分治的优势在于边连接的一定是父子，因此可以将树分成两部分，包含根的记作R，不含根的记作B。而R中任意顶点x，与B中所有顶点的LCA是相同的，因此可以提前计算并用于后面的处理。

# 边分树

考虑要处理这样的问题，有两棵树T1和T2，对于某个不同顶点对u、v，定义它们的距离为：


$$
dist(u,v)=dist_1(u,v)+dist_2(u,v)
$$


其中$dist_1$为第一颗树上的距离，$dist_2$是第二颗树上的距离。这个问题可以通过边分数来消除第一颗树上LCA带来的影响，之后为第二颗树建立虚树，可以消除第二颗树上LCA的影响，之后就成为一般的DFS统计最远顶对问题，时间复杂度是$O(n(\log_2n)^2)$。

可以用另外一种叫做边分树的技术来优化。我们为每个顶点额外维护一个二叉树，初始时只有一个顶点。在对第一个树进行边分治时，删除边重心后，会得到两个连通块，记作a、b。我们将a上的顶点二叉树深度最大的叶结点下加上一个左孩子，为b上顶点二叉树深度最大的叶结点下加上一个右孩子。完成了边分治后，每个顶点所对应的二叉树实际上都是一条弯曲的链表（长度为$O(\log_2n)$），之后我们在第二颗树上进行DP操作。对于每个顶点，当递归处理完一个子结点时，就将它的二叉树和自己的二叉树进行合并，合并的时候对于处于二叉树左右不同分支的顶点，可以统计其贡献。这样就能在$O(n\log_2n)$的时空复杂度下解决问题。

# 树上最远点对

**命题1：如果树上边权非负，对于两个顶点集合A、B，设A中最远点对为$a_1,a_2$，而B中最远点对为$b_1,b_2$，那么在A、B合并后，其中最远点对一定可以从$\{a_1,a_2,b_1,b_2\}$中得到。**



**命题2：如果树上边权非负，并定义树上距离为路径距离加上两点的点权，对于两个顶点集合A、B，设A中最远点对为$a_1,a_2$，而B中最远点对为$b_1,b_2$，那么在A、B合并后，其中最远点对一定可以从$\{a_1,a_2,b_1,b_2\}$中得到。**

# 树上中点（边）

如果一颗树的直径为$D$。

如果$D$是偶数，那么树上一定存在一个顶点，到其它所有顶点的距离不超过$D/2$，这个顶点称为树的中点。

如果$D$是奇数，那么树上一定存在一条边，使得其它所有顶点到边的某一端的顶点的距离不超过$(D-1)/2$，这条边称为树的中边。

任意取一条树上直径，如果直径长度为偶数，那么直径中心的顶点就是树的中点，假如直径长度为奇数，那么直径中心的边就是树的中边。

# LUOGU4565

**题意**

[https://www.luogu.org/problem/P4565](https://www.luogu.org/problem/P4565)

**题解**

首先用边分治将树1分为两块，包含根的记作R，不含根的记作B。给R中顶点上黑色，B中顶点上白色，之后根据树2建立虚树。

记一个顶点x在树中到树根的路径的总边权记作prefix(x)，记B中深度最浅的顶点为y。

那么黑色顶点a的点权为：weight(a)=prefix(a)-prefix(lca(a, y))

白色顶点b的点权为：weight(b)=prefix(b)

建立好虚树后，我们要找到虚树上距离最远的一对黑白点，其中虚树中a,b距离的定义为：$weight(a)+weight(b)-weight(lca(a,b))$。这个问题dfs就能解决了。

总的时间复杂度为$O(n(\log_2n)^2)$。

# LUOGU4220

**题意**

[https://www.luogu.org/problem/P4220](https://www.luogu.org/problem/P4220)

**题解**

我们先理解题目要我们求的到底是个啥，定义$dist(i,j)=dist_1(i,j)+dist_2(i,j)+dist_3(i,j)$，其中$dist_k(i,j)$表示在第k树中i、j的距离。可以进行简化：


$$
\max\quad dist(i,j)=\sum_{k=1}^3dist_k(i,j)=\sum_{k=1}^3depth_k(i)+depth_k(j)-2\cdot depth_k(L_k(i,j))
$$


这里$depth_k(i)$表示的是i在第k颗树中的深度，$L_k(i,j)$表示i、j在第k个树中的LCA。我们记$depth(i)=depth_1(i)+depth_2(i)+depth_3(i)$，之后公式为：


$$
\max\quad dist(i,j)=depth(i)+depth(j)-2depth_1(L_1(i,j))-2depth_2(L_2(i,j))-2depth_3(L_3(i,j))
$$


利用边分治处理第一颗树，删除边重心后，得到两个连通块，包含根的记作A，不含根的记作B。将A中顶点全部染成白色，B中染成黑色，记边的。记录$w_A(i)=depth(i)-2depth_1(L_1(i,B))$，$w_B(i)=depth(i)$。之后为这些点按照第二颗树的结构建立虚树。现在我们要求的是：


$$
\max \quad dist(i,j)=w_A(i)+w_B(j)-2depth_2(L_2(i,j))-2depth_3(L_3(i,j))
$$


在虚数上处理第t个顶点时，由于LCA一定是t，因此可以认为$2depth_2(L_2(i,j))$是常数。此时我们要计算的是


$$
\max \quad dist'(i,j)=w_A(i)+w_B(j)-2depth_3(L_3(i,j))
$$


这里需要用到一个在树上所有边非负的时候成立的命题。

**命题1：如果树上边权非负，对于两个顶点集合A、B，设A中最远点对为$a_1,a_2$，而B中最远点对为$b_1,b_2$，那么在A、B合并后，其中最远点对一定可以从$\{a_1,a_2,b_1,b_2\}$中得到。**

我们可以继续扩展这个命题得到：

**命题2：如果树上边权非负，并定义树上距离为路径距离加上两点的点权，对于两个顶点集合A、B，设A中最远点对为$a_1,a_2$，而B中最远点对为$b_1,b_2$，那么在A、B合并后，其中最远点对一定可以从$\{a_1,a_2,b_1,b_2\}$中得到。**

转换公式令其得到符合命题2：


$$
\max \quad dist'(i,j)=(w_A(i)-depth_3(i))+(w_B(j)-depth_3(j))+dist_3(i,j)
$$

因此在递归处理虚树的同时维护子树dist'最大的白点对、黑点对，在向上贡献的时候合并到父结点的信息中。

# Atcoder AGC001C

**题意**

[https://atcoder.jp/contests/agc001/tasks/agc001_c](https://atcoder.jp/contests/agc001/tasks/agc001_c)

给定一颗树，删除最少的顶点，保证剩余顶点组成一颗直径不超过k的树的前提下，要求树尽可能大。

**题解**

先学习了一下树的中点和中边的概念。

如果原树半径就小于等于k，那么结果就是原树。

否则，那么结果的半径一定是k。如果k是偶数，那么可以寻找结果的中点，如果找到，那么结果一定是距离中点小于k/2的顶点集合（很显然这是一个满足条件的树，并且结果是这类树构成集合的一个元素）。

如果k是奇数，那么对应的求结果中的中边即可。

时间复杂度为$O(n^2)$。

