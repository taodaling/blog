---
categories: algorithm
layout: post
---

- Table
{:toc}
# 边分治

边分治类似于点分治，区别在于点分治找的是重心点，而边分治找的是重心边。

树T的重心边是指这样一条边e，使得删除e后得到的两个连通块大小的最大值最小，我们记作$effect(e)$。

由于对于菊花图，任何边得到的连通分块的大小都是1和n-1，因此边分治不能得到很好的效果。我们可以插入一些假的顶点，使得每个顶点下只挂两条边（不包括与父亲相连的边）。

现在在已知树中每个顶点的度都不超过3的前提下，我们证明假如e是树T的重心，且T的大小为n，那么$effect(e)\leq \frac{2}{3}n$。实际上假设e是树T的重心，连接两个顶点u、v。不妨认u所在连通块的大小大于$\frac{2}{3}n$。考虑到u至多还能连接两条边，因此至少有一条边e'的另外一端所在连通块的大小能达到$\frac{1}{3}n$。e'是比e更好的重心。

边分治的优势在于边连接的一定是父子，因此可以将树分成两部分，包含根的记作R，不含根的记作B。而R中任意顶点x，与B中所有顶点的LCA是相同的，因此可以提前计算并用于后面的处理。

# 边分树

考虑要处理这样的问题，有两棵树T1和T2，对于某个不同顶点对u、v，定义它们的距离为：


$$
dist(u,v)=dist_1(u,v)+dist_2(u,v)
$$


其中$dist_1$为第一颗树上的距离，$dist_2$是第二颗树上的距离。这个问题可以通过边分数来消除第一颗树上LCA带来的影响，之后为第二颗树建立虚树，可以消除第二颗树上LCA的影响，之后就成为一般的DFS统计最远顶对问题，时间复杂度是$O(n(\log_2n)^2)$。

可以用另外一种叫做边分树的技术来优化。我们为每个顶点额外维护一个二叉树，初始时只有一个顶点。在对第一个树进行边分治时，删除边重心后，会得到两个连通块，记作a、b。我们将a上的顶点二叉树深度最大的叶结点下加上一个左孩子，为b上顶点二叉树深度最大的叶结点下加上一个右孩子。完成了边分治后，每个顶点所对应的二叉树实际上都是一条弯曲的链表（长度为$O(\log_2n)$），之后我们在第二颗树上进行DP操作。对于每个顶点，当递归处理完一个子结点时，就将它的二叉树和自己的二叉树进行合并，合并的时候对于处于二叉树左右不同分支的顶点，可以统计其贡献。这样就能在$O(n\log_2n)$的时空复杂度下解决问题。

# 树上最远点对

**命题1：如果树上边权非负，对于两个顶点集合A、B，设A中最远点对为$a_1,a_2$，而B中最远点对为$b_1,b_2$，那么在A、B合并后，其中最远点对一定可以从$\{a_1,a_2,b_1,b_2\}$中得到。**



**命题2：如果树上边权非负，并定义树上距离为路径距离加上两点的点权，对于两个顶点集合A、B，设A中最远点对为$a_1,a_2$，而B中最远点对为$b_1,b_2$，那么在A、B合并后，其中最远点对一定可以从$\{a_1,a_2,b_1,b_2\}$中得到。**

# 树上中点（边）

如果一颗树的直径为$D$。

如果$D$是偶数，那么树上一定存在一个顶点，到其它所有顶点的距离不超过$D/2$，这个顶点称为树的中点。

如果$D$是奇数，那么树上一定存在一条边，使得其它所有顶点到边的某一端的顶点的距离不超过$(D-1)/2$，这条边称为树的中边。

任意取一条树上直径，如果直径长度为偶数，那么直径中心的顶点就是树的中点，假如直径长度为奇数，那么直径中心的边就是树的中边。

# 相邻元素最少交换次数

现在给定等长且含有相同数量1的两个二进制序列，记作A、B。

我们可以对序列A做如下操作，交换两个相邻的位的值。问最少需要多少次操作，可以将A转换为B。

譬如：

A=0110

B=1001

很显然将第一位和第二位交换，将第三位和第四位交换就可以得到想要的结果，且任意可能的方案都至少要进行两次交换，因此答案是2。

这个问题的解法非常简单，我们记A中1出现的位置从小到大为
$$
a_1,a_2,\ldots,a_k
$$
，B中1出现的位置从小到大为
$$
b_1,b_2,\ldots,b_k
$$
。可以证明A中原本位于$a_i$的1会最终被放置在$b_i$。

事实上，我们永远不会交换两个相同的值，因此$a_{i+1}$永远不会交换到$a_1$之前。因此我们可以直接证明$a_1$与$b_1$相匹配（这里匹配的意思是A中原本$a_1$处的1最终会移动到$b_1$）。同理可以证明其它1的匹配。

因此答案为：
$$
\sum_{i=1}^k|a_i-b_i|
$$
。



这个问题可以在树上进行定义。对于一颗树，我们为顶点的初始值赋值为1或0，接下来，每个顶点还有一个目标值。我们可以交换两个之间存在一条边的顶点的值，我们的目的是使得最终树上每个顶点的值和目标值相同，并要求步骤数最少。

很显然，如果目标值中的1和初始值中的1的数目不同（简单说目标值的和和初始值的和不同），那么问题是无解的。下面考虑相同的情况。

对于树中的任意一条边，该边会将树分成两个连通块。我们称连通块的不平衡度为连通块中值的和与目标值的和的差的绝对值。很显然删除边e后，两个连通块的不平衡度是相同的。记$f(e)$为树失去边e后形成的连通块的不平衡度，称为边两端不平衡度。
很显然式子
$$
\sum_{e\in E}f(e)
$$
是结果的一个下界。我们可以这样理解这个式子，由于删除$e$后，两个连通块的不平衡度均为$f(e)$，那么必定至少有$f(e)$个1从一个连通块中经过边$e$转移到另外一个连通块中。

下面我们设计一个算法，可以在下界次操作中完成转换。

首先我们从图中删除所有两端不平衡度为0的边，仅保留不平衡度非0的边。假如连通块大小都为1，这意味着没有边存在，即所有顶点的值和目标值是相同的，这时候我们自然可以在下界次（0）操作中完成转换。

利用反证法，假设不存在这样的边e，使得e的两端顶点的值一个为1，一个为0，且为1的顶点所在连通块的值和减去目标值和是正数。任意考虑一个大小非1的连通块。连通块一定是树，因此一定存在度数为1的叶子结点$v$。叶子结点的值和目标值必定不同，我们不妨设叶子结点的值为0，目标值为1。之后考虑$v$的父结点$u$，很显然父结点一定也是0（否则与假设相悖）。利用归纳法我们可以推广证明对于任意高度的树，树中的值必定都是相同的。当然这样的话，就意味着连通块的不平衡度非0，这是不可能的。因此假设不成立，存在这样的一条边，两端顶点值不同且1所在的连通块的值减去目标值和是正数。

我们将上面提到的边两端的顶点的值交换，发现除了$e$两端不平衡度减少了1以外，其余边的不平衡度都没有发生变化。

而上面的操作最多发生下界次，因此就证明了存在一种方案可以在下界次交换中使得每个顶点的值和目标值是相同的。

# 最小子树统计

对于一株树
$$
T=(V,E)
$$
，对于任意$V$的子集$S$，包含$S$的顶点最少的子树的顶点数目记作$f(S)$。

要求：


$$
\sum_{S\subset V}f(S)
$$


这个问题站在顶点的角度看，是很难解决的。但是如果站在边的角度看问题就很简单了，记
$$
g(S)
$$
表示包含$S$的顶点最少的子树中的边集。那么我们可以推出：


$$
\sum_{S\subset V}f(S)\\
=\sum_{S\subset V}(\sum_{e\in g(S)}1+1)\\
=\sum_{S\subset V}\sum_{e\in g(S)}1+2^{|V|}\\
=\sum_{e\in E}\sum_{S\subset V}[e\in g(S)]+2^{|V|}
$$


其中
$$
[e\in g(S)]
$$
为1，当且仅当$S$中包含从$T$中删除$e$后得到的两个子树中顶点至少一个。因此我们利用容斥，从所有可能的$V$的子集中删除仅覆盖$e$一侧顶点的集合数即可得到，记$L(x)$表示边左侧子树大小，$R(x)$表示边右侧子树大小，那么结果就是：


$$
\sum_{S\subset V}[e\in g(S)]=2^{|V|}-2^{L(e)}-2^{R(e)}+2^{0}
$$


因此最终结果可以表示为：


$$
\sum_{S\subset V}f(S)=\sum_{e\in E}\sum_{S\subset V}[e\in g(S)]+2^{|V|}\\
=\sum_{e\in E}(2^{|V|}-2^{L(e)}-2^{R(e)}+2^{0})+2^{|V|}
$$


这个可以通过dfs线性统计出来。

# LUOGU4565

**题意**

[https://www.luogu.org/problem/P4565](https://www.luogu.org/problem/P4565)

**题解**

首先用边分治将树1分为两块，包含根的记作R，不含根的记作B。给R中顶点上黑色，B中顶点上白色，之后根据树2建立虚树。

记一个顶点x在树中到树根的路径的总边权记作prefix(x)，记B中深度最浅的顶点为y。

那么黑色顶点a的点权为：weight(a)=prefix(a)-prefix(lca(a, y))

白色顶点b的点权为：weight(b)=prefix(b)

建立好虚树后，我们要找到虚树上距离最远的一对黑白点，其中虚树中a,b距离的定义为：$weight(a)+weight(b)-weight(lca(a,b))$。这个问题dfs就能解决了。

总的时间复杂度为$O(n(\log_2n)^2)$。

# LUOGU4220

**题意**

[https://www.luogu.org/problem/P4220](https://www.luogu.org/problem/P4220)

**题解**

我们先理解题目要我们求的到底是个啥，定义$dist(i,j)=dist_1(i,j)+dist_2(i,j)+dist_3(i,j)$，其中$dist_k(i,j)$表示在第k树中i、j的距离。可以进行简化：


$$
\max\quad dist(i,j)=\sum_{k=1}^3dist_k(i,j)=\sum_{k=1}^3depth_k(i)+depth_k(j)-2\cdot depth_k(L_k(i,j))
$$


这里$depth_k(i)$表示的是i在第k颗树中的深度，$L_k(i,j)$表示i、j在第k个树中的LCA。我们记$depth(i)=depth_1(i)+depth_2(i)+depth_3(i)$，之后公式为：


$$
\max\quad dist(i,j)=depth(i)+depth(j)-2depth_1(L_1(i,j))-2depth_2(L_2(i,j))-2depth_3(L_3(i,j))
$$


利用边分治处理第一颗树，删除边重心后，得到两个连通块，包含根的记作A，不含根的记作B。将A中顶点全部染成白色，B中染成黑色，记边的。记录$w_A(i)=depth(i)-2depth_1(L_1(i,B))$，$w_B(i)=depth(i)$。之后为这些点按照第二颗树的结构建立虚树。现在我们要求的是：


$$
\max \quad dist(i,j)=w_A(i)+w_B(j)-2depth_2(L_2(i,j))-2depth_3(L_3(i,j))
$$


在虚数上处理第t个顶点时，由于LCA一定是t，因此可以认为$2depth_2(L_2(i,j))$是常数。此时我们要计算的是


$$
\max \quad dist'(i,j)=w_A(i)+w_B(j)-2depth_3(L_3(i,j))
$$


这里需要用到一个在树上所有边非负的时候成立的命题。

**命题1：如果树上边权非负，对于两个顶点集合A、B，设A中最远点对为$a_1,a_2$，而B中最远点对为$b_1,b_2$，那么在A、B合并后，其中最远点对一定可以从$\{a_1,a_2,b_1,b_2\}$中得到。**

我们可以继续扩展这个命题得到：

**命题2：如果树上边权非负，并定义树上距离为路径距离加上两点的点权，对于两个顶点集合A、B，设A中最远点对为$a_1,a_2$，而B中最远点对为$b_1,b_2$，那么在A、B合并后，其中最远点对一定可以从$\{a_1,a_2,b_1,b_2\}$中得到。**

转换公式令其得到符合命题2：


$$
\max \quad dist'(i,j)=(w_A(i)-depth_3(i))+(w_B(j)-depth_3(j))+dist_3(i,j)
$$

因此在递归处理虚树的同时维护子树dist'最大的白点对、黑点对，在向上贡献的时候合并到父结点的信息中。

# Atcoder AGC001C

**题意**

[https://atcoder.jp/contests/agc001/tasks/agc001_c](https://atcoder.jp/contests/agc001/tasks/agc001_c)

给定一颗树，删除最少的顶点，保证剩余顶点组成一颗直径不超过k的树的前提下，要求树尽可能大。

**题解**

先学习了一下树的中点和中边的概念。

如果原树半径就小于等于k，那么结果就是原树。

否则，那么结果的半径一定是k。如果k是偶数，那么可以寻找结果的中点，如果找到，那么结果一定是距离中点小于k/2的顶点集合（很显然这是一个满足条件的树，并且结果是这类树构成集合的一个元素）。

如果k是奇数，那么对应的求结果中的中边即可。

时间复杂度为$O(n^2)$。

