---
categories: algorithm
layout: post
---

- Table
{:toc}

# 切比雪夫距离

对于二维平面上两个点(a,b),(c,d)，它们的切比雪夫距离定义为


$$
\max(|a-c|,|b-d|)
$$


由于切比雪夫距离不容易被预处理，有时候需要先转换为曼哈顿距离进行处理。下面给出转换的数学公式：


$$
|a-c|+|b-d|=\max(|(a+b)-(c+d)|,|(a-b)-(c-d)|)
$$


证明方式比较简单，首先将右边公式转换为：


$$
\max(|(a-c)+(b-d)|,|(a-c)-(b-d)|)
$$


考虑两种情况，第一种$a-c$与$b-d$同号。那么右边的公式取值为$\|(a-c)+(b-d)\|=\|a-c\|+\|b-d\|$。而第二种情况下，$a-c$与$b-d$异号。那么右边的公式取值为$\|(a-c)-(b-d)\|=\|a-c\|+\|-(b-d)\|=\|a-c\|+\|b-d\|$。因此证明了等式的成立。



利用这个公式我们可以先将所有平面上的点$(x,y)$转换为$(x+y,x-y)$的形式，之后计算各个点间的切比雪夫距离就可以得到原平面的曼哈顿距离。同理，如果我们将平面上的点$(x,y)$转换为$(\frac{x+y}{2}, \frac{x-y}{2})$，之后计算各个点之间的曼哈顿距离，那么就可以得到原平面的切比雪夫距离。

# 曼哈顿距离的组合

最近从一个atcoder的[问题](https://atcoder.jp/contests/abc111/tasks/arc103_b)中学了一个新的东西，记录一下。

给定序列$2^0,2^1,2^2,\ldots, 2^k$，我们从$(0,0)$出发，我们可以不断从序列中选取一个整数x并删除，之后向四个方向中的一个方向移动距离x。重复这个过程直到序列为空。

我们可以证明通过上面这个流程可以从$(0,0)$移动到距离$(0,0)$曼哈顿距离为奇数且小于$2^{k+1}$的所有整数坐标顶点。

至于怎么构造到$(x,y)$的路径，我们可以选择最后一个数字$2^k$，之后沿着四个方向移动，判断哪种方案移动后到$(0,0)$的距离小于$2^k$，选择它即可。递归这个流程就可以构造出解决方案了。

# BZOJ3170

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=3170](https://www.lydsy.com/JudgeOnline/problem.php?id=3170)

**题解**

距离是切比雪夫距离，非常难算。但是如果距离是曼哈顿距离的话，似乎就非常简单了。我们可以先将切比雪夫距离转换为曼哈顿距离（如何转换见切比雪夫距离这一段）。之后假设我们选择$(x_0,y_0)$作为集合点，那么总路程为：


$$
\sum_{i=1}^n(|x_i-x_0|+|y_i-y_0|)=\sum_{i=1}^n|x_i-x_0|+\sum_{i=1}^n|y_i-y_0|
$$


可以发现x和y坐标可以分开计算，而计算单一维度非常简单，这里不赘述。

# BZOJ1337

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1337](https://www.lydsy.com/JudgeOnline/problem.php?id=1337)

**题解**

我们可以枚举圆心坐标来求最小半径。当圆心坐标确定时，计算半径时间复杂度为$O(n)$。

记$f(x,y)$表示以(x,y)为圆心时的最小半径。容易发现当x或y一者固定时$f(x,y)$是单峰函数。记$f_X(x)=\min_y(f(x,y))$，容易看出$f_X$也是单峰函数。因此我们需要做的就是三分套三分，分别枚举圆心的横坐标和纵坐标，总的时间复杂度为$O(n(\log_2M)^2)$，其中M是最大坐标。

题目的实际数据量好像并不大，估计只有几千左右。所以速度不是很重要，精度要调整的小些。

# BZOJ1052

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1052](https://www.lydsy.com/JudgeOnline/problem.php?id=1052)

**题解**

由所有点可以确定唯一的面积最小的矩形R，包含所有点。

先考虑只有一个正方形的情况，这时候边长一定是R的长。

再考虑两个正方形的情况，如果四边形边长小于R的长，那么我们可以保证两个四边形分别与R的两条边接触，即两个四边形落在R的两个对角顶点上。

考虑三个正方形的情况，如果四边形边长小于R的长，那么我们能保证至少一个四边形落在R的一个顶点上。这是必然的，不然所有四边形最多与1条R的边接触，那么有一条R的边将没有与任何四边形接触，即有点没被覆盖。我们可以枚举四个角的情况，用掉一个正方形，接着就是用两个四边形覆盖未被覆盖的顶点的情况了。这总的时间复杂度是$O(n)$。

容易发现随着正方形边增大，覆盖从不可能转换为可能。因此可以二分。总的时间复杂度为$O(nlogn)$。

# BZOJ1069

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1069](https://www.lydsy.com/JudgeOnline/problem.php?id=1069)

**题解**

四个点一定落在外部凸包上，这个自己在纸上画画就可以得出结论了。

我们可以枚举四边形的一条对角线，这条对角线将四边形分为两个三角形的和，即我们需要去对角线的顺逆时针方向分别取一个点，之后形成两个三角形。

由于这两个三角形可以独立求解，这里总的时间复杂度就已经被优化到了$O(n^3+n\log_2n)$了，是否还可以继续优化呢。

我们可以仅考虑包含顶点i的对角线，这样我们可以利用旋转卡壳算法来计算距离对角线最远的对角线两端的顶点，因此处理包含特定顶点的所有对角线确定的最大四边形，只需要$O(n)$的时间复杂度，总共有$n$个点，因此总的时间复杂度为$O(n^2)$。

# BZOJ1074

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1074](https://www.lydsy.com/JudgeOnline/problem.php?id=1074)

**题解**

折叠后的图形不一定是凸多边形，因此不好维护。我们可以这样考虑，假设只折叠一次，那么打的这个点会对应原图的两个点，这两个点一个对应原来的点，一个对应沿折叠线镜像的点。如果折叠多次，可以按这个思路不断拆开图纸就可以了。

我们可以用矩阵实现坐标变换，以折叠的起点为原点，以折叠的起点到终点的线为x轴。这样建立坐标系后，对于每个点，我们可以将该点从标准坐标系转换到我们的自定义坐标系，如果转换后的点的y值大于等于精度，那么它对应拆开图纸后的两点，否则没有在图纸上留下任何点。

# BZOJ1102

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1102](https://www.lydsy.com/JudgeOnline/problem.php?id=1102)

**题解**

沿着y=x的线，将一侧的顶点全部翻转到另外一侧，这时候得到的是周长最小的矩形。如果不理解，可以自己画一下图。


# BZOJ1100

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1100](https://www.lydsy.com/JudgeOnline/problem.php?id=1100)

**题解**

每个顶点都包含三个信息，顺时针边长，逆时针边长，以及角度。

假设存在对称轴，那么这意味着从对称轴开始，顺逆时针遍历可以得到完全一致的顶点序列。即该序列是回文。

我们可以将顶点序列表示成字符串，寻找对称轴视作在字符串中找指定长度的回文。这部分可以用哈希算法实现。

# ARC065E

**题意**

[https://atcoder.jp/contests/arc065/tasks/arc065_c](https://atcoder.jp/contests/arc065/tasks/arc065_c)

**题解**

注意到是曼哈顿距离，因此我们可以将其转换为切比雪夫距离。

这样所有从顶点u可以到达的其它顶点都应该落在以u为中心边长为2*d(a,b)的正方形的边上。

剩下的就是一些平衡树的奇技淫巧了，在平衡树上维护每条与x轴平行的横线以及与y轴平行的竖线，总的时间复杂度为$O(n\log_2n)$。

# POJ3335

**题意：**

判断多边形的核是否存在。

**题解：**

利用半平面交算多边形的核，如果核存在，则至少会有3条边组成。

# POJ3525

**题意：**

寻找多边形中距离边缘最远的点。

**题解：**

二分可能的距离d，之后将多边形的边按照垂线移动d距离，判断新的多边形是否存在。

# POJ3384

**题意：**

寻找两个点，点距离边缘距离必须超过r，且两个点尽可能远。

**题解：**

首先将多边形的边按照垂线移动r距离。之后留下的多边形一定是凸包，在凸包上找最远的两个点，这两个点一定是凸包的顶点。可以利用旋转卡壳或暴力计算。

# POJ1755

**题意：**

给出一组ai,bi,ci。对于每个i，判断是否存在三个正数x，y，z，使得对所有$j\neq i$满足$a_ix+b_iy+c_iz < a_jx+b_jy,c_jz$，

**题解：**

首先三元不好计算，我们可以始终认为z被设置为1，换言之我们将z的赋值作为比较的标准。我们对每个i进行独立计算，将不等式转换为


$$
(a_i-a_j)x+(b_i-b_j)y+(c_i-c_j)<0
$$


这是一组不等式，可以让我们想到可以用线性规划来解决。但是由于只有两个变量，我们可以将每个不等式转换为一个半平面，之后判断这些半平面是否形成了一个有效的多边形。

# POJ2540

**题意：**

见链接[http://poj.org/problem?id=2540](http://poj.org/problem?id=2540)

**题解：**

与当前位置p和上一次位置p'等距离的点一定落在线段pp'的中垂线上。知道这一点之后可以不断剔除一半的平面就可以了，半平面交算法。

# ARC082C

**题意**

[https://atcoder.jp/contests/arc082/tasks/arc082_c](https://atcoder.jp/contests/arc082/tasks/arc082_c)

**题解**

一开始想了个$O(n^4)$的DP解法，但是做到一半的时候越发觉得不对劲。

后来看了题解才知道自己漏了个非常重要的条件。

考虑一个可以构成凸包的点集合$S$，以及被$S$覆盖的点集$V$。$S$对结果的贡献应该为$2^{V-S}$。

考虑$V$的子集共有$2^V$种，其中共有$2^{V-S}$个子集是$S$的超集，而这些超集有一个公共点，就是从他们中生成的凸包的顶点集合一定是$S$。因此我们可以通过枚举有多少个集合生成的凸包的顶点集合一定是$S$，每个集合都对结果贡献1，来实现$S$对结果贡献相同的效果。

而每个子集只要面积非0，那么一定能生成一个合法的凸包，即对结果贡献1。因此我们可以通过计算所有面积非0的子集。我们可以先算出所有子集，之后减去面积为0的子集（空集、单个点以及共线点）。

# 斜线转坐标轴平行线

**问题1：平面上有$n$个坐标不同的点$(x,y)$。对于顶点$(x_0,y_0)$，我们可以用过该点的两条斜率分别为$\frac{\pi}{4}$与$-\frac{\pi}{4}$的直线将整个二维平面划分为四个区域。我们可以按照四个区域相对于$(x_0,y_0)$的位置将其分为上下左右四个方向。现在我们希望对每个点统计处于其上方区域、下方区域、左边区域、右边区域（不存在与区域的划分线上）的顶点数目。**

斜线不是很好处理，我们可以发现若一个顶点$(a,b)$落在$(x_0,y_0)$的右区域上，这时候有$(a-x_0,b-y_0)$的极角落在$(-\frac{\pi}{4},\frac{\pi}{4})$。这意味着

$$
-(a-x_0)\leq b-y_0\leq a-x_0\\
\Rightarrow 
\left\{
\begin{array}{ccc}
y_0+x_0&\leq &b+a\\
y_0-x_0&\geq &b-a
\end{array}
\right.
$$

这里我们可以将所有点的坐标$(x,y)$变化成$(y-x,y+x)$，这样一个点$A$处于$B$的右区域，当且仅当这个$A$变换后的顶点处于$B$变换后的顶点的左上方。

对于其余三个方向我们可以做同样的变化。事实上由于这是线性变换，因此可以很容易得出：***右区域对应左上，左区域对应右下，上区域对应右上，而下区域对应左下***。

现在问题就变成了统计每个顶点左上，左下，右上，右下各有多少顶点，离散化后用BIT统计即可。

一道不错的类似[题目](https://codeforces.com/contest/944/problem/F)。

# 求三角形内心坐标

**问题：在圆心为原点，半径为1的圆周上，存在$n$个点（$n\leq 3000$）。现在我们随机从中取出三个不同的点，考虑三个点构成的三角形的内心坐标。问三角形内心坐标的期望。**

原题是[https://atcoder.jp/contests/agc039/tasks/agc039_d](https://atcoder.jp/contests/agc039/tasks/agc039_d)。做法是套公式。考虑复平面，根据欧拉公式有:对于所有实数$x$，有：

$$
\exp(ix)=\cos(x)+i\sin(x)
$$

同时，假设选择的三个点为$\exp(i\varphi_1),\exp(i\varphi_2),\exp(i\varphi_3)$，且满足$0\leq \varphi_1 < \varphi_2 < \varphi_3<2\pi$，那么由这三个点组成的三角形的内心一定为

$$\exp(i\frac{\varphi_1+\varphi_2}{2})-\exp(i\frac{\varphi_1+\varphi_3}{2})+\exp(i\frac{\varphi_2+\varphi_3}{2})$$

这样我们只要暴力两两枚举即可解决这个问题，时间复杂度是$O(n^2)$以及一个很大的常数，因为$sin$和$cos$函数会被调用$O(n^2)$次。

# Codeforces 1025F

**题意**

[https://codeforces.com/contest/1025/problem/F](https://codeforces.com/contest/1025/problem/F)

**题解**

首先需要发现，对于任意两个不相交的三角形，一定能找到一条线，使得两个三角形属于这条线的两侧（且与线无交点）。我们可以微微旋转这条线，直到与两个三角形都相交，这样就得到了两条切线。

剩下的就没有什么难度了，直接暴力枚举切线即可。

由于暴力枚举线，每次统计切线两侧顶点数比较麻烦，所以可以先选择切线的一个端点，将其余顶点提前排序，之后用两个指针扫描即可。

总的时间复杂度为$O(n^2log_2n)$。

# Codeforces 1019D

**题意**

[https://codeforces.com/contest/1019/problem/D](https://codeforces.com/contest/1019/problem/D)

**题解**

求三角形面积，我们知道三角形的面积可以利用叉积进行计算。我们从几何的角度进行观察，当我们选择了两个顶点之后，这两个顶点将整个平面分成两个半平面，我们要找到这样一个顶点，它距离之前选择的两个顶点的连线的距离为给定值。如果我们能提前将所有顶点按照它们到这两个顶点的连线距离进行排序，那么这个问题就只剩下二分了。

但是很显然每次选择两个顶点的复杂度为$O(n^2)$，而对所有顶点进行排序每次的时间复杂度为$O(n\log_2n)$，这样总的时间复杂度为$O(n^3\log_2n)$，这样还不如暴力枚举的$O(n^3)$时间复杂度呢。

但是神奇的事情是如果我们按照所有顶点之间的连线按照它们的极角进行排序，并依序处理，并且每次我们都利用插入排序重新维护所有顶点到连线的距离，那么在整个过程中最多只会发生$O(n^2)$次邻位交换。即我们不必每次都排序，而只需要花费$O(n\log_2n)$的时间复杂度提前预先排序后，之后总的维护排序关系的时间复杂度仅为$O(n^2)$。

但是这里比较特殊的是我们不在按照距离进行排序，而是按照与当前扫描到连线的向量的叉积进行排序（距离始终非负，而叉积允许出现负数，可以携带更多信息）。我们能看出两个顶点a,b的叉积大小关系什么时候会改变，自然是在扫描到连线$(a,b)$的时候，因此大小关系最多只会发生$O(n^2)$次改变，这里我们可以暴力修复排序。

之后对于每个扫描线，对有序列表进行二分查找即可，非常容易。

总的时间复杂度为$O(n^2\log_2n)$。

# 多维偏序问题

**问题1：给出$n$二维平面上的顶点$(x_i,y_i)$，满足$x_i,y_i\geq 0$，同时给出$m$个请求，每个请求查询左下角为$(0,0)$，右上角为$(r,t)$的矩形中有多少平面上顶点存在**

这是个典型的二维偏序问题，我们可以提前所有顶点按照$x$坐标进行排序，如果$x$坐标相同，则按照$y$坐标排序。对请求通样这样处理，并且利用双指针技术在请求范围内的所有顶点加入后回答请求，这时候请求就变成了有多少顶点的$y$坐标小于等于$t$，这可以用BIT或线段树维护。总的时间复杂度为$O((n+m)\log_2n)$。

**问题2：给出$n$三维的顶点$(x_i,y_i,z_i)$，满足$x_i,y_i,z_i\geq 0$，同时给出$m$个请求，每个请求查询左下角为$(0,0,0)$，右上角为$(r,t,d)$的矩形中有多少顶点存在**

这个是三维偏序问题，与所有偏序问题一样，我们可以通过提前排序消除一个维护带来的影响。剩下的就是二维数据的维护了，你可以选择树套树，也可以选择CDQ分治。树套树时间复杂度为$O((n+m)(\log_2n)^2)$，空间复杂度为$O(n(\log_2n)^2)$，CDQ分治的时间复杂度为$O((n+m)(\log_2(n+m))^2)$，空间复杂度为$O(n+m)$。

**问题3：给出$n$三维的顶点$(x_i,y_i,z_i)$，满足$x_i,y_i,z_i\geq 0$，同时给出$m$个请求，每个请求查询左下角为$(l,b,f)$，右上角为$(r,t,d)$的矩形中有多少顶点存在**

这个问题类似于问题2，区别在于要去我们计算的是落在一个三维矩形中有多少顶点。一种简单的方式就是利用容斥，记$S$表示落在由$(0,0,0)$与$(r,t,d)$矩形中的所有顶点，记$X$表示满足$x<l$的顶点集合，同理定义$Y$和$Z$，那么我们要计算的落在左下角为$(l,b,f)$，右上角为$(r,t,d)$的矩形中顶点数目，等价于计算：$\mid \overline{X}\cap \overline{Y}\cap\overline{Z}\mid$。这是个简单的容斥，可以转换为$2^3$个左下角为$(0,0,0)$的矩形顶点数的统计。

一道CF的[例题](https://codeforces.com/contest/1010/problem/E)。