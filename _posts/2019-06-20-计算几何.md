---
categories: algorithm
layout: post
---

- Table
{:toc}

# 切比雪夫距离

对于二维平面上两个点(a,b),(c,d)，它们的切比雪夫距离定义为


$$
\max(|a-c|,|b-d|)
$$


由于切比雪夫距离不容易被预处理，有时候需要先转换为曼哈顿距离进行处理。下面给出转换的数学公式：


$$
|a-c|+|b-d|=\max(|(a+b)-(c+d)|,|(a-b)-(c-d)|)
$$


证明方式比较简单，首先将右边公式转换为：


$$
\max(|(a-c)+(b-d)|,|(a-c)-(b-d)|)
$$


考虑两种情况，第一种$a-c$与$b-d$同号。那么右边的公式取值为$\|(a-c)+(b-d)\|=\|a-c\|+\|b-d\|$。而第二种情况下，$a-c$与$b-d$异号。那么右边的公式取值为$\|(a-c)-(b-d)\|=\|a-c\|+\|-(b-d)\|=\|a-c\|+\|b-d\|$。因此证明了等式的成立。



利用这个公式我们可以先将所有平面上的点$(x,y)$转换为$(x+y,x-y)$的形式，之后计算各个点间的切比雪夫距离就可以得到原平面的曼哈顿距离。同理，如果我们将平面上的点$(x,y)$转换为$(\frac{x+y}{2}, \frac{x-y}{2})$，之后计算各个点之间的曼哈顿距离，那么就可以得到原平面的切比雪夫距离。

# 曼哈顿距离的组合

最近从一个atcoder的[问题](https://atcoder.jp/contests/abc111/tasks/arc103_b)中学了一个新的东西，记录一下。

给定序列$2^0,2^1,2^2,\ldots, 2^k$，我们从$(0,0)$出发，我们可以不断从序列中选取一个整数x并删除，之后向四个方向中的一个方向移动距离x。重复这个过程直到序列为空。

我们可以证明通过上面这个流程可以从$(0,0)$移动到距离$(0,0)$曼哈顿距离为奇数且小于$2^{k+1}$的所有整数坐标顶点。

至于怎么构造到$(x,y)$的路径，我们可以选择最后一个数字$2^k$，之后沿着四个方向移动，判断哪种方案移动后到$(0,0)$的距离小于$2^k$，选择它即可。递归这个流程就可以构造出解决方案了。


# 斜线转坐标轴平行线

**问题1：平面上有$n$个坐标不同的点$(x,y)$。对于顶点$(x_0,y_0)$，我们可以用过该点的两条斜率分别为$\frac{\pi}{4}$与$-\frac{\pi}{4}$的直线将整个二维平面划分为四个区域。我们可以按照四个区域相对于$(x_0,y_0)$的位置将其分为上下左右四个方向。现在我们希望对每个点统计处于其上方区域、下方区域、左边区域、右边区域（不存在与区域的划分线上）的顶点数目。**

斜线不是很好处理，我们可以发现若一个顶点$(a,b)$落在$(x_0,y_0)$的右区域上，这时候有$(a-x_0,b-y_0)$的极角落在$(-\frac{\pi}{4},\frac{\pi}{4})$。这意味着

$$
-(a-x_0)\leq b-y_0\leq a-x_0\\
\Rightarrow 
\left\{
\begin{array}{ccc}
y_0+x_0&\leq &b+a\\
y_0-x_0&\geq &b-a
\end{array}
\right.
$$

这里我们可以将所有点的坐标$(x,y)$变化成$(y-x,y+x)$，这样一个点$A$处于$B$的右区域，当且仅当这个$A$变换后的顶点处于$B$变换后的顶点的左上方。

对于其余三个方向我们可以做同样的变化。事实上由于这是线性变换，因此可以很容易得出：***右区域对应左上，左区域对应右下，上区域对应右上，而下区域对应左下***。

现在问题就变成了统计每个顶点左上，左下，右上，右下各有多少顶点，离散化后用BIT统计即可。

一道不错的类似[题目](https://codeforces.com/contest/944/problem/F)。

# 求三角形内心坐标

**问题：在圆心为原点，半径为1的圆周上，存在$n$个点（$n\leq 3000$）。现在我们随机从中取出三个不同的点，考虑三个点构成的三角形的内心坐标。问三角形内心坐标的期望。**

原题是[https://atcoder.jp/contests/agc039/tasks/agc039_d](https://atcoder.jp/contests/agc039/tasks/agc039_d)。做法是套公式。考虑复平面，根据欧拉公式有:对于所有实数$x$，有：

$$
\exp(ix)=\cos(x)+i\sin(x)
$$

同时，假设选择的三个点为$\exp(i\varphi_1),\exp(i\varphi_2),\exp(i\varphi_3)$，且满足$0\leq \varphi_1 < \varphi_2 < \varphi_3<2\pi$，那么由这三个点组成的三角形的内心一定为

$$\exp(i\frac{\varphi_1+\varphi_2}{2})-\exp(i\frac{\varphi_1+\varphi_3}{2})+\exp(i\frac{\varphi_2+\varphi_3}{2})$$

这样我们只要暴力两两枚举即可解决这个问题，时间复杂度是$O(n^2)$以及一个很大的常数，因为$sin$和$cos$函数会被调用$O(n^2)$次。


# 多维偏序问题

**问题1：给出$n$二维平面上的顶点$(x_i,y_i)$，满足$x_i,y_i\geq 0$，同时给出$m$个请求，每个请求查询左下角为$(0,0)$，右上角为$(r,t)$的矩形中有多少平面上顶点存在**

这是个典型的二维偏序问题，我们可以提前所有顶点按照$x$坐标进行排序，如果$x$坐标相同，则按照$y$坐标排序。对请求通样这样处理，并且利用双指针技术在请求范围内的所有顶点加入后回答请求，这时候请求就变成了有多少顶点的$y$坐标小于等于$t$，这可以用BIT或线段树维护。总的时间复杂度为$O((n+m)\log_2n)$。

**问题2：给出$n$三维的顶点$(x_i,y_i,z_i)$，满足$x_i,y_i,z_i\geq 0$，同时给出$m$个请求，每个请求查询左下角为$(0,0,0)$，右上角为$(r,t,d)$的矩形中有多少顶点存在**

这个是三维偏序问题，与所有偏序问题一样，我们可以通过提前排序消除一个维护带来的影响。剩下的就是二维数据的维护了，你可以选择树套树，也可以选择CDQ分治。树套树时间复杂度为$O((n+m)(\log_2n)^2)$，空间复杂度为$O(n(\log_2n)^2)$，CDQ分治的时间复杂度为$O((n+m)(\log_2(n+m))^2)$，空间复杂度为$O(n+m)$。

**问题3：给出$n$三维的顶点$(x_i,y_i,z_i)$，满足$x_i,y_i,z_i\geq 0$，同时给出$m$个请求，每个请求查询左下角为$(l,b,f)$，右上角为$(r,t,d)$的矩形中有多少顶点存在**

这个问题类似于问题2，区别在于要去我们计算的是落在一个三维矩形中有多少顶点。一种简单的方式就是利用容斥，记$S$表示落在由$(0,0,0)$与$(r,t,d)$矩形中的所有顶点，记$X$表示满足$x<l$的顶点集合，同理定义$Y$和$Z$，那么我们要计算的落在左下角为$(l,b,f)$，右上角为$(r,t,d)$的矩形中顶点数目，等价于计算：$\mid \overline{X}\cap \overline{Y}\cap\overline{Z}\mid$。这是个简单的容斥，可以转换为$2^3$个左下角为$(0,0,0)$的矩形顶点数的统计。

一道CF的[例题](https://codeforces.com/contest/1010/problem/E)。

# 一些游走问题

**问题1：给出一组二维向量$v_1,v_2,\ldots,v_n$，你要选择一组符号$s_1,s_2,\ldots,s_n$，其中$s_i\in \{-1,1\}$。其中$\mid v_i \mid \leq D$，要求选择的符号满足$\mid \sum_{i=1}^ns_iv_i \mid\leq \sqrt{2}D$。**

如果只有两个向量的话，我们可以构造一个半径为$D$的圆，我们将两个向量以及其负向量加入，可以证明至少会有两个向量是处于同一个$90$度半圆内，而这个半圆内的任意两点距离都不会超过$\sqrt{2}D$，这与我们的符号也就选好了。

现在考虑一般情况，此时至少有三个向量，我们取这样三个向量以及其负向量加入到半径为$D$的圆内，此时，至少有两个向量处于同一个$60$度半圆内，而这个半圆内任意两点的距离都不会超过$D$，因此我们找出这两个向量，并合并为一个向量即可。重复这个过程直到向量数目少于3为止。如果剩余向量数为2，那么需要特殊处理，否则任意选一个符号就好了。

# 直线（线段）排序的优化技巧

考虑现在有$n=10000$条二维直线（所有直线都不与$Y$轴平行，且任意两条直线最多有一个交点）。之后给定$m=10000$个请求，第$i$个请求给定一个数$x_i$，要求将所有直线根据与直线$y=x_i$交点的纵坐标从小到大排序，并输出排序后的编号。

要计算交点坐标，有$O(1)$的做法，因此如果我们使用快速排序或选择排序，那么时间复杂度将为在$O(nm\log_2n)$。

下面我将提出一种排序技术，可以将时间复杂度优化到$O(n(m+n))$。

首先我们离线请求，将请求按照$x_i$从小到大进行排序。之后我们逐个处理请求，但是处理每个请求的时候，我们使用的排序算法是插入排序。为什么要使用最坏时间复杂度为$O(n^2)$的插入排序呢？因为插入排序在序列本身有序的情况下是线性的。下面我们给出严格的时间复杂度分析。

我们考虑插入排序的时间复杂度，其本质是扫描整个序列一次，并且每一次解决一个逆序对时对时间复杂度贡献$1$，因此当序列完全为逆序的时候，总共有${n\choose 2}$个逆序对，这时候时间复杂度为$O(n^2)$。

但是考虑到直线排序的特殊性，对于任意两条直线$A$与$B$，直线$A$与$B$的偏序关系最多改变一次（由$A<B$变成$A>B$)。即除了第一次的插入排序后，之后每个逆序对对时间复杂度的贡献仅为$O(1)$，而插入排序的其余部分是线性的。

因此总的时间复杂度为$O(n(m+n))$。