---
categories: interview
layout: post
---

- Table
{:toc}

# 前言

这篇博客会以基础知识，回答问题，以及阅读源码为主。

# spring

## spring bean的生命周期

首先spring会扫描所有的组件类，并未这些类创建对应的`BeanDefinition`，`BeanDefinition`中会存储这个类的所有信息，包括注解内容。

如果`BeanDefinition`中记录的是单例，那么spring还会创建对应的单例对象。

在实例化对象之前，spring会检查用户是否提供了`BeanFactoryPostProcessor`，如果有，则允许`BeanFactoryPostProcessor`返回一个新的Bean替代原来的Bean。

Spring是默认支持单例之间的循环依赖的。由于Spring是通过递归来创建对象并处理它们的拓扑关系的，因此它提供了两个缓存`earlySingletonObjects`和`singletonObjects`，前者存储在创建的对象，后者存储创建完成的对象。比如`A`注入`B`，`B`注入`A`，则创建`A`的时候，需要注入`B`，这时候递归调用创建`B`，但是由于需要向`B`注入`A`，这时候再次`getBean(A)`的时候，会发现`earlySingletonObjects`中存放了`A`，这时候会直接返回`A`。

下面是源码：

```java
public class SpringApplication {
    public ConfigurableApplicationContext run(String... args) {
        ...
        try {
            ...
            //这里会创建和初始化所有的Bean
            this.refreshContext(context);
            ...
        } catch (Throwable var10) {
            ...
        }
        ...
    }
}
```

跟踪`refreshContext`方法可以得到：

```java
public class SpringApplication {
	private void refreshContext(ConfigurableApplicationContext context) {
		if (this.registerShutdownHook) {
			try {
                //这里会注册负责关闭jvm时释放资源的钩子
				context.registerShutdownHook();
			}
			catch (AccessControlException ex) {
				// Not allowed in some environments.
			}
		}
        //转发调用
		refresh((ApplicationContext) context);
	}

    	@Deprecated
	protected void refresh(ApplicationContext applicationContext) {
		Assert.isInstanceOf(ConfigurableApplicationContext.class, applicationContext);
        
        //转发调用
		refresh((ConfigurableApplicationContext) applicationContext);
	}

    	protected void refresh(ConfigurableApplicationContext applicationContext) {
        //转发的终点
		applicationContext.refresh();
	}
}
```

可以看到`applicationContext.refresh()`方法会做主要工作，继续跟踪下去。

```java
public abstract class AbstractApplicationContext extends DefaultResourceLoader
		implements ConfigurableApplicationContext {
    @Override
	public void refresh() throws BeansException, IllegalStateException {
		synchronized (this.startupShutdownMonitor) {
			...
			try {
				...
                //执行BeanFactory的后置处理器
                // Invoke factory processors registered as beans in the context.
				invokeBeanFactoryPostProcessors(beanFactory);
				// Register bean processors that intercept bean creation.
                //插入Bean的后置处理器
				registerBeanPostProcessors(beanFactory);
				...
				// Instantiate all remaining (non-lazy-init) singletons.
                //创建单例对象
				finishBeanFactoryInitialization(beanFactory);
                ...
			}

			catch (BeansException ex) {
				...
			}

			finally {
				...
			}
		}
	}
}
```

Spring会将所有`BeanPostProcessor`的子类Bean作为后置处理器注册到BeanFactory中。具体源码如下：

```java
	public static void registerBeanPostProcessors(
			ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {

		String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);

		// Register BeanPostProcessorChecker that logs an info message when
		// a bean is created during BeanPostProcessor instantiation, i.e. when
		// a bean is not eligible for getting processed by all BeanPostProcessors.
		int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
		beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));

		// Separate between BeanPostProcessors that implement PriorityOrdered,
		// Ordered, and the rest.
		List<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<>();
		List<BeanPostProcessor> internalPostProcessors = new ArrayList<>();
		List<String> orderedPostProcessorNames = new ArrayList<>();
		List<String> nonOrderedPostProcessorNames = new ArrayList<>();
		for (String ppName : postProcessorNames) {
			if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
				BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
				priorityOrderedPostProcessors.add(pp);
				if (pp instanceof MergedBeanDefinitionPostProcessor) {
					internalPostProcessors.add(pp);
				}
			}
			else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
				orderedPostProcessorNames.add(ppName);
			}
			else {
				nonOrderedPostProcessorNames.add(ppName);
			}
		}

		// First, register the BeanPostProcessors that implement PriorityOrdered.
		sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
		registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);

		// Next, register the BeanPostProcessors that implement Ordered.
		List<BeanPostProcessor> orderedPostProcessors = new ArrayList<>(orderedPostProcessorNames.size());
		for (String ppName : orderedPostProcessorNames) {
			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
			orderedPostProcessors.add(pp);
			if (pp instanceof MergedBeanDefinitionPostProcessor) {
				internalPostProcessors.add(pp);
			}
		}
		sortPostProcessors(orderedPostProcessors, beanFactory);
		registerBeanPostProcessors(beanFactory, orderedPostProcessors);

		// Now, register all regular BeanPostProcessors.
		List<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<>(nonOrderedPostProcessorNames.size());
		for (String ppName : nonOrderedPostProcessorNames) {
			BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
			nonOrderedPostProcessors.add(pp);
			if (pp instanceof MergedBeanDefinitionPostProcessor) {
				internalPostProcessors.add(pp);
			}
		}
		registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);

		// Finally, re-register all internal BeanPostProcessors.
		sortPostProcessors(internalPostProcessors, beanFactory);
		registerBeanPostProcessors(beanFactory, internalPostProcessors);

		// Re-register post-processor for detecting inner beans as ApplicationListeners,
		// moving it to the end of the processor chain (for picking up proxies etc).
		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));
	}
```

创建单例对象的源码在`finishBeanFactoryInitialization`中：

```java
	protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
        ...
		// Instantiate all remaining (non-lazy-init) singletons.
        //初始化单例
		beanFactory.preInstantiateSingletons();
	}
```

它转发调用了BeanFactory的`preInstantiateSingletons`方法。源码如下：

```java
	@Override
	public void preInstantiateSingletons() throws BeansException {
		...
		// Trigger initialization of all non-lazy singleton beans...
		for (String beanName : beanNames) {
			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
            //只有单例、非抽象类、非懒加载的bean会被创建
			if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
				if (isFactoryBean(beanName)) {
					Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
                    //工厂类的创建流程
					if (bean instanceof FactoryBean) {
						FactoryBean<?> factory = (FactoryBean<?>) bean;
						boolean isEagerInit;
						if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
							isEagerInit = AccessController.doPrivileged(
									(PrivilegedAction<Boolean>) ((SmartFactoryBean<?>) factory)::isEagerInit,
									getAccessControlContext());
						}
						else {
							isEagerInit = (factory instanceof SmartFactoryBean &&
									((SmartFactoryBean<?>) factory).isEagerInit());
						}
						if (isEagerInit) {
							getBean(beanName);
						}
					}
				}
				else {
                    //普通bean的创建
					getBean(beanName);
				}
			}
		}

		...
	}
```

很显然getBean才是核心方法，我们瞅瞅：

```java
	public <T> T getBean(String name, @Nullable Class<T> requiredType, @Nullable Object... args)
			throws BeansException {

		return doGetBean(name, requiredType, args, false);
	}
    	protected <T> T doGetBean(
			String name, @Nullable Class<T> requiredType, @Nullable Object[] args, boolean typeCheckOnly)
			throws BeansException {

		String beanName = transformedBeanName(name);
		Object beanInstance;

		//优先从缓存中取，避免重复构建
		// Eagerly check singleton cache for manually registered singletons.
		Object sharedInstance = getSingleton(beanName);
		if (sharedInstance != null && args == null) {
			...
		}

		else {
			...
			try {
				...

				// Create bean instance.
				if (mbd.isSingleton()) {
                    //实例化
					sharedInstance = getSingleton(beanName, () -> {
						try {
                            //工厂方法
							return createBean(beanName, mbd, args);
						}
						catch (BeansException ex) {
							// Explicitly remove instance from singleton cache: It might have been put there
							// eagerly by the creation process, to allow for circular reference resolution.
							// Also remove any beans that received a temporary reference to the bean.
							destroySingleton(beanName);
							throw ex;
						}
					});
					beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
				}

				else if (mbd.isPrototype()) {
					// It's a prototype -> create a new instance.
					Object prototypeInstance = null;
					try {
						beforePrototypeCreation(beanName);
						prototypeInstance = createBean(beanName, mbd, args);
					}
					finally {
						afterPrototypeCreation(beanName);
					}
					beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
				}

				else {
					...
				}
			}
			catch (BeansException ex) {
				...
			}
			finally {
				...
			}
		}

		return adaptBeanInstance(name, beanInstance, requiredType);
	}
```

在第一次调用`getSingleton`方法的时候，Spring会尝试从多个缓存中获取Bean。

```java
	public Object getSingleton(String beanName) {
		return getSingleton(beanName, true);
	}
		protected Object getSingleton(String beanName, boolean allowEarlyReference) {
		// Quick check for existing instance without full singleton lock
		Object singletonObject = this.singletonObjects.get(beanName);
		//如果单例处理创建中
		if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) {
			//尝试从early缓存中获取
			singletonObject = this.earlySingletonObjects.get(beanName);
			if (singletonObject == null && allowEarlyReference) {
				//这里控制了并发
				synchronized (this.singletonObjects) {
					// Consistent creation of early reference within full singleton lock
					singletonObject = this.singletonObjects.get(beanName);
					if (singletonObject == null) {
						singletonObject = this.earlySingletonObjects.get(beanName);
						if (singletonObject == null) {
							ObjectFactory<?> singletonFactory = this.singletonFactories.get(beanName);
							if (singletonFactory != null) {
								//如果不存在于early缓存，则利用工厂构建对象，并加入到early缓存，防止创建多个对象
								//这里也是early缓存的唯一的加入点
								singletonObject = singletonFactory.getObject();
								this.earlySingletonObjects.put(beanName, singletonObject);
								this.singletonFactories.remove(beanName);
							}
						}
					}
				}
			}
		}
		return singletonObject;
	}
```

`getSingleton`方法只是调用了工厂方法，并做些前置和后置的处理。后置处理会将对象加入到单例池中。

```java
public Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {
		Assert.notNull(beanName, "Bean name must not be null");
		synchronized (this.singletonObjects) {
			Object singletonObject = this.singletonObjects.get(beanName);
			if (singletonObject == null) {
				if (this.singletonsCurrentlyInDestruction) {
					throw new BeanCreationNotAllowedException(beanName,
							"Singleton bean creation not allowed while singletons of this factory are in destruction " +
							"(Do not request a bean from a BeanFactory in a destroy method implementation!)");
				}
				if (logger.isDebugEnabled()) {
					logger.debug("Creating shared instance of singleton bean '" + beanName + "'");
				}
				//标志对象在处于创建流程
				beforeSingletonCreation(beanName);
				boolean newSingleton = false;
				boolean recordSuppressedExceptions = (this.suppressedExceptions == null);
				if (recordSuppressedExceptions) {
					this.suppressedExceptions = new LinkedHashSet<>();
				}
				try {
					singletonObject = singletonFactory.getObject();
					newSingleton = true;
				}
				catch (IllegalStateException ex) {
					// Has the singleton object implicitly appeared in the meantime ->
					// if yes, proceed with it since the exception indicates that state.
					singletonObject = this.singletonObjects.get(beanName);
					if (singletonObject == null) {
						throw ex;
					}
				}
				catch (BeanCreationException ex) {
					if (recordSuppressedExceptions) {
						for (Exception suppressedException : this.suppressedExceptions) {
							ex.addRelatedCause(suppressedException);
						}
					}
					throw ex;
				}
				finally {
					if (recordSuppressedExceptions) {
						this.suppressedExceptions = null;
					}
					//标志对象结束创建流程
					afterSingletonCreation(beanName);
				}
				if (newSingleton) {
					//加入到单例缓存中
					addSingleton(beanName, singletonObject);
				}
			}
			return singletonObject;
		}
	}

	protected void addSingleton(String beanName, Object singletonObject) {
		synchronized (this.singletonObjects) {
			this.singletonObjects.put(beanName, singletonObject);
			this.singletonFactories.remove(beanName);
			this.earlySingletonObjects.remove(beanName);
			this.registeredSingletons.add(beanName);
		}
	}
```

比较重要的就是工厂方法中的内容：

```java
	protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
			throws BeanCreationException {

		...
		try {
			// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.
			Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
			if (bean != null) {
				return bean;
			}
		}
		catch (Throwable ex) {
			throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,
					"BeanPostProcessor before instantiation of bean failed", ex);
		}

		try {
            //创建bean
			Object beanInstance = doCreateBean(beanName, mbdToUse, args);
			if (logger.isTraceEnabled()) {
				logger.trace("Finished creating instance of bean '" + beanName + "'");
			}
			return beanInstance;
		}
		catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {
			// A previously detected exception with proper bean creation context already,
			// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.
			throw ex;
		}
		catch (Throwable ex) {
			throw new BeanCreationException(
					mbdToUse.getResourceDescription(), beanName, "Unexpected exception during bean creation", ex);
		}
	}
```

继续追踪得到：

```java
Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
			throws BeanCreationException {
        // Instantiate the bean.
		BeanWrapper instanceWrapper = null;
		if (mbd.isSingleton()) {
			instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
		}
		if (instanceWrapper == null) {
            //创建具体的bean
			instanceWrapper = createBeanInstance(beanName, mbd, args);
		}
		Object bean = instanceWrapper.getWrappedInstance();
		...
		//在自动注入和调用其它生命周期之前，将对象加入到singletonFactories中，来避免循环依赖
		// Eagerly cache singletons to be able to resolve circular references
		// even when triggered by lifecycle interfaces like BeanFactoryAware.
		boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
				isSingletonCurrentlyInCreation(beanName));
		if (earlySingletonExposure) {
			if (logger.isTraceEnabled()) {
				logger.trace("Eagerly caching bean '" + beanName +
						"' to allow for resolving potential circular references");
			}
			//这里注册了一个工厂对象，它会执行aop增强等内容
			addSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));
		}

		// Initialize the bean instance.
		Object exposedObject = bean;
		try {
            //注入成员
			populateBean(beanName, mbd, instanceWrapper);
            //初始化对象，调用BeanPostProcessors
			exposedObject = initializeBean(beanName, exposedObject, mbd);
		}
		catch (Throwable ex) {
			if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {
				throw (BeanCreationException) ex;
			}
			else {
				throw new BeanCreationException(
						mbd.getResourceDescription(), beanName, "Initialization of bean failed", ex);
			}
		}

		//如果允许单例提前曝光
		if (earlySingletonExposure) {
			//如果之前没有循环引用，则这里会从factory里创建一个bean的增强对象，否则会从缓存中取
			Object earlySingletonReference = getSingleton(beanName, false);
			if (earlySingletonReference != null) {
				//单例后来没有被替换，则复用之前强化后的结果（aop增强等）
				if (exposedObject == bean) {
					exposedObject = earlySingletonReference;
				}
				//否则比较复杂
				else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
					//如果这个bean的代理对象被注入到任意一个bean中了，那么就直接抛出异常
					//这里也说明了自定义的BeanPostPorcessor的修改，aop的修改在循环引用情况下同时发生会导致异常
					String[] dependentBeans = getDependentBeans(beanName);
					Set<String> actualDependentBeans = new LinkedHashSet<>(dependentBeans.length);
					for (String dependentBean : dependentBeans) {
						if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
							actualDependentBeans.add(dependentBean);
						}
					}
					if (!actualDependentBeans.isEmpty()) {
						throw new BeanCurrentlyInCreationException(beanName,
								"Bean with name '" + beanName + "' has been injected into other beans [" +
								StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
								"] in its raw version as part of a circular reference, but has eventually been " +
								"wrapped. This means that said other beans do not use the final version of the " +
								"bean. This is often the result of over-eager type matching - consider using " +
								"'getBeanNamesForType' with the 'allowEagerInit' flag turned off, for example.");
					}
				}
			}
		}

		...
	}
```

其中`getEarlyBeanReference`是一个比较重要的方法，考虑到Spring中大量使用了代理，而注入的时候自然需要代理已经被创建完成。但是代理的创建一般发生在初始化完成raw实例后才发生，因此在循环引用的时候会出问题。故这里允许提前对对象进行代理。

```java
	protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {
		Object exposedObject = bean;
		if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
			for (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) {
				//org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator负责aop工作，生成一个新的代理，它的getEarlyBeanReference和postProcessAfterInitialization方法都会调用wrapIfNecessary方法，其中会为对象创建对应的代理
				exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);
			}
		}
		return exposedObject;
	}

```

在`createBeanInstance`的时候用的是反射的方式来创建对象：

```java
	protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
		// Make sure bean class is actually resolved at this point.
		Class<?> beanClass = resolveBeanClass(mbd, beanName);

		if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) {
			throw new BeanCreationException(mbd.getResourceDescription(), beanName,
					"Bean class isn't public, and non-public access not allowed: " + beanClass.getName());
		}

		Supplier<?> instanceSupplier = mbd.getInstanceSupplier();
		if (instanceSupplier != null) {
			return obtainFromSupplier(instanceSupplier, beanName);
		}

		if (mbd.getFactoryMethodName() != null) {
			return instantiateUsingFactoryMethod(beanName, mbd, args);
		}

		// Shortcut when re-creating the same bean...
		boolean resolved = false;
		boolean autowireNecessary = false;
		if (args == null) {
			synchronized (mbd.constructorArgumentLock) {
				if (mbd.resolvedConstructorOrFactoryMethod != null) {
					resolved = true;
					autowireNecessary = mbd.constructorArgumentsResolved;
				}
			}
		}
		if (resolved) {
			if (autowireNecessary) {
				return autowireConstructor(beanName, mbd, null, null);
			}
			else {
				return instantiateBean(beanName, mbd);
			}
		}

		// Candidate constructors for autowiring?
		Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
		if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
				mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
			return autowireConstructor(beanName, mbd, ctors, args);
		}

		// Preferred constructors for default construction?
		ctors = mbd.getPreferredConstructors();
		if (ctors != null) {
			return autowireConstructor(beanName, mbd, ctors, null);
		}

		// No special handling: simply use no-arg constructor.
		return instantiateBean(beanName, mbd);
	}
```

这里创建的对象还是一个raw对象，没有执行注入操作。注入操作发生在`populateBean`方法中。看看源码：

```java
protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
		...
		boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
		boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);

		PropertyDescriptor[] filteredPds = null;
		if (hasInstAwareBpps) {
            //实现注入
			if (pvs == null) {
				pvs = mbd.getPropertyValues();
			}
			for (InstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().instantiationAware) {
                //@resource由class org.springframework.context.annotation.CommonAnnotationBeanPostProcessor负责注入
                //@autowire由class org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor负责注入
                //两者的实现基本雷同，可以认为@resource和@autowire是相同的作用
				PropertyValues pvsToUse = bp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
				if (pvsToUse == null) {
					if (filteredPds == null) {
						filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
					}
					pvsToUse = bp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
					if (pvsToUse == null) {
						return;
					}
				}
				pvs = pvsToUse;
			}
		}
		...
	}
```

最后需要调用BeanPostProcessor来替代原来的对象，代码是调用`initializeBean`。

```java
protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {
		if (System.getSecurityManager() != null) {
			AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
				invokeAwareMethods(beanName, bean);
				return null;
			}, getAccessControlContext());
		}
		else {
			invokeAwareMethods(beanName, bean);
		}

		Object wrappedBean = bean;
		if (mbd == null || !mbd.isSynthetic()) {
            //调用BeanPostProcessor替代原来的Bean
			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
		}

		try {
            //调用初始化方法，需要Bean实现InitializingBean
			invokeInitMethods(beanName, wrappedBean, mbd);
		}
		catch (Throwable ex) {
			throw new BeanCreationException(
					(mbd != null ? mbd.getResourceDescription() : null),
					beanName, "Invocation of init method failed", ex);
		}
		if (mbd == null || !mbd.isSynthetic()) {
            //再次调用后置处理器，这次调用的是postProcessAfterInitialization
			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
		}

		return wrappedBean;
	}
```

其中`applyBeanPostProcessorsBeforeInitialization`会调用Bean后置处理器。

```java
	@Override
	public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)
			throws BeansException {

		Object result = existingBean;
		for (BeanPostProcessor processor : getBeanPostProcessors()) {
            //调用后置处理器，后置处理
            //class org.springframework.context.annotation.CommonAnnotationBeanPostProcessor会处理postConstruct等注解
			Object current = processor.postProcessBeforeInitialization(result, beanName);
			if (current == null) {
				return result;
			}
			result = current;
		}
		return result;
	}
```


## IOC

IOC全意为控制反转。传统情况下，A依赖B，则会在A中new一个B。但是这样会导致A对B的强耦合（A知道了B的具体实现，这意味着如果之后出现一个B的更加高效的B的实现类，那么A必须通过重写代码才能使用新的实现类）。依赖注入是一种控制反转的实现方式，A的组件将不通过A中的代码创建，而是由外部传入。这样话仅仅外部的代码出现了耦合。而外部的代码一般由容器提供，比如spring。

## spring boot的自动装配

spring boot中提供了`@Import`注解，这个注解会将一些类作为`BeanDefinition`加入到Spring中，而不需要使用`Component`等注解。下面是mybatis的`MapperScan`类的内容：

```java
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
@Documented
@Import({MapperScannerRegistrar.class})
@Repeatable(MapperScans.class)
public @interface MapperScan {
...
}
```

同时如果一个Bean实现了`ImportSelector`接口，那么它的`selectImports`方法的返回值也会被作为`BeanDefinition`加入到Spring中。比如下面是缓存相关的一个ImportSelector。

```java
	static class CacheConfigurationImportSelector implements ImportSelector {

		@Override
		public String[] selectImports(AnnotationMetadata importingClassMetadata) {
			CacheType[] types = CacheType.values();
			String[] imports = new String[types.length];
			for (int i = 0; i < types.length; i++) {
				imports[i] = CacheConfigurations.getConfigurationClass(types[i]);
			}
			return imports;
		}

	}
```

还有一种比较重要的接口，叫做`ImportBeanDefinitionRegistrar`，它可以自由地增加一些自定义的BeanDefinition。比如之前代码中出现的`MapperScannerRegistrar`就实现了这个接口，其中加入了`MapperScannerConfigurer`类。

```java
public class MapperScannerRegistrar implements ImportBeanDefinitionRegistrar, ResourceLoaderAware {
   public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        AnnotationAttributes mapperScanAttrs = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(MapperScan.class.getName()));
        if (mapperScanAttrs != null) {
            this.registerBeanDefinitions(importingClassMetadata, mapperScanAttrs, registry, generateBaseBeanName(importingClassMetadata, 0));
        }

    }

    void registerBeanDefinitions(AnnotationMetadata annoMeta, AnnotationAttributes annoAttrs, BeanDefinitionRegistry registry, String beanName) {
        BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);
        builder.addPropertyValue("processPropertyPlaceHolders", true);
        Class<? extends Annotation> annotationClass = annoAttrs.getClass("annotationClass");
        if (!Annotation.class.equals(annotationClass)) {
            builder.addPropertyValue("annotationClass", annotationClass);
        }

        Class<?> markerInterface = annoAttrs.getClass("markerInterface");
        if (!Class.class.equals(markerInterface)) {
            builder.addPropertyValue("markerInterface", markerInterface);
        }

        Class<? extends BeanNameGenerator> generatorClass = annoAttrs.getClass("nameGenerator");
        if (!BeanNameGenerator.class.equals(generatorClass)) {
            builder.addPropertyValue("nameGenerator", BeanUtils.instantiateClass(generatorClass));
        }

        Class<? extends MapperFactoryBean> mapperFactoryBeanClass = annoAttrs.getClass("factoryBean");
        if (!MapperFactoryBean.class.equals(mapperFactoryBeanClass)) {
            builder.addPropertyValue("mapperFactoryBeanClass", mapperFactoryBeanClass);
        }

        String sqlSessionTemplateRef = annoAttrs.getString("sqlSessionTemplateRef");
        if (StringUtils.hasText(sqlSessionTemplateRef)) {
            builder.addPropertyValue("sqlSessionTemplateBeanName", annoAttrs.getString("sqlSessionTemplateRef"));
        }

        String sqlSessionFactoryRef = annoAttrs.getString("sqlSessionFactoryRef");
        if (StringUtils.hasText(sqlSessionFactoryRef)) {
            builder.addPropertyValue("sqlSessionFactoryBeanName", annoAttrs.getString("sqlSessionFactoryRef"));
        }

        List<String> basePackages = new ArrayList();
        basePackages.addAll((Collection)Arrays.stream(annoAttrs.getStringArray("value")).filter(StringUtils::hasText).collect(Collectors.toList()));
        basePackages.addAll((Collection)Arrays.stream(annoAttrs.getStringArray("basePackages")).filter(StringUtils::hasText).collect(Collectors.toList()));
        basePackages.addAll((Collection)Arrays.stream(annoAttrs.getClassArray("basePackageClasses")).map(ClassUtils::getPackageName).collect(Collectors.toList()));
        if (basePackages.isEmpty()) {
            basePackages.add(getDefaultBasePackage(annoMeta));
        }

        String lazyInitialization = annoAttrs.getString("lazyInitialization");
        if (StringUtils.hasText(lazyInitialization)) {
            builder.addPropertyValue("lazyInitialization", lazyInitialization);
        }

        String defaultScope = annoAttrs.getString("defaultScope");
        if (!"".equals(defaultScope)) {
            builder.addPropertyValue("defaultScope", defaultScope);
        }

        builder.addPropertyValue("basePackage", StringUtils.collectionToCommaDelimitedString(basePackages));
        registry.registerBeanDefinition(beanName, builder.getBeanDefinition());
    }
}
```

我们也可以尝试写一个自己的`ImportBeanDefinitionRegistrar`的实现类，通过SPI机制来从`META-INF/spring.factories`文件中加载具体的类型。先创建一个类型：

```java
public class CustomAutoConfiguration implements ImportBeanDefinitionRegistrar, BeanClassLoaderAware {
    ClassLoader loader;

    @Override
    public void setBeanClassLoader(ClassLoader classLoader) {
        this.loader = classLoader;
    }

    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        List<String> names = SpringFactoriesLoader.loadFactoryNames(CustomAutoConfiguration.class, loader);
        for (String name : names) {
            if (registry.containsBeanDefinition(name)) {
                continue;
            }
            BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(name);
            registry.registerBeanDefinition(name, builder.getBeanDefinition());
        }
    }
}
```

之后在`META-INF/spring.factories`下面加入以下内容

```properties
com.daltao.registrar.CustomAutoConfiguration=\
com.daltao.service.A,\
com.daltao.service.B,\
com.daltao.service.C
```

之后是启动类：

```java
@SpringBootApplication
@Import(CustomAutoConfiguration.class)
public class Application {
    public static void main(String[] args) throws Exception {
        ConfigurableApplicationContext run = SpringApplication.run(Application.class, args);
        System.out.println(run.getBean(A.class));
        System.out.println(run.getBean(B.class));
        System.out.println(run.getBean(C.class));
    }
}
```

可以发现即使`A,B,C`上没有加Component注解，也会被加入到IOC容器当中。

接下来我们考虑`SpringBootApplication`这个注解中自带的注册方式。

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
...
}
```

其中`EnableAutoConfiguration`会允许自动注册。

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import(AutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration {

	/**
	 * Environment property that can be used to override when auto-configuration is
	 * enabled.
	 */
	String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration";

	/**
	 * Exclude specific auto-configuration classes such that they will never be applied.
	 * @return the classes to exclude
	 */
	Class<?>[] exclude() default {};

	/**
	 * Exclude specific auto-configuration class names such that they will never be
	 * applied.
	 * @return the class names to exclude
	 * @since 1.3.0
	 */
	String[] excludeName() default {};

}
```

其中引入了`AutoConfigurationImportSelector`。再继续看下去。

```java
public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware,
		ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {
	@Override
	public String[] selectImports(AnnotationMetadata annotationMetadata) {
		if (!isEnabled(annotationMetadata)) {
			return NO_IMPORTS;
		}
		AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);
		return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());
	}

	protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {
		if (!isEnabled(annotationMetadata)) {
			return EMPTY_ENTRY;
		}
		AnnotationAttributes attributes = getAttributes(annotationMetadata);
		List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);
		configurations = removeDuplicates(configurations);
		Set<String> exclusions = getExclusions(annotationMetadata, attributes);
		checkExcludedClasses(configurations, exclusions);
		configurations.removeAll(exclusions);
		configurations = getConfigurationClassFilter().filter(configurations);
		fireAutoConfigurationImportEvents(configurations, exclusions);
		return new AutoConfigurationEntry(configurations, exclusions);
	}

	protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
		//这里去spring.factories文件中查找EnableAutoConfiguration的相关类型
		List<String> configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),
				getBeanClassLoader());
		Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you "
				+ "are using a custom packaging, make sure that file is correct.");
		return configurations;
	}

	protected Class<?> getSpringFactoriesLoaderFactoryClass() {
		return EnableAutoConfiguration.class;
	}
}
```

而在`spring-boot-autoconfigure`下的`spring.factories`文件中，已经手写了非常多的与`EnableAutoConfiguration`相关的配置类。

```properties
# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\
org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\
org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\
org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\
org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\
org.springframework.boot.autoconfigure.context.LifecycleAutoConfiguration,\
org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\
org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\
org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ReactiveElasticsearchRestClientAutoConfiguration,\
org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.neo4j.Neo4jReactiveDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.neo4j.Neo4jReactiveRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.r2dbc.R2dbcDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.r2dbc.R2dbcRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\
org.springframework.boot.autoconfigure.elasticsearch.ElasticsearchRestClientAutoConfiguration,\
org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\
org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\
org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\
org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\
org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\
org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\
org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\
org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\
org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\
org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\
org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\
org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\
org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\
org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\
org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\
org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\
org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\
org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\
org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\
org.springframework.boot.autoconfigure.availability.ApplicationAvailabilityAutoConfiguration,\
org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\
org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\
org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\
org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\
org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\
org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\
org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\
org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\
org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\
org.springframework.boot.autoconfigure.neo4j.Neo4jAutoConfiguration,\
org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\
org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\
org.springframework.boot.autoconfigure.r2dbc.R2dbcAutoConfiguration,\
org.springframework.boot.autoconfigure.r2dbc.R2dbcTransactionManagerAutoConfiguration,\
org.springframework.boot.autoconfigure.rsocket.RSocketMessagingAutoConfiguration,\
org.springframework.boot.autoconfigure.rsocket.RSocketRequesterAutoConfiguration,\
org.springframework.boot.autoconfigure.rsocket.RSocketServerAutoConfiguration,\
org.springframework.boot.autoconfigure.rsocket.RSocketStrategiesAutoConfiguration,\
org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\
org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\
org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\
org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\
org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\
org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,\
org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,\
org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\
org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\
org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\
org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\
org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\
org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\
org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\
org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\
org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\
org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\
org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\
org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\
org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\
org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\
org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\
org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\
org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\
org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\
org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\
org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\
org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration
```

当然这么多类需要进行装配，很显然是非常慢的，但是实际上我们启动一个简单的Spring boot项目的时候并不会装配所有的Bean，因为它们的类型上都有通过`Conditional`注解来描述一些特殊条件，只有这些条件满足了才会装配。比如`CacheAutoConfiguration`。

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(CacheManager.class)
@ConditionalOnBean(CacheAspectSupport.class)
@ConditionalOnMissingBean(value = CacheManager.class, name = "cacheResolver")
@EnableConfigurationProperties(CacheProperties.class)
@AutoConfigureAfter({ CouchbaseDataAutoConfiguration.class, HazelcastAutoConfiguration.class,
		HibernateJpaAutoConfiguration.class, RedisAutoConfiguration.class })
@Import({ CacheConfigurationImportSelector.class, CacheManagerEntityManagerFactoryDependsOnPostProcessor.class })
public class CacheAutoConfiguration {
}
```


# Spring

- [一口气说出 6种，@Transactional注解的失效场景](https://juejin.cn/post/6844904096747503629)
- [spring的proxy-target-class详解](https://blog.csdn.net/shaoweijava/article/details/76474652)

# 分布式事务

- [通俗易懂 强一致性、弱一致性、最终一致性、读写一致性、单调读、因果一致性 的区别与联系](https://zhuanlan.zhihu.com/p/67949045)
- [分布式事务：2PC、3PC、SAGA、TCC](https://zhuanlan.zhihu.com/p/142136446)
- [TCC和XA的区别](https://blog.csdn.net/Maxiao1204/article/details/103618851)
- [分布式两阶段提交和三阶段提交](https://www.huaweicloud.com/articles/76e2673f386af0ea10d5553885704814.html)

# 网络

- [十分钟搞懂HTTP和HTTPS协议？](https://zhuanlan.zhihu.com/p/72616216)
- [五层网络协议，各层功能，各层协议](https://blog.csdn.net/qq_22238021/article/details/80279001)
- [TCP中已有SO_KEEPALIVE选项，为什么还要在应用层加入心跳包机制?? - iEternity的回答 - 知乎](https://www.zhihu.com/question/40602902/answer/209148428)
- [Netty(三) 什么是 TCP 拆、粘包？如何解决？](https://juejin.cn/post/6844903651652141070#heading-1)
- [网络编程中的线程模型](https://qiuyadongsite.github.io/2019/04/11/framework4-highConcurrent-30/)
- [Reactor线程模型 - 每天晒白牙的文章 - 知乎](https://zhuanlan.zhihu.com/p/69341619)
- [关于三次握手和四次挥手，面试官想听到怎样的回答？ 车小胖的回答 - 知乎](https://www.zhihu.com/question/271701044/answer/398114686)
- [关于三次握手和四次挥手，面试官想听到怎样的回答？ - 牛客网的回答 - 知乎](https://www.zhihu.com/question/271701044/answer/1808988570)

# MySQL

- [MySQL事务提交过程（一）](https://www.cnblogs.com/exceptioneye/p/5451960.html)
- [mysql主从复制原理](https://zhuanlan.zhihu.com/p/96212530)
- [为什么生产环境中B+树的高度总是3-4层？](https://zhuanlan.zhihu.com/p/86137284)
- [深入理解了MySQL，你才能说熟悉数据库。](https://zhuanlan.zhihu.com/p/66352669)
- [MySQL · 专家投稿 · InnoDB物理行中null值的存储的推断与验证](https://developer.aliyun.com/article/71921)
- [Mysql 中 MyISAM 和 InnoDB 的区别有哪些？ - oscarwin的回答 - 知乎](https://www.zhihu.com/question/20596402/answer/211492971)
- [解决死锁之路（终结篇） - 再见死锁](https://www.aneasystone.com/archives/2018/04/solving-dead-locks-four.html)
- [Mysql 查询主键未指定排序时的默认排序问题](https://juejin.cn/post/6844903861086322702)
- [分库分表下分页查询解决方案](https://blog.csdn.net/lvqinglou/article/details/100065995)
- [Sharding-JDBC 的基本用法和基本原理](https://juejin.cn/post/6894046209552416782)
- [mysql半同步复制跟无损半同步区别](https://www.huaweicloud.com/articles/52c0e6b49461911ec5d4dfb268753733.html)
- [MySQL无损复制](https://developer.aliyun.com/article/59258)
- [InnoDB 的意向锁有什么作用？ - 大王叫我来巡山的回答 - 知乎](https://www.zhihu.com/question/51513268/answer/147733422)
- [Mysql性能优化：什么是索引下推？ - 不才陈某的文章 - 知乎](https://zhuanlan.zhihu.com/p/121084592)
- [MySQL 性能优化神器 Explain 使用分析](https://segmentfault.com/a/1190000008131735)
- [MySQL 慢查询日志解析](https://zhuanlan.zhihu.com/p/112307303)
- [MySQL 执行计划中Extra(Using where,Using index,Using index condition,Using index,Using where)的浅析](https://www.cnblogs.com/kerrycode/p/9909093.html)
- [Using where的含义](https://stackoverflow.com/a/9534935)
- [深入理解MDL元数据锁](https://juejin.cn/post/6844904014769979400)

# 操作系统

- [零拷贝(Zero-copy) 浅析及其应用](https://www.cnblogs.com/rickiyang/p/13265043.html)
- [select、poll、epoll之间的区别(搜狗面试)](https://www.cnblogs.com/aspirant/p/9166944.html)
- [彻底搞懂epoll高效运行的原理](https://www.jianshu.com/p/31cdfd6f5a48)
- [计算机存储术语: 扇区，磁盘块，页](https://zhuanlan.zhihu.com/p/117375905)

# Java

- [CMS,G1 和 ZGC](https://huzb.me/2019/02/21/CMS-G1%E5%92%8CZGC/)
- [java偏向锁，轻量级锁与重量级锁为什么会相互膨胀? - Adsf的回答 - 知乎](https://www.zhihu.com/question/53826114/answer/160222185)
- [Java线程的6种状态及切换(透彻讲解)](https://blog.csdn.net/pange1991/article/details/53860651)
- [java的gc为什么要分代？ - RednaxelaFX的回答 - 知乎](https://www.zhihu.com/question/53613423/answer/135743258)
- [调试排错 - JVM 调优参数](https://pdai.tech/md/java/jvm/java-jvm-param.html)
- [垃圾收集器GC中parallel scavenge收集器为什么不能CMS配合使用？](https://blog.csdn.net/qq_33915826/article/details/79672772)
- [阿里面试官最喜欢问的21个HashMap面试题](https://www.bilibili.com/read/cv6114752/)
- [Java 并发高频面试题：聊聊你对 AQS 的理解？](https://juejin.cn/post/6844903895622221832)
- [Java 多线程（五）－ 理解 Condition 和 条件变量](https://www.jianshu.com/p/82bdd60ff816)
- [Java死锁排查和Java CPU 100% 排查的步骤整理和OOM FullGc案例](https://blog.csdn.net/u010648555/article/details/80721815)
- [CAS 原理和缺陷](https://huzb.me/2018/09/03/CAS%E5%8E%9F%E7%90%86%E5%92%8C%E7%BC%BA%E9%99%B7/)
- [内存屏障](https://www.jianshu.com/p/2ab5e3d7e510)
- [深入分析 ThreadLocal 内存泄漏问题](https://zhuanlan.zhihu.com/p/56214714)
- [​死锁的产生、防止、避免、检测和解除](https://zhuanlan.zhihu.com/p/61221667)
- [synchronized加锁，是公平锁还是非公平锁？ - Long的回答 - 知乎](https://www.zhihu.com/question/48140804/answer/388323557)
- [ClassNotFoundException和NoClassDefFoundError的区别](https://segmentfault.com/a/1190000021292121)
- [JVM: GC过程总结(minor GC 和 Full GC)](https://blog.csdn.net/weixin_42615068/article/details/102813947)
- [JEP 122: Remove the Permanent Generation](http://openjdk.java.net/jeps/122)

# 消息队列

- [你的消息队列如何保证消息不丢失，且只被消费一次，这篇就教会你（kafka）](https://cloud.tencent.com/developer/article/1664494)
- [解决RabbitMQ消息丢失问题和保证消息可靠性（一）](https://juejin.cn/post/6844903906074427400)
- [RabbitMQ消息丢失问题和保证消息可靠性-消费端不丢消息和HA（二）](https://juejin.cn/post/6844903927696064526)
- [RabbitMQ高可用方案总结](https://www.cnblogs.com/dreamroute/p/6251180.html)
- [RabbitMQ延时队列原理讲解](https://blog.csdn.net/Leon_Jinhai_Sun/article/details/106041470)
- [延迟消息的五种实现方案](https://zhuanlan.zhihu.com/p/343674088)
- [面试题:如何保证消息不被重复消费？](https://cloud.tencent.com/developer/article/1444056)

# dubbo

- [dubbo微服务之间流水号的隐式传递](https://blog.csdn.net/wjlucky262/article/details/105907636)

# 系统设计

- [system-design-primer](https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md)
- [TPS、QPS和系统吞吐量的区别和理解](https://blog.csdn.net/u010889616/article/details/83245695)

# 数据结构

- [不同平衡树的比较](https://re-ra.xyz/%E4%B8%8D%E5%90%8C%E5%B9%B3%E8%A1%A1%E6%A0%91%E7%9A%84%E6%AF%94%E8%BE%83/#red-black-trees)

# 分布式锁

- [Lua脚本在redis分布式锁场景的运用](https://www.cnblogs.com/demingblog/p/9542124.html#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81)
- [面试必问：分布式锁实现之zk（Zookeeper）](https://www.cnblogs.com/aobing/p/12650036.html)

# 面试话术

- [面试中该如何回答，面试官问的“还有什么问题问我吗？](https://blog.csdn.net/Cheng_MY/article/details/102894281)

# zookeeper

- [Zookeeper 学习笔记](https://huzb.me/2019/07/14/zookeeper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/)

# 认证

- [理解OAuth 2.0](https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)
- [JWT为什么要设置2个token? - find goo的回答 - 知乎](https://www.zhihu.com/question/316165120/answer/1183051534)

# 算法

- [HashedWheelTimer算法详解](https://segmentfault.com/a/1190000010987765)

# RPC

- [Dubbo的负载均衡](https://dubbo.apache.org/zh/docs/v2.7/user/examples/loadbalance/)

# Kafka

- [Kafka架构图](https://zhuanlan.zhihu.com/p/38269875)

# redis

- [一文揭秘单线程的Redis为什么这么快?](https://zhuanlan.zhihu.com/p/57089960)
- [深入剖析Redis系列(三)-Redis集群模式搭建与原理](https://zhuanlan.zhihu.com/p/44537690)