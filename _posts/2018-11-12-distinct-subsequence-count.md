---
categories: problem
layout: post
---

# 问题提出

上周的leetcode周赛最后一道题很有意思，但是比赛的过程中没有想到解法，后来比赛结束后在discuss中看到了解法。现在做个笔记：

问题：有一个字符串s(仅包含小写字母)，其子序列为s中去除某些位置的字符后剩余字符按先后顺序重组而成，比如abc中ab，ac均为s的子序列。问s的所有不同子序列的个数？

# 解法

问题的解法也非常有趣。

首先我们定义cnts\[i]\[j]表示s[0..i]中以字符j结尾的所有不同的子序列的个数。

那么假设s[i]=c。

那么对于任意k!=c，cnts\[i]\[k]一定等于cnts\[i-1][k]，原因是所有以k结尾的s[0..i]的子序列一定也是s[0..(i-1)]的子序列。

而对于cnts\[i]\[c]统计的任意子序列u，我们可以保证u的最后一个字符为c，而其倒数第二个字符仅可能取'a'~'z'，或者不存在（此时u="a")。

我们先仅考虑u长度大于1的情况。首先我们可以保证u在移除最后一个字符c后得到的序列u'一定是s[0..(i-1)]的子序列，且对于s[0..i]的以c结尾的不同子序列x，y，其移除最后一个字符后得到的x',y'一定不同。同样对于所有不同的s[0..(i-1)]的子序列在增加一个c后一定会得到以c结尾的s[0..i]的子序列，且两两不同。而对于u长度为1时仅有一种可能。

因此cnts\[i]\[c]=cnts\[i-1]\['a']+...+cnts\[i-1]\['z']+1。

解法可以优化为下面代码形式：

```java
f(s):
    cnts = new int[26];
    sum = 0;
    for(int i = 0; i < |s|; i++)
        int val = sum + 1;
        sum = sum - cnts[s[i] - 'a'] + val;
        cnts[s[i] - 'a']= val;
    result = 0;
    for(int i = 0; i < 26; i++)
        result += cnts[i];
    return result;
```

上面代码的时间复杂度为O(|s|)，空间复杂度为O(26)。