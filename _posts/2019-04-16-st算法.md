---
categories: algorithm
layout: post
---

- Table
{:toc}

# 区间最值

st算法可以用于计算区间最值，不同于其它区间最值查询算法，st算法单次查询的时间复杂度仅为$O(1)$。下面讲解st算法。

假设区间的范围为$[0,n]$。我们首先定义函数$f(i,j)$表示区间$[i,i+2^j)$的最小值。很显然我们可以给出递推公式：


$$
f(i,j)=min(f(i,j-1),f(i+2^{j-1},j-1))
$$


对于$i$，共有$0$到$n$总选择，而对于$j$，共有$0$到$\lfloor \log_2n \rfloor$种选择。总计对$f$的调用有$O(n\log2_n)$种可能，我们可以提前通过上面的递推公式以$O(n\log2_n)$的时空复杂度预处理得到。之后的所有$f$调用的时间复杂度都为$O(1)$，这也是st算法能够在$O(1)$时间复杂度内回答区间最小值的关键。

现在，假设我们要查询区间$[l,r]$的最小值。我们知道区间$[l,r]$的最小值，也就是$[l,r+1)$的最小值。记$k=\lfloor \log_2(r+1-l) \rfloor$，则$[l,r+1)$的最小值必定是$[l, l+2^k)$的最小值和$[r+1-2^k,r+1)$的最小值中的较小者，即$min(f(l,k), f(r+1-k,k))$。

上面的操作几乎可以认为是$O(1)$了，美中不足的是我们需要计算$\lfloor \log_2(r+1-l) \rfloor$。一般对于这种操作，各种语言都提供了接近$O(1)$的奇技淫巧，但是如果追求严格，可以以预先处理的方式以$O(n)$的时空复杂度计算$\lfloor \log_2x \rfloor$，其中$x=1,2,\ldots,n+1$。这样对数向下取整也能保证以$O(1)$的时间复杂度得到。

上面预处理的总的时间复杂度和空间复杂度均为$O(n\log_2n)$，而每次查询区间最值仅需要$O(1)$的时间复杂度。

# LCA

LCA问题可以转换为区间最值问题，之后利用st算法就可以高效求解了。

首先我们对树进行深度优先搜索，当第一次访问结点$u$时，将$u.enter$记录为当前时间戳。之后比较特殊的是，在访问$u$时，我们首先将$u$加入某个列表尾部，之后每次访问$u$的子结点返回后，都要将$u$再次加入列表尾部，访问$u$完毕后将$u.leave$设置为当前时间戳。

第一次将$u$加入该列表尾部的费用由$u$支付，之后每次访问某个结点$v$后再次加入$u$的费用由边$(u,v)$支付，每次支付的费用为1，而一株大小为$n$的树中，结点数目为$n$，边的数目为$n-1$，因此最终搜索完毕后列表的大小为$2n-1$。

```java
void dfs(root){
    root.enter = list.size();
    list.add(root);
    for(Node child : root.children)
    {
        dfs(child);
        list.add(root);
    }
    root.leave = list.size() - 1;
}
```

接下来，每次查询结点$x=lca(u,v)$，等价于查询list区间$I=[min(u.enter,v.enter), max(u.leave, v.leave)]$中$enter$值最小的哪个结点。这就是我们上面聊到的区间最值问题。

下面证明一下下面几点：

1. 区间$I$中一定包含$u$与$v$的$x$。
2. $x$是区间$I$中拥有最小$enter$值的结点。

如果$u=v$，落在区间$I$中的结点都是$u$的子结点，因此两条命题都是满足的。下面都认为$u.enter < v.enter$，由于$x=lca(u,v)$，那么可知$u$和$v$分别处在$x$下不同的两个子树中，因此在从含$u$的子树中递归返回后，$x$会被加入到列表尾部，之后会访问$v$，很显然命题1是满足的。并且在$x$返回之前，中间不会加入其它$x$的祖先结点，即$x$是拥有最小$enter$值节点，命题2是满足的。上面的推理对于$u=x$的情况也是一样的。

