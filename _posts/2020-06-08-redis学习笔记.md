---
categories: technology
layout: post
---

- Table
{:toc}

# 安装配置

## windows安装

从[github](https://github.com/microsoftarchive/redis)上下载windows版本。

之后解压就好了。

# 数据类型

## 字符串

Redis用动态字符串(SDS，Simple dynamic string)的类型来保存字符串。

定义在`sds.h`中的`sdshdr`中。源码在`sds.h`和`sds.c`中。

比较关键的是，当要求分配后的空间为$n$，那么实际分配的空间为$\min(2n,n+2^{20})$，多出来的部分称为预留空间。源码：

```c
sds sdsMakeRoomFor(sds s, size_t addlen) {
...
    newlen = (len+addlen);
    //小于1M就预留相同空间
    if (newlen < SDS_MAX_PREALLOC)
        newlen *= 2;
    else
    //>=1M，则只预留1M
        newlen += SDS_MAX_PREALLOC;
...
}
```

## 链表

定义在`adlist.h`和`adlist.c`文件中。

## 字典

字典的实现为哈希表，通过链表解决冲突。其实现在`dict.h`和`dict.c`文件中。

类似于java中的实现，字典的bucket数目始终为2的幂，这样就可以用且运算来确定哈希值对应的槽了。

```c
//从4开始增加，直到找到2^c，满足2^{c-1}<size 且 2^c>=size
/* Our hash table capability is a power of two */
static unsigned long _dictNextPower(unsigned long size)
{
    unsigned long i = DICT_HT_INITIAL_SIZE;

    if (size >= LONG_MAX) return LONG_MAX + 1LU;
    while(1) {
        if (i >= size)
            return i;
        i *= 2;
    }
}
```

记$\alpha$为哈希表中元素数目与槽数的比例。扩张比较复杂，一般情况下只需要$\alpha\geq 1$就会发生，但是如果正在执行BGSAVE或BGREWRITEAOF等持久化命令，则只有在$\alpha\geq 6$的时候才会发生。这是因为redis在做持久化时会开启一个子进程，通过共享内存来做落盘操作，操作系统对于进程间共享的内存会采用写时复制的技术，因此这期间redis会通过提高扩张的阈值来避免扩张带来的写入操作，从而节约内存。同理当$\alpha<0.1$就会减少bucket，释放内存，但是如果在执行BGSAVE或BGREWRITEAOF等持久化命令，就不会执行缩小操作。

```c
//是否支持缩放，如果元素数/bucket数>dict_force_resize_ratio，则会强制发生哈希，即使不支持缩放
/* Using dictEnableResize() / dictDisableResize() we make possible to
 * enable/disable resizing of the hash table as needed. This is very important
 * for Redis, as we use copy-on-write and don't want to move too much memory
 * around when there is a child performing saving operations.
 *
 * Note that even when dict_can_resize is set to 0, not all resizes are
 * prevented: a hash table is still allowed to grow if the ratio between
 * the number of elements and the buckets > dict_force_resize_ratio. */
static int dict_can_resize = 1;
static unsigned int dict_force_resize_ratio = 5;
...
//缩小哈希表
/* Resize the table to the minimal size that contains all the elements,
 * but with the invariant of a USED/BUCKETS ratio near to <= 1 */
int dictResize(dict *d)
{
    unsigned long minimal;

    //只有在允许缩放以及没有处于哈希中才能进行缩小操作
    if (!dict_can_resize || dictIsRehashing(d)) return DICT_ERR;
    minimal = d->ht[0].used;
    if (minimal < DICT_HT_INITIAL_SIZE)
        minimal = DICT_HT_INITIAL_SIZE;
    return dictExpand(d, minimal);
}
...
//执行一步rehash操作
/* This function performs just a step of rehashing, and only if there are
 * no safe iterators bound to our hash table. When we have iterators in the
 * middle of a rehashing we can't mess with the two hash tables otherwise
 * some element can be missed or duplicated.
 *
 * This function is called by common lookup or update operations in the
 * dictionary so that the hash table automatically migrates from H1 to H2
 * while it is actively used. */
static void _dictRehashStep(dict *d) {
    //这里需要保证没有安全迭代器存在
    if (d->iterators == 0) dictRehash(d,1);
}
...
//按需扩张
/* Expand the hash table if needed */
static int _dictExpandIfNeeded(dict *d)
{
    /* Incremental rehashing already in progress. Return. */
    if (dictIsRehashing(d)) return DICT_OK;

    //这里做初始化操作
    /* If the hash table is empty expand it to the initial size. */
    if (d->ht[0].size == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE);

    /* If we reached the 1:1 ratio, and we are allowed to resize the hash
     * table (global setting) or we should avoid it but the ratio between
     * elements/buckets is over the "safe" threshold, we resize doubling
     * the number of buckets. */
    if (d->ht[0].used >= d->ht[0].size &&
        (dict_can_resize ||
        //由于是整数除法，实际上这里要求达到6倍才行。。
         d->ht[0].used/d->ht[0].size > dict_force_resize_ratio))
    {
        //翻一倍大小
        return dictExpand(d, d->ht[0].used*2);
    }
    return DICT_OK;
}
```

## 跳表

Redis中用跳表来实现有序集合，以及在集群节点中用作内部数据结构。其源码出现在`server.h`和`t_zset.c`文件中。

Redis的跳表的特点是需要同时维护一个哈希表和跳表，其中哈希表存储对象到某个分数的映射，同时负责排重工作，而跳表则支持插入删除排名等操作，其元素按照score作为第一关键字，元素作为第二关键字进行排序。

```c
typedef struct zset {
    //需要同时使用哈希表和skiplist，前者用于查询判重等，后者用于排名，排序等
    dict *dict;
    zskiplist *zsl;
} zset;
```

跳表的元素只能是字符串，为了节省内存，因此哈希表和跳表用的是相同的引用，而释放元素由跳表负责（因此每次删除需要先从哈希表中删除，再删除跳表，否则会存在坏键）。

跳表的最大高度为32，每个元素的高度由投硬币决定。

```c
//上升概率为0.25
#define ZSKIPLIST_P 0.25      /* Skiplist P = 1/4 */

/* Returns a random level for the new skiplist node we are going to create.
 * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL
 * (both inclusive), with a powerlaw-alike distribution where higher
 * levels are less likely to be returned. */
int zslRandomLevel(void) {
    //投硬币
    int level = 1;
    while ((random()&0xFFFF) < (ZSKIPLIST_P * 0xFFFF))
        level += 1;
    return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;
}

```

## 整数集合

如果一个集合只包含整数，并且数量不多，Redis就会用整数集合来存储。其源码出现在`intset.h`和`intset.c`文件中。

```c
typedef struct intset {
    //存储的是几位长度的整数
    uint32_t encoding;
    uint32_t length;
    int8_t contents[];
} intset;
```

整数集合中的元素以从小到大的方式排序存放在`contents`这个柔性数组中，不允许重复元素的出现。

如果放入需要更多字节才能表示的整数，需要对整数集合进行升级，要求重新分配空间。升级后的整数集合并不会因为删除元素而降级。引入升级机制的好处是适用最小的类型来存储整数，这样可以节约内存。

```c
/* Upgrades the intset to a larger encoding and inserts the given integer. */
static intset *intsetUpgradeAndAdd(intset *is, int64_t value) {
    uint8_t curenc = intrev32ifbe(is->encoding);
    uint8_t newenc = _intsetValueEncoding(value);
    int length = intrev32ifbe(is->length);
    //如果是因为过小，就加到前面，否则后面
    int prepend = value < 0 ? 1 : 0;

    /* First set new encoding and resize */
    is->encoding = intrev32ifbe(newenc);
    is = intsetResize(is,intrev32ifbe(is->length)+1);

    /* Upgrade back-to-front so we don't overwrite values.
     * Note that the "prepend" variable is used to make sure we have an empty
     * space at either the beginning or the end of the intset. */
    //从后往前处理，避免覆盖问题
    while(length--)
        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));

    /* Set the value at the beginning or the end. */
    //插前面还是后面，这是一个问题
    if (prepend)
        _intsetSet(is,0,value);
    else
        _intsetSet(is,intrev32ifbe(is->length),value);
    is->length = intrev32ifbe(intrev32ifbe(is->length)+1);
    return is;
}
```

当然是用数组来是不可能有有效支持插入删除操作的，这里它们的时间复杂度是$O(n)$。

```c
/* Insert an integer in the intset */
intset *intsetAdd(intset *is, int64_t value, uint8_t *success) {
    uint8_t valenc = _intsetValueEncoding(value);
    uint32_t pos;

    //先默认成功
    if (success) *success = 1;

    /* Upgrade encoding if necessary. If we need to upgrade, we know that
     * this value should be either appended (if > 0) or prepended (if < 0),
     * because it lies outside the range of existing values. */
    if (valenc > intrev32ifbe(is->encoding)) {
        //升级的同时解决插入问题
        /* This always succeeds, so we don't need to curry *success. */
        return intsetUpgradeAndAdd(is,value);
    } else {
        /* Abort if the value is already present in the set.
         * This call will populate "pos" with the right position to insert
         * the value when it cannot be found. */
        //如果存在就返回失败
        if (intsetSearch(is,value,&pos)) {
            if (success) *success = 0;
            return is;
        }

        //???，果真暴力
        is = intsetResize(is,intrev32ifbe(is->length)+1);
        if (pos < intrev32ifbe(is->length)) intsetMoveTail(is,pos,pos+1);
    }

    _intsetSet(is,pos,value);
    is->length = intrev32ifbe(intrev32ifbe(is->length)+1);
    return is;
}
/* Delete integer from intset */
intset *intsetRemove(intset *is, int64_t value, int *success) {
    uint8_t valenc = _intsetValueEncoding(value);
    uint32_t pos;
    if (success) *success = 0;

    if (valenc <= intrev32ifbe(is->encoding) && intsetSearch(is,value,&pos)) {
        uint32_t len = intrev32ifbe(is->length);

        /* We know we can delete */
        if (success) *success = 1;

        //删除也是暴力
        /* Overwrite value with tail and update length */
        if (pos < (len-1)) intsetMoveTail(is,pos+1,pos);
        //每次都需要重新分配内存？？
        is = intsetResize(is,len-1);
        is->length = intrev32ifbe(len-1);
    }
    return is;
}
```

由于是有序存储，因此查找可以通过二分：

```c
/* Search for the position of "value". Return 1 when the value was found and
 * sets "pos" to the position of the value within the intset. Return 0 when
 * the value is not present in the intset and sets "pos" to the position
 * where "value" can be inserted. */
static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) {
    int min = 0, max = intrev32ifbe(is->length)-1, mid = -1;
    int64_t cur = -1;

    //剪枝
    /* The value can never be found when the set is empty */
    if (intrev32ifbe(is->length) == 0) {
        if (pos) *pos = 0;
        return 0;
    } else {
        /* Check for the case where we know we cannot find the value,
         * but do know the insert position. */
        if (value > _intsetGet(is,max)) {
            if (pos) *pos = intrev32ifbe(is->length);
            return 0;
        } else if (value < _intsetGet(is,0)) {
            if (pos) *pos = 0;
            return 0;
        }
    }

    //感人二分
    while(max >= min) {
        mid = ((unsigned int)min + (unsigned int)max) >> 1;
        cur = _intsetGet(is,mid);
        if (value > cur) {
            min = mid+1;
        } else if (value < cur) {
            max = mid-1;
        } else {
            break;
        }
    }


    if (value == cur) {
        if (pos) *pos = mid;
        return 1;
    } else {
        if (pos) *pos = min;
        return 0;
    }
}
```

感觉没什么软用啊。。

# 压缩列表

压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表键，且每个列表项要么是小整数，要么是长度较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。

压缩列表是以双端链表的方式实现的，因此可以从头部和尾部删除或插入。但是由于每次修改操作都需要将整个压缩链表重新分配，因此时间复杂度总是$O(n)$的。

```c
//每次都需要重新分配内存
/* Resize the ziplist. */
unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {
    zl = zrealloc(zl,len);
    ZIPLIST_BYTES(zl) = intrev32ifbe(len);
    zl[len-1] = ZIP_END;
    return zl;
}
```

ziplist的优点是每个结点都可以有自己独立的压缩模式，因此即使列表中有超大整数，也不会影响较小的数占用非常少的空间。且虽然是双端队列，但是由于是存储了前驱和自身的大小来实现查找前驱后继的功能，因此占用的空间非常小。且由于占用的是连续的空间，因此对缓存友好，且不容易出现内存碎片。

ziplist的中保存的元素的数目是用16位整数存储的，因此当达到最大时，就不会再增长了，之后获取大小必须通过遍历列表实现。

```c
/* Return length of ziplist. */
unsigned int ziplistLen(unsigned char *zl) {
    unsigned int len = 0;
    if (intrev16ifbe(ZIPLIST_LENGTH(zl)) < UINT16_MAX) {
        len = intrev16ifbe(ZIPLIST_LENGTH(zl));
    } else {
        //长度达到$2^{16}$，需要执行扫描才能获得真正的长度
        unsigned char *p = zl+ZIPLIST_HEADER_SIZE;
        while (*p != ZIP_END) {
            p += zipRawEntryLength(p);
            len++;
        }

        /* Re-store length if small enough */
        if (len < UINT16_MAX) ZIPLIST_LENGTH(zl) = intrev16ifbe(len);
    }
    return len;
}

/* Increment the number of items field in the ziplist header. Note that this
 * macro should never overflow the unsigned 16 bit integer, since entries are
 * always pushed one at a time. When UINT16_MAX is reached we want the count
 * to stay there to signal that a full scan is needed to get the number of
 * items inside the ziplist. */
#define ZIPLIST_INCR_LENGTH(zl,incr) { \
    if (ZIPLIST_LENGTH(zl) < UINT16_MAX) \
        ZIPLIST_LENGTH(zl) = intrev16ifbe(intrev16ifbe(ZIPLIST_LENGTH(zl))+incr); \
}
```

## quicklist

学习了ziplist后，可以发现ziplist的优点是占用空间小，但是缺点是所有操作的时间复杂度都是$O(n)$，因此ziplist一旦达到百万级别，队列操作所花的时间就非常多了。而实现队列较好的选择就是linklist，插入弹出时间复杂度均为$O(1)$，但是对应的内存使用量不高。

quicklist结合了linklist和ziplist的优点，我们可以将其理解为对列表的分块，每一块都是一个ziplist，不同的块通过linklist的前驱后继指针的方式串联起来。这样我们就可以较快的实现队列操作，且由于底层的块是由ziplist存储的，因此内存使用量也少。而且由于作为队列时，除了两端的块，中间的块不常被访问，因此可以用压缩算法进行压缩，释放更加多的空间。

可以通过`list-max-ziplist-size`来配置块大小，为正数的时候用于配置每一块最多能包含的元素数目（此时每个ziplist中的元素大小都不能超过8K），负数$-x$表示每一块内存使用量少于$2^{x+1}$KB，$1\leq x\leq 5$。

```c
REDIS_STATIC int
_quicklistNodeSizeMeetsOptimizationRequirement(const size_t sz,
                                               const int fill) {
    //fill>=0表示限制项目数
    if (fill >= 0)
        return 0;

    //<0表示限定内存占用
    size_t offset = (-fill) - 1;
    if (offset < (sizeof(optimization_level) / sizeof(*optimization_level))) {
        if (sz <= optimization_level[offset]) {
            //没有达到上限
            return 1;
        } else {
            return 0;
        }
    } else {
        //使用了未定义的范围
        return 0;
    }
}

REDIS_STATIC int _quicklistNodeAllowInsert(const quicklistNode *node,
                                           const int fill, const size_t sz) {
    if (unlikely(!node))
        return 0;

    int ziplist_overhead;
    /* size of previous offset */
    if (sz < 254)
        ziplist_overhead = 1;
    else
        ziplist_overhead = 5;

    /* size of forward offset */
    if (sz < 64)
        ziplist_overhead += 1;
    else if (likely(sz < 16384))
        ziplist_overhead += 2;
    else
        ziplist_overhead += 5;

    /* new_sz overestimates if 'sz' encodes to an integer type */
    unsigned int new_sz = node->sz + sz + ziplist_overhead;
    //判断新的块大小是否满足占用空间约束
    if (likely(_quicklistNodeSizeMeetsOptimizationRequirement(new_sz, fill)))
        return 1;
    //如果不满足占用空间要求，那么每个元素的最大不能超过8096
    else if (!sizeMeetsSafetyLimit(new_sz))
        return 0;
    //如果fill是非负，那么只要求count不超过fill
    else if ((int)node->count < fill)
        return 1;
    else
        return 0;
}
```

对于压缩，可以通过`list-compress-depth`来配置，若值为$x$，则表示除了最前边的$x$个块和最后边的$x$个块外，其余块全部进行压缩。

```c
//尝试进行压缩
/* Force 'quicklist' to meet compression guidelines set by compress depth.
 * The only way to guarantee interior nodes get compressed is to iterate
 * to our "interior" compress depth then compress the next node we find.
 * If compress depth is larger than the entire list, we return immediately. */
REDIS_STATIC void __quicklistCompress(const quicklist *quicklist,
                                      quicklistNode *node) {
    /* If length is less than our compress depth (from both sides),
     * we can't compress anything. */
    //quicklist->compress为0时表示不压缩
    if (!quicklistAllowsCompression(quicklist) ||
    //剪枝
        quicklist->len < (unsigned int)(quicklist->compress * 2))
        return;

    /* Iterate until we reach compress depth for both sides of the list.a
     * Note: because we do length checks at the *top* of this function,
     *       we can skip explicit null checks below. Everything exists. */
    quicklistNode *forward = quicklist->head;
    quicklistNode *reverse = quicklist->tail;
    int depth = 0;
    //指数变量，表示node是否在两端（压缩部分外）
    int in_depth = 0;

    while (depth++ < quicklist->compress) {
        quicklistDecompressNode(forward);
        quicklistDecompressNode(reverse);

        if (forward == node || reverse == node)
            in_depth = 1;

        if (forward == reverse)
            return;

        forward = forward->next;
        reverse = reverse->prev;
    }

    //需要压缩node
    if (!in_depth)
        quicklistCompressNode(node);

    if (depth > 2) {
        //顺带压缩了？
        /* At this point, forward and reverse are one node beyond depth */
        quicklistCompressNode(forward);
        quicklistCompressNode(reverse);
    }
}
```

# 对象

Redis没有用上面提到的数据结构实现键值对数据库，而是基于这些数据结构创建了一个对象系统。这个系统中包含字符串对象、列表对象、哈希对象、集合对象、有序集合对象共五种类型的对象。

Redis的对象使用引用计数的方式实现了垃圾回收，当某个对象不再被使用的时候就会被自动释放。

Redis的对象还带有访问时间，这样服务器就可以将一些过久没有使用的对象进行淘汰。

Redis使用对象来表示键值对，当我们创建一个新的对象的时候，我们会创建一个SDS用来存储对象名，同时创建一个值对象。

Redis的每个对象都由redisObject所表示，下面是`server.h`文件中的定义：

```c
#define LRU_BITS 24

typedef struct redisObject {
    //值类型
    unsigned type:4;
    //使用的什么数据结构
    unsigned encoding:4;
    //LRU时间，低8位存储频率，高16位存储访问时间
    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or
                            * LFU data (least significant 8 bits frequency
                            * and most significant 16 bits access time). */
    //引用计数
    int refcount;
    //指向实际的值
    void *ptr;
} robj;
```

其中type字段表示的是什么类型的对象，可能值可以是字符串类型、列表类型、哈希类型、集合类型、有序集合。而encoding则存储了值对应的数据结构，比如即使是列表类型，其也可能是linklist或quicklist。

encoding中字符串类型可以分为int,raw,embstr。如果字符串中实际上保存的是一个不超过64位的整数，则会以int类型存储，否则会以raw类型（底层用的sds）存储。但是特殊的如果字符串长度不超过32，那么会用embstr类型存储这个字符串emstr的特点就是将redisObject和sds作为一块连续的区间分配管理，于是这样就减少了内存分配和回收的次数，同时也更好的利用了缓存。在redis中使用字符串类型存储浮点数，而浮点数的字符串形式长度一般不超过32，因此一般会用embstr表示。

encoding中列表类型可以分为linklist,ziplist,quicklist，其中前两种在Redis3.2版本之前使用，后来quicklist替代了前两者。

# 参考资料

- 《Redis设计与实现》
- [Redis内部数据结构详解(5)——quicklist](http://zhangtielei.com/posts/blog-redis-quicklist.html)