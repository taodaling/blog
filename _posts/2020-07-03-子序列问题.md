---
categories: algorithm
layout: post
---

- Table
{:toc}

# 判断A是否是B的子串

要判断$A$是否是$B$的子串，我们可以使用贪心算法，记$f(i)$表示A的长度为$i$的前缀，是$B$的长度为$f(i)$的前缀的子串，且$f(i)$尽可能小。

可以发现$f$是个递增函数，此时$f(i)$等于最小的$j$，满足$j>f(i-1)$且$B_j=A_i$。因此我们我们用线性算法解决这个问题，时间复杂度为$O(\|A\|+\|B\|)$。

这里特殊提一下，如果有很多判断子串的请求，要求计算$A_1,A_2,\ldots,A_k$是否是$B$的子串。这时候我们可以预处理$B$，令$next(i,j)$表示最小的下标$t$，满足$t>i$且$B_t=j$。之后每次判断我们可以根据$next$表快速跳转，时间复杂度为$O(C\|B\|+\sum_{i=1}^k\|A_i\|)$，其中$C$是字符集大小。

# 本质不同的子串数目

给定一个长度为$n$的字符串$S$，字符集为$C$。要求计算字符串有多少本质不同的子串（子串是通过从原串删除若干个字符后得到的新的字符串，原字符串和长度为0的空串也认为是子串）。两个子串$A,B$本质不同，当且仅当长度不同或存在某个下标$i$，满足$A_i\neq B_i$。

如果不考虑本质不同，那么总共有$2^n$种子串。下面来考虑有多少本质不同的字符串。

我们回忆另外一个问题，给你两个字符串$A,B$，判断$A$是否是$B$的子串。这个问题我们有$O(\|A\|+\|B\|)$时间复杂度的贪心算法。即对于每个$A$的长度为$i$的前缀$A(i)$，记录最短的$B$的前缀$B(j)$，满足$A(i)$是$B(j)$的子串，这里我们记$P(i)=j$。可以发现$P(i)$是递增函数，因此我们找到$P(i-1)$后，一定有$P(i)>P(i-1)$，我们逐一扫描$B$的第$P(i-1)$个字符后面的字符即可。

可以发现上面提到的算法，对于给定的$A$其流程是固定的，但是对于不同的$A$，其流程两两不同。因此我们可以记$f(i)$表示满足最后一个字符恰好匹配$S_i$的本质不同的序列数目（很显然在这时候没有统计到的序列最后都不会和这些序列冲突），记$N(i,c)$表示$S$中第$i$个位置后字符$c$出现的首个下标，那么$f(i)$可以对$f(N(i,c))$产生贡献，其中$c\in C$。因此时间复杂度为$O(n\|C\|)$，空间复杂度为$O(n\|C\|)$。

提供一道题目：SRM750 PurpleSubsequences。

# 最短的非子串

给定长度为$n$的序列$A$，要求找出所有不是$A$的子串中长度最短的序列，如果有多个，找出其中字典序最小的。其中字符集$C$为所有小写英文字母。

我们知道如何判断一个字符串是否是$A$的子串，我们记$N(i,x)$，表示最小的$j$，满足$j>i$且$A_j=x$，如果不存在，就记$j$为$n+1$。记$B$为我们的答案。可以发现`B[2..]`不是`A[N(0,B_1)+1..]`的子串且是最短的，因此如果我们希望$B$尽可能短，则对应的希望$N(0,B_1)$尽可能大。

我们可以建立一副图，并从顶点$i$到顶点$N(i,c)$建立一条长度为1的有向边，有向边上写着字符$c$。那么问题就变成了计算从顶点$0$到顶点$n+1$的最短路径。在保证路径最短的前提下，我们要找出路径上字符组成的字符串字典序最小的那一条。

由于是无环图，因此可以直接DP解决掉。时间复杂度为$O(Cn)$。

提供一道[题目](https://atcoder.jp/contests/arc081/tasks/arc081_c?lang=en)。