---
categories: share, file
layout: post
---

- Table
{:toc}
# 前言



随着计算机的普及，人们逐渐抛弃了纸质文档的方式，而开始投入数字存储的怀抱。

数字存储的优势：

- 容量大，一枚小小的U盘就可以容纳整个图书馆中的书。
- 数据不容易损坏，而纸质文档容易因为各种原因损坏。
- 利用搜索技术可以更方便地定位文档。

好了，编不下去了，总之，就是优点多多。



但是数字存储的可靠性依赖于硬件，但是硬件的可靠性是无法保证的。硬件本身就会老化，并且还很容易受灾害影响，因此保存在硬件中的数据可以认为是易丢失的。为了避免重要数据的丢失，一般会使用多副本技术。为一份数据创建多个副本，这样任何一份副本的丢失都不会影响数据的完整性。但是多副本的方式操作起来，我们不仅仅需要自行维护硬件，还得关注硬件的状态，以及数据的同步问题，这对于个体用户是昂贵的，但是个体用户却又这样的需求，因此一些云存储也得以流行起来。



讲到了多副本，自然就存在副本之间的同步问题。考虑现在在主机A上，保存了你的一份资料，同时在主机B上，保存了这份资料的副本。现在你操作主机A，修改了原始的数据，之后自然需要将数据同步到主机B上。这时候就引入了全量更新和增量更新。

- 全量更新：全量更新是指将本地数据完整拷贝到远程主机上，并替换原始副本。

- 增量更新：增量更新是指仅将本地数据修改的部分传送到远程主机上，并将修改部分应用到原始副本上。



实现全量更新非常简单，直接通过scp远程拷贝就可以了。全量更新在数据量不大的时候是非常好的解决方案，但是当数据量达到M级之后就会体现出巨大的浪费。考虑你有一个很大的文件，比如原始而未经压缩的视频或图像，并且你需要与小组在这些媒体文件上协同工作，你们之间的数据必须不停的在彼此之间重复发送以确保大家的数据同步。或者你自己维护了一个很大的记录日常活动的Excel文件，每天都对应一个sheet页。或者你有一个巨大的应用，你需要经常将应用部署到远端服务器上以确保自己的更新生效。

每次的全量拷贝会受到网络的严格限制，可能每一次修改后你的一次同步操作就够你喝杯咖啡了。



因此全量更新在很多时候都会造成可怕的浪费，它不仅要受网络的限制还会造成高额的流量费用。增量更新才是王道！



增量更新有非常简单的实现思路。比如：

1. 在对一批文件执行批量更新时，校验每个文件在双方的哈希值，如果相同就跳过。
2. 在对单个文件执行更新时，每次编辑操作都记录操作日志，之后就发送操作日志到远端，并在远端重演所有操作。

其中1是一种通用的优化思路，这是非常有效的。但是它还是无法解决编辑单个大文件的问题。而2是一种被广泛采纳的技术，比如MySQL中主库会向从库拷贝binlog。但是2也有缺点，修改必须发生在受我们控制的环境下，这意味着我们必须能在编辑环境中加入自己记录日志的插件，但是由于IDE如此的多，我们显然无法每个都做到。



# Rsync

>  rsync is a utility for efficiently transferring and synchronizing files across networked computers by comparing the modification times and sizes of files. It is commonly found on Unix-like operating systems. The rsync algorithm is a type of delta encoding, and is used for minimizing network usage. Zlib may be used for additional data compression, and SSH or stunnel can be used for security. [[1]](#ref-1)

rsync是一个工具包，通过比较文件的修改时间和大小，从而高效地跨网络传输和同步文件。它一般能在类Unix操作系统上找到。rsync算法是一类差量编码，并被用于最小化网络消耗。可以利用Zlib进一步提供额外的数据压缩能力，而SSH或stunnel可以用来保证安全。

> Andrew Tridgell and Paul Mackerras wrote the original rsync, which was first announced on 19 June 1996. Tridgell discusses the design, implementation, and performance of rsync in chapters 3 through 5 of his Ph.D. thesis in 1999. It is currently maintained by Wayne Davison.[[1]](#ref-1)
>

最初的rsync于1996年6月19日发布，由安德鲁·垂鸠和保罗·麦克拉斯共同撰写。垂鸠在他1999年的博士论文的第3章到第5章讨论了rsync的设计、实现和性能。如今它由韦恩·戴维森维护。

> Because of the flexibility, speed, and scriptability of rsync, it has become a standard Linux utility, included in all popular Linux distributions. It has been ported to Windows (via Cygwin, Grsync, or SFU), FreeBSD, NetBSD, OpenBSD, and macOS.[[1]](#ref-1)

rsync的灵活性，速度以及适配能力，已经使它成为了标准Linux工具包，包含在所有流行的Linux发行版本中。它也已经迁移到了Windows（通过Cygwin，Grsync或者SFU），FreeBSD，NetBSD，OpenBSD和macOS上。

## rsync原理

rsync原理非常简单。下面的图展示了rsync的整体流程。

![A To B](https://raw.githubusercontent.com/taodaling/assets/master/images/2019-03-12-differ/rsync-process.png)

下面我们了解每个步骤具体做了什么。

第一步，A主机将文件名称和相对路径发送给B主机。

第二步，B主机将文件切分成若干个固定大小的块，除了最后一块外每一块的大小都相同。之后B主机为每一个块计算两个摘要值，一个弱摘要，一个强摘要。弱摘要采用滚动哈希算法，原版中采用的adler-32算法，而强摘要可以选择SHA-1，MD5等，原版中采用的是MD4算法。

比如我们按照1024作为固定大小，那么第0块的范围是[0, 1024)，第1块的范围是\[1024, 2048)，第k块的范围是[1024 \* k, 1024 \* (k + 1))

第三步，B主机将每一个分块的强弱摘要返回给A主机，你可以认为数据类似于：

```json
[
    {
        "blockId": 1,
        "weakChecksum": 9863,
        "strongChecksum": "AC765D7F65310EA5..."
    },
...
]
```

第四步，A主机同样对本地文件分块，并采用与B主机分块一样的大小。但是分块策略并不完全相同。

假设我们按照1024作为固定大小，A主机下第0块的范围是[0, 1024)，第1块的范围是[1, 1025)，第k块范围是[k, 1024 + k)。

之后计算差量的方式非常有趣。由于之前已经从B主机接收到分块的摘要信息，A主机将这些摘要信息维护到哈希表中，弱摘要用于确定slot的下标，强摘要作为关键字，块ID作为值。比如

```json
{
    9863 => "AC765D7F65310EA5...":1,...
    ...
}
```

之后按序遍历A主机下的分块。由于采用的是滚动哈希，因此当我们计算出第i块的弱哈希时，可以以O(1)的时间复杂度内计算出第i+1块的弱哈希值。下面说明整体计算流程：

![calc differ](https://raw.githubusercontent.com/taodaling/assets/master/images/2019-03-12-differ/rsync-calc-differ.png)

第五步中，A主机将第四步输出的操作序列发送到B主机。

第六步中，B主机执行操作序列，add命令代表向新文件尾部追加一个字节，copy命令表示拷贝原文件的一个块内容到新文件尾部。

## 演示

假设我们B中文件内容为`你好啊，铁开诚`，而A中的文件为`你好吗，铁开诚？`，并假设块大小为2。

第4步流程如下：

输入"你好吗"，没有匹配，发送命令"add 你"。

输入"好吗，"，没有匹配，发送命令"add 好"。

输入"吗，铁"，没有匹配，发送命令"add 吗"。

输入"，铁开"，发现匹配，发送命令"copy 3"。

输入"诚？"，由于长度不足，直接发送"add 诚", "add？"。

之后在B端执行这些命令。首先它创建一个临时文件temp，之后在临时文件上执行操作序列。第6步流程如下，

"add 你"，执行完后文件内容为"你"

"add 好"，执行完后文件内容为"你好"

"add 吗"，执行完后文件内容为"你好吗"

"copy 3"，执行完后文件内容为"你好啊，铁开"

"add 诚", "add？"，执行完后文件内容为"你好啊，铁开诚?"

## 分析

采用了rsync算法后，文件大小对于真正每次的传输数据量来说影响不大，其仅于你的修改次数和块大小有关。因此不管文件有多大，增量算法都可以非常好的运行。当然由于使用了rsync，差量的计算和应用将会带来比较多的CPU消耗。

# Myers' Diff

作为rsync的作者，安德鲁·垂鸠还间接造成git的出现。

> 自2002年开始，林纳斯·托瓦兹决定使用BitKeeper作为Linux内核主要的版本控制系统用以维护代码。因为BitKeeper为专有软件，这个决定在社群中长期遭受质疑。在Linux社群中，特别是理查德·斯托曼与自由软件基金会的成员，主张应该使用开放源代码的软件来作为Linux内核的版本控制系统。林纳斯·托瓦兹曾考虑过采用现成软件作为版本控制系统（例如Monotone），但这些软件都存在一些问题，特别是性能不佳。现成的方案，如CVS的架构，受到林纳斯·托瓦兹的批评。
>
> 2005年，安德鲁·垂鸠写了一个简单程序，可以连接BitKeeper的存储库，BitKeeper著作权拥有者拉里·麦沃伊认为安德鲁·垂鸠对BitKeeper内部使用的协议进行逆向工程，决定收回无偿使用BitKeeper的许可。Linux内核开发团队与BitMover公司进行磋商，但无法解决他们之间的歧见。林纳斯·托瓦兹决定自行开发版本控制系统替代BitKeeper，以十天的时间编写出git第一个版本。[[2]](#ref-2)

Rsync适用于远程主机之间的修改和同步，但是它计算的差量是接近于实际的修改内容，但实际上还是会掺杂额外的数据，比如，文件尾部的内容会被无条件拷贝。

Git并没有将Rsync作为自己的增量算法，因为Git需要保证每次提交都仅包含必要的内容，这样才能快速地在多位开发者之间快速分发提交，同时也可以减轻Git仓库的存储负担。

## Git补丁内容

我们先演示git的diff功能。

```sh
$ mkdir temprepo & cd temprepo
$ git init
```

在目录下创建文件：

```tex
t
i
e
z
h
o
n
g
c
h
e
n
g
```

提交后。发现名字写错了，将名字变更为

```tex
t
i
e
k
a
i
c
h
e
n
g
```

之后我们查看提交中包含的具体内容。

```sh
$ git show HEAD
commit 41e666a3bb6bbdd283dc49494a79b972a9dc6e6d (HEAD -> master)
Author: taodaling <daling.tao@ideacome.com>
Date:   Wed Mar 13 15:04:12 2019 +0800

    fix

diff --git a/data b/data
index 4f71c15..d3f46fc 100644
--- a/data
+++ b/data
@@ -1,11 +1,9 @@
 t
 i
 e
-z
-h
-o
-n
-g
+k
+a
+i
 c

```

我们发现git认为两次commit的差别仅在于删除了zhong，并在tie的后面添加kai，而非改变整个文本。

## 提出问题

Git的diff实际上会计算文件之间的最小变动。实际上diff解决的是一个最短编辑脚本（shortest edit script）问题。



最短编辑脚本问题是给出两段字符串A、B（实际上可以是任何序列），在A上执行若干次下面两种操作，问最少需要多少次操作就可以将A转换为B：

- 删除A中一个字符
- 向A中某个位置插入一个字符

比如A=`"abcd"`，B=`"acb"`，那么我们需要执行两次删除和一次插入操作。



最短编辑脚本问题还有一个镜像问题，叫做最长公共子串问题。

最长公共子串问题是指，给出两段字符串A、B，从A中移除一些字符，从B中移除一些字符后得到的最长相同字符串。

比如A=`"abcd"`，B=`"acb"`，A与B的最长公共子串是“ac”和"ab"，长度均为2。



最长公共子串中对B中字符的删除对应于在最短编辑脚本中向A中插入字符。

## 传统动态规划解决方案

最短编辑脚本问题是一个经典的动态规划问题。设A的长度为n，B的长度为m。那么我们构建一个二维数组dp，其行数为n，列数是m。

dp\[i\]\[j\]表示将A[0..i]转换成B[0..j]所需的最少编辑次数。

如果A\[i\]与B\[j\]不同，那么***dp\[i\]\[j\] = min(dp\[i - 1\]\[j\], dp\[i\]\[j - 1\]) + 1***。

如果A[i]与B[j]相同，那么***dp\[i\]\[j\] = dp\[i - 1\]\[j - 1\]***

之后由于dp计算的依赖是有拓扑序的，因此是可以直接计算出所有的dp值，而不会发生循环依赖。

这种方式的优点是简单直接，容易理解，但是缺点是需要的时间和空间复杂度均为O(nm)。

考虑两个文本大小为1M，那么需要的内存会达到1T，这是无法满足的。但是1M的文本并不少见，因此这个方法不能被采用。

## Myers' Diff

Myers' Diff算法由Myers提出，论文可以在[http://www.xmailserver.org/diff2.pdf](http://www.xmailserver.org/diff2.pdf)处获得。

为了理解Myers' Diff算法，我们首先需要回到之前提过的动态规划方案。我们将其作为二维图进行绘制。

![myers](https://raw.githubusercontent.com/taodaling/assets/master/images/2019-03-12-differ/myers.PNG)

如果A\[i\]=B\[j\]，那么就在图中绘制一条从(i-1,j-1)到(i,j)的斜线。

如果我们将图中的对角线的长度设计为0，而任何水平边和垂直边的长度设计为1，那么dp的过程等价于在图中寻找一条从(0, 0)到(n, m)的最短路径。我们将字符串问题转换为了图问题。



Myers' Diff引入了下面定义。

**蛇（snake）：若干首位相连的斜线，其组合称为蛇，蛇上任意节点之间的最短距离为0。**

**对角线（diagonal）：结点(x,y)位于对角线x-y上，显然对角线取值范围为-m~n。**

**D-路径（D-path）：D路径是指长度为D的路径。**

**最远D-路径(Furthest D-path)：最远D路径是指所有终点在相同对角线上的D-路径中终点的x坐标值最大的路径。**



以及由上面定义证明下面命题。

**命题1：D路径的终点仅可能落在{-D,-D+2,..., D-2, D}对角线上**。

**命题2：每一条D-路径的终点，都可以通过某个(D-1)-路径的终点沿着水平边或垂直边移动1距离后，沿着蛇移动到达。**

**命题3：每一条最远D-路径的终点，都可以通过某个最远(D-1)-路径的终点沿着水平边或垂直边移动1距离后，沿着蛇移动到达。**

**命题4：如果(x,y)与(u,v)处于相同对角线上，x>u，D(x,y)表示(0,0)到(x,y)的最短距离，D(u,v)表示(0,0)到(u,v)的最短距离，有D(x,y)>=D(u,v)**



利用这些命题，可以给出时间和空间复杂度均为O(d\*(n+m))的算法，d为(0,0)与(n,m)的最短距离。

```c
lcs(A, B)
{
    n = |A|;
    m = |B|;
    for(d = 0; ; d++)
    {
        for(from = -d, until = d, i = from; i <= to; i += 2)
        {
            if(i > n)
            {
                continue;
            }
            if(i < -m)
            {
                continue;
            }
            x = 0;
            if(i > from && i > - m)
            {
                x = max(x, min(n, furthest[d - 1][i - 1] + 1));
            }
            if(i < to && i < n)
            {
                x = max(x, furthest[d - 1][i + 1]);
            }
            y = x - i;
            while(x < n && y < m && A[x] == B[y])
            {
                x++;
                y++;
            }
            furthest[d][i] = x;
            if(x == n && y == m)
            {
                display(furthest, d, i, A, B);
                return;
            }
        }
    }
}

display(furthest, d, i, A, B)
{
    if(d < 0)
    {
        return;
    }
    x = 0;
    j = 0;
    if(i > -d && min(n, furthest[d - 1][i - 1] + 1) >= x)
    {
        x = min(n, furthest[d - 1][i - 1] + 1);
        j = i - 1;
    }
    if(i < d && furthest[d - 1][i + 1] >= x)
    {
        x = furthest[d - 1][i + 1];
        j = i + 1;
    }
    display(furthest, d - 1, j, A, B);
    output(A[x]...furthest[d][i]-1);
}
```



由于空间的限制一般会高于时间，因此O(d*(n+m))的空间复杂度依旧是夸张的。比如1M的文本，做了10000次修改，需要的内存就达到了10G。



幸好，论文中提供了上面贪心算法的一个变种，这个变种拥有相同的时间复杂度，但是空间复杂度为O(n + m)。



更多的命题：

**命题5：存在从(0,0)到(n,m)的长度为D的路径，当且仅当存在从(0,0)出发的长度为ceil(D/2)的路径，终点为(x,y)，以及存在从(n,m)出发的长度为floor(D/2)的路径，终点为(u,v)。(x,y)与(u,v)满足：**

- **u+v>=ceil(D/2)且x+y<=N+M-floor(D/2)**

- **x-y=u-v且x>=u**



我们需要找到这样的(x,y)和(u,v)，之后分而治之。从命题中导出的算法。

```c
lcs(A, B){
    n = |A|;
    m = |B|;
    if(n == 0 || m == 0)
    {
        return;
    }
    fill furthest00 with -1;
    fill furthestnm with n + 1;
    for(d = 0; ; d++)
    {
        for(from = -d, to = d, i = from; i <= to; i += 2)
        {
            if(i > n)
            {
                continue;
            }
            if(i < -m)
            {
                continue;
            }
            x = 0;
            if(i > from && i > - m)
            {
                x = max(x, min(n, furthest00[i - 1] + 1));
            }
            if(i < to && i < n)
            {
                x = max(x, furthest00[i + 1]);
            }
            y = x - i;
            while(x < n && y < m && A[x] == B[y])
            {
                x++;
                y++;
            }
            furthest00[i] = x;
            if(furthest00[i] >= furthestnm[i])
            {
                lcs0(A, B, i, furthestnm[i], furthest00[i], d * 2 - 1);
                return;
            }
        }
        for(from = n - m - d, to = n - m + d, i = from; i <= to; i += 2)
        {
            if(i > n)
            {
                continue;
            }
            if(i < -m)
            {
                continue;
            }
            x = n;
            if(i > from && i > - m)
            {
                x = min(x, furthestnm[i - 1]);
            }
            if(i < to && i < n)
            {
                x = min(x, furthestnm[i + 1] - 1);
            }
            y = x - i;
            while(x > 0 && y > 0 && A[x - 1] == B[y - 1])
            {
                x--;
                y--;
            }
            furthestnm[i] = x;
            if(furthest00[i] >= furthestnm[i])
            {
                lcs0(A, B, i, furthestnm[i], furthest00[i], d * 2);
                return;
            }
        }
    }
}

lcs0(A, B, i, u, x, d)
{
    n = |A|;
    m = |B|;
    y = x - i;
    v = u - i;
    if(d > 1)
    {
        lcs(A[0...u-1], B[0...v-1]);
    	output(A[u...x-1]);
    	lcs(A[x...n - 1], B[y...m - 1]);
    }
    else if(n < m)
    {
        output(A);
    }
    else
    {
        output(B);
    }
}
```





****

# 参考文献

<a name="ref-1"></a> \[1\] [https://en.wikipedia.org/wiki/Rsync](https://en.wikipedia.org/wiki/Rsync)

<a name="ref-2"></a> [2] [https://zh.wikipedia.org/wiki/Git](https://zh.wikipedia.org/wiki/Git)

<a name="ref-3"></a> [3] [https://www.andrew.cmu.edu/course/15-749/READINGS/required/cas/tridgell96.pdf](https://www.andrew.cmu.edu/course/15-749/READINGS/required/cas/tridgell96.pdf)

[4] [https://blog.jcoglan.com/2017/02/12/the-myers-diff-algorithm-part-1/](https://blog.jcoglan.com/2017/02/12/the-myers-diff-algorithm-part-1/)

[5] [http://www.xmailserver.org/diff2.pdf](http://www.xmailserver.org/diff2.pdf)

