---
layout: post
categories: algorithm
---

# 问题：
```
有M个鹰蛋，鹰蛋有一个固定的硬度E，E的含义是从E层楼抛下恰好摔裂，而从E-1层楼则毫发无损。现在假设我们已知E的一个可能上界N。我们可以尝试在任意
层楼丢下鹰蛋（前提是手头还有完好的鹰蛋），这称为一次实验。

问在最坏情况下我们最少需要多少次实验才能确认E。
```

这个问题很容易被理解错误，现在举一个例子。比如N=100，M=2。很多人会选择第一次在50层楼丢，在最坏情况下该蛋必定摔裂，之后则只能从1,2,...,49逐一丢剩下
的一枚蛋。这样最坏情况下需要丢49次，加上前面第一次丢掷，共50次实验。但是如果我们第一颗蛋分别在10，20，30，...，90楼丢，这样确定了大小为9的范围后，
只需要再继续丢我们第二颗蛋，只需要18次实验即可，比如第90楼裂了，那么E仅可能为81，...，89，90，之后丢9次即可。

# 解法：

首先定义f(i,j)表示i个蛋确定至多为j的E值在最坏情况下需要最少实验次数。那么由于我们可以分别选择在第1,2,...,j-1楼丢蛋，而在第k楼丢蛋，有两种可能，
- 蛋破了，确定E<=k，此时后续还需要实验f(i-1,k)次
- 蛋没破，确地E>k，此时后续还需要实验f(i,j-k)次

考虑到始终发生的都是最坏情况，因此在k楼丢蛋的后续实验数为max(f(i-1,k),f(i,j-k))。而我们可以选择具体在哪一楼丢蛋，故
`
f(i,j)=min(
  max(f(i-1,1), f(i, j-1)),
  max(f(i-1,2), f(i, j-2)),
  ...
  max(f(i-1,j-1), f(i, 1)),
)
`

因此我们得到了一个递推式，通过动态规划技术，我们需要O(NM)的空间复杂度和O(MN^2)的时间复杂度。考虑到如果i>=log2(j)，那么利用二分法可以直接得到最优解，
此时f(i,j)=ceil(log2(j))。因此在M>=log2(N)的情况下，时间复杂度降低为O(log2(N))，而在其他情况下，时间复杂度则至多为O(N^2*log2(N))。

但是如果我们更换一下视角，我们可以得到优秀的多的时间复杂度。我们定义h(i,j)表示最多丢i次，共有j个蛋，在最坏情况下能够确定E的最大N值。
（即E仅可能为1,2,...,N，我们始终能通过i次丢j蛋的实验确定E）。

考虑到当j=1时，我们必须逐层实验才能确定E，故：`h(i,1)=i+1`。
同理当i=1时，仅发生一次实验，那么对于任意j>=1均有`h(1,j)=2`。

当j>1时，我们可以做如下决策：在层k丢掷一个蛋，根据蛋是否碎做下面不同决定
1. 如果蛋碎了，则我们还有i-1次操作和j-1个蛋，考虑到E<=k，而我们必定能确定E，故k<=h(i-1,j-1)。
2. 如果蛋没碎，则我们还有i-1次操作和j个蛋，考虑到E>=k+1，我们仅能保证如果E<=k+h(i-1,j)时能确定E。

由于k有上界，而h(i,j)=k+h(i-1,j)，因此我们取k为其上界，得到最大的可能值，h(i,j)=h(i-1,j-1)+h(i-1,j)。

我们要求的结果是找到这样一个x，使得h(x,M)<N但h(x+1,M)>=N。

我们就得到了h的递推式，观察发现h的递推式很类似组合的递推式C(n,m)=C(n-1,m-1)+C(n-1,m)，可以容易的证明h(i,j)>C(n,m)。由于前面已知M<=log2(N)。
如果M=1，则i=N-1，这个可以直接得出。下面仅考虑M>=2的情况，当x>=2M时，由于N>h(x,M)>C(x,M)>=(x/M)^M，故xM<=M^2\*N^(1/M)。

因此我们推得的最终时间复杂度为O(xM)=O((log2(N))^2\*N^(1/M))，空间复杂度为O(log2(N))。其甚至优于线性复杂度。

```java
int determine(int N, int M)
{
  int log2N = 0;
  while((1 << log2N) < N)
  {
    log2N++;
  }
  
  if(M >= log2N)
  {
    return log2N;
  }
  
  int[] dp = new int[M + 1];
  int i = 1;
  for(int j = 1; j <= M; j++)
  {
    dp[j] = 2;
  }
  
  while(dp[M] < N)
  {
    i++;
    for(int j = M; j > 1; j--)
    {
      dp[j] = dp[j - 1] + dp[j];
    }
    dp[1] = i + 1;
  }
  
  return i;
}
```
