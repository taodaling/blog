---
categories: algorithm
layout: post
---

- Table
{:toc}

# 基础概念

一个图G=(V,E)，如果V可以分为两个不相交集合L、R，使得$L\cup R=V$且$L\cap R=\empty$。且集合L中任意两个顶点之间没有边存在，集合R中任意两个顶点之间没有边存在，那么称图G为二分图。

对于E的一个子集，若子集中的任意两条边都没有公共顶点，那么称该子集为图G的一个匹配。如果不存在比某个匹配更大的匹配，则称该匹配为G的最大匹配。

对于V的一个子集，若对于任意E中的一条边，其至少一个顶点属于该子集，那么称该子集为图G的一个顶点覆盖。所有顶点覆盖中最小的顶点覆盖，称为图G的最小顶点覆盖。

对于E的一个子集，若对于任意V中的一个顶点v，一定能在子集中找到一个边e，使得v是e的某个端点，那么称该子集是图G的一个边覆盖。所有边覆盖中最小的称为最小边覆盖。

# 最大流算法求最大匹配

我们向图中加入两个顶点s，t，分别作为源点和终点，从s到所有L中顶点建立一条容量为1的边，从R中所有顶点到t建立一条容量为1的边。之后在图上跑最大流算法就可以得到最大覆盖了，一个边如果流量为1，则边为最大匹配的一部分。

很显然这样得到的一组边集是一个匹配，而对于任意一个匹配，匹配中的每一条边都能为最大流算法提供1的流量。因此最大流算法得出的最大流与最大覆盖的大小等同，而我们得到的边集的大小等同于最大流的大小，因此该覆盖是最大匹配。

最简单的最大流算法就是沿着最短路不断增广的Edmonds-Karp算法，其时间复杂度为$O(E(V+E))$。或者可以选择更进一步优化的ISAP算法，时间复杂度类似，但是实际效果会好很多。

# Kuhn-Munkres算法

Knhn-Munkres也是一个求最大匹配的算法，时间复杂度与EK算法类似，同样是$O(E(V+E))$，但是由于是二分图专用的，因此实际效果非常好，个人实测有将近10倍的差距。

算法的思路与EK算法类似，也是沿着残存网络中的边进行增广。

```java
/**
* 要求node释放自己的同伴，成功返回true，失败false
*/
boolean release(Node node){
    if(node.visited)
    {
        return false;
    }
    node.visited = true;
    if(node.partner != null && bind(node.partner))
    {
        node.partner = null;
    }
    return node.partner == null;
}
/**
* 要求node重新寻找一个新的同伴，成功返回true，失败false
*/
boolean bind(Node node)
{
    if(node.visited)
    {
        return false;
    }
    node.visited = true;
    for(Node nearby : node.edges)
    {
        if(!release(nearby))
        {
            continue;
        }
        node.partner = nearby;
        return true;
    }
    return false;
}
```

# Konig定理

Konig定理：二分图中的最大匹配数等于这个图的最小顶点覆盖数。

证明：

假设我们找到了最大匹配Y。

我们称Y中所有边的两个端点为被Y所匹配。我们遍历所有R中没有被Y匹配的顶点，寻找所有长度为偶数的路径，路径中匹配边和未匹配边交替出现。事实上不存在长度为奇数的路径，不然我们就找到了一个增广路径。我们将L中被标记过的顶点和R中未被标记的顶点合成一个新的点集合X，我们接下来证明X是最小顶点覆盖。

首先先说明X是顶点覆盖，即所有边至少有一个端点属于X。假设存在一条边e，e的两个端点$l\in L$,$r\in R$均不属于X，这意味着l未被标记而r被标记过了。但是这是不可能的，因为r被标记意味着存在这样一个顶点序列$r_0,l_0,r_1,l_1,\ldots,r$，其中路径$(r_i,l_i) \notin Y$且$(l_i,r_{i+1}) \in Y$。我们可以在路径尾部追加$l$得到更长的一条奇数路径，l必定被Y匹配，因此存在另外一条边$(l,t)\in Y$，即路径$r_0,l_0,r_1,l_1,\ldots,r,l,t$是一条合法路径，其上所有顶点都会被标记，因此不存在这样的边，X是顶点覆盖。

之后说明X最小。显然每个Y中的边至少需要一个顶点覆盖，因此最小顶点覆盖数至少为\|Y\|。我们接下来证明$\|X\|=\|Y\|$。

很显然，X中的顶点必定都被Y所匹配（回忆下X是由哪些顶点组成的）。而如果一条$Y$中的边e，两个端点$l\in L$,$r\in R$都属于X，这意味着l被标记而r未被标记，这是不可能的，因为我们同样可以构建一个合法的标记路径。因此我们知道$Y$中的每一条边只有一个顶点属于$X$，到此，我们证明了$\|X\|=\|Y\|$。

# 最小边覆盖

最小边覆盖数等于$\|V\|-\|Y\|$，其中，其中Y$是最大匹配。

证明：

假设X是最小边覆盖，我们可以保证，X中每条边都至少独立覆盖了一个顶点（不然我们可以将这条边删除得到更小的一个边覆盖）。我们不断从X中删除仅独立覆盖一条顶点的边，假设共删除了k个顶点。留下的$\|X\|-k$条边都独立覆盖了两个顶点，可以发现此时条边都独立覆盖了两个顶点，可以发现此时条边都独立覆盖了两个顶点，可以发现此时条边都独立覆盖了两个顶点，可以发现此时X同样也是G的一个匹配。由此得出下面不等式：


$$
2X=V+k\geq V+X-Y\Rightarrow X\geq V-Y
$$



因此我们可以得出最小边覆盖的大小至少为$\|V\|-\|Y\|$。下面我们讲述如何得到最小边覆盖。

记边集X初始为Y。由于X覆盖了2X个顶点，记这些顶点集合为U，我们为每个不属于U的顶点，找到一个以其为端点的边并加入到Y中。完成上述操作后，X的大小正好为$\|V\|-\|Y\|$。此时。此时。此时。此时X为图G的一个边覆盖。

# 参考文献

\[1\] [匹配 wiki介绍](https://zh.wikipedia.org/wiki/%E5%8C%B9%E9%85%8D_(%E5%9B%BE%E8%AE%BA))
\[2\] [Konig定理百度百科](https://baike.baidu.com/item/Konig%E5%AE%9A%E7%90%86)
\[3\] 算法导论
\[4\] [二分图最大匹配的König定理及其证明](http://www.matrix67.com/blog/archives/116)