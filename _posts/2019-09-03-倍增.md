---
categories: algorithm
layout: post
---

- Table
{:toc}
# 快速幂乘法

考虑要计算$x^n$，其中n是一个非负整数。记$pow(x,n)=x^n$，接下来考虑两种情况：

- 当n为偶数时，$pow(x,n)=pow(x,\frac{n}{2})^2$。
- 当n为奇数时，$pow(x,n)=pow(x,\frac{n-1}{2})^2\cdot x$。

因此我们可以以$O(\log_2n)$次乘法运算计算出$x^n$。

快速幂乘法只需要乘法运算满足结合性，即$(a\cdot b)\cdot c=a\cdot (b\cdot c)$。因此x可以是数值，可以是复数，也可以是多项式，矩阵等等。

# BZOJ4870

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=4870](https://www.lydsy.com/JudgeOnline/problem.php?id=4870)

**题解**

记从k个元素中取任意数目的元素为一次操作。记向量f(i)，其第j个元素表示经过i次操作后总共取得的元素的数目模k是j的取法数目。可以推出$f(i+j)=f(i)\times f(j)$，这里的乘法指的是卷积。由于卷积运算符合结合律，因此我们可以用类似快速幂的方式计算$f(n)$。

共发生$O(\log_2n)$次卷积，每次的时间复杂度为$O(k^2)$。因此总的时间复杂度为$O(k^2\log_2n)$。



# BZOJ4773

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=4773](https://www.lydsy.com/JudgeOnline/problem.php?id=4773)

**题解**

首先为了保证单调性（即存在长度为L的负环就一定存在长度为L+1的负环），我们为每个顶点建立一条长度为0的子环。

记f(i)为矩阵，矩阵中第x行第y列元素表示的是从x出发到y的长度为$2^i$的路径最小总权值。

之后我们处理10个比特位，二分判断每个比特位是否允许为0。从而得到最小的负环长。



# LUOGU1613

**题意**

[https://www.luogu.org/problem/P1613](https://www.luogu.org/problem/P1613)

**题解**

分别找出距离为$2^k$的顶点，并在其之间加上一条长度为1的边，结果就是最终图上的最短距离。

# LUOGU4308

**题意**

[https://www.luogu.org/problem/P4308](https://www.luogu.org/problem/P4308)

**题解**

一开始以为是在图上跑DP，但是算了一下精度，至少需要跑一千万轮BFS才能保证精度，这肯定要超时。

题目很好地使用了倍增思想。简单计算可以知道在$10^9$后继续移动带来的收益已经不足以影响后面的精度。我们记$f(i,x,y)$表示从x点到y点，共经过$2^i$次移动可以得到的收益。那么可以推出下面公式：
$$
f(i,x,y)=\max_z f(i-1,x,z)+p^{2^{i-2}}f(i-1,x,z)
$$
我们i枚举到30就够了。