---
categories: algorithm
layout: post
---

- Table
{:toc}


# LUOGU2371

**题意**

[https://www.luogu.org/problem/P2371](https://www.luogu.org/problem/P2371)

**题解**

神奇的题目，很显然DP是不可能的，暴力也是不可能的。

真正的解法，是从$\{a_i\}$选取任意一个数，记作k。之后我们建立k个顶点，分别代表模k时余数为$0,1,\ldots,k-1$。

之后对于顶点$i$和数$a_j$，我们建立边$(i,(i+a_j)\mod k)$。之后我们寻找以顶点0为起点的单源最短路径。

对于数x，记$r=x\mod k$，如果顶点r距离顶点0的最短距离为d，那么根据d与x的大小关系，我们可以快速判断出是否能找到一组非负整数解$\{x_i\}$，使的$\sum_ia_ix_i=x$。如果$d<x$，不存在解，如果$d\geq x$，那么就有解。


# LUOGU4292

**题意**

[https://www.luogu.org/problem/P4292](https://www.luogu.org/problem/P4292)

**题解**

先用分数规划将问题转换为二分+长链剖分。

由于允许的路径边数是范围，所以需要用线段树维护。时间复杂度为$O(n(\log_2n)^2)$。


# LUOGU4220

**题意**

[https://www.luogu.org/problem/P4220](https://www.luogu.org/problem/P4220)

**题解**

我们先理解题目要我们求的到底是个啥，定义$dist(i,j)=dist_1(i,j)+dist_2(i,j)+dist_3(i,j)$，其中$dist_k(i,j)$表示在第k树中i、j的距离。可以进行简化：


$$
\max\quad dist(i,j)=\sum_{k=1}^3dist_k(i,j)=\sum_{k=1}^3depth_k(i)+depth_k(j)-2\cdot depth_k(L_k(i,j))
$$


这里$depth_k(i)$表示的是i在第k颗树中的深度，$L_k(i,j)$表示i、j在第k个树中的LCA。我们记$depth(i)=depth_1(i)+depth_2(i)+depth_3(i)$，之后公式为：


$$
\max\quad dist(i,j)=depth(i)+depth(j)-2depth_1(L_1(i,j))-2depth_2(L_2(i,j))-2depth_3(L_3(i,j))
$$


利用边分治处理第一颗树，删除边重心后，得到两个连通块，包含根的记作A，不含根的记作B。将A中顶点全部染成白色，B中染成黑色，记边的。记录$w_A(i)=depth(i)-2depth_1(L_1(i,B))$，$w_B(i)=depth(i)$。之后为这些点按照第二颗树的结构建立虚树。现在我们要求的是：


$$
\max \quad dist(i,j)=w_A(i)+w_B(j)-2depth_2(L_2(i,j))-2depth_3(L_3(i,j))
$$


在虚数上处理第t个顶点时，由于LCA一定是t，因此可以认为$2depth_2(L_2(i,j))$是常数。此时我们要计算的是


$$
\max \quad dist'(i,j)=w_A(i)+w_B(j)-2depth_3(L_3(i,j))
$$


这里需要用到一个在树上所有边非负的时候成立的命题。

**命题1：如果树上边权非负，对于两个顶点集合A、B，设A中最远点对为$a_1,a_2$，而B中最远点对为$b_1,b_2$，那么在A、B合并后，其中最远点对一定可以从$\{a_1,a_2,b_1,b_2\}$中得到。**

我们可以继续扩展这个命题得到：

**命题2：如果树上边权非负，并定义树上距离为路径距离加上两点的点权，对于两个顶点集合A、B，设A中最远点对为$a_1,a_2$，而B中最远点对为$b_1,b_2$，那么在A、B合并后，其中最远点对一定可以从$\{a_1,a_2,b_1,b_2\}$中得到。**

转换公式令其得到符合命题2：


$$
\max \quad dist'(i,j)=(w_A(i)-depth_3(i))+(w_B(j)-depth_3(j))+dist_3(i,j)
$$

因此在递归处理虚树的同时维护子树dist'最大的白点对、黑点对，在向上贡献的时候合并到父结点的信息中。

# LUOGU4565

**题意**

[https://www.luogu.org/problem/P4565](https://www.luogu.org/problem/P4565)

**题解**

首先用边分治将树1分为两块，包含根的记作R，不含根的记作B。给R中顶点上黑色，B中顶点上白色，之后根据树2建立虚树。

记一个顶点x在树中到树根的路径的总边权记作prefix(x)，记B中深度最浅的顶点为y。

那么黑色顶点a的点权为：weight(a)=prefix(a)-prefix(lca(a, y))

白色顶点b的点权为：weight(b)=prefix(b)

建立好虚树后，我们要找到虚树上距离最远的一对黑白点，其中虚树中a,b距离的定义为：$weight(a)+weight(b)-weight(lca(a,b))$。这个问题dfs就能解决了。

总的时间复杂度为$O(n(\log_2n)^2)$。

# LUOGU4152

**题意**

[https://www.luogu.org/problem/P4151](https://www.luogu.org/problem/P4151)

**题解**

好题。

首先我们考虑两条不同的从1到n的路径。将两条路径进行亦或操作（公共路径去除，非公共路径保留），我们一定得到若干个环。这也预示着任何从1到n的路径，都可以通过任选一条从1到n的路径后，并亦或上一些环得到。

因此，我们可以找到所有的环，并用线性基处理。之后我们取得任意一条从1到n的路径之后，计算线性基能提供的最大亦或和即可。

要寻找所有的环，我们实际上只需要找到简单环即可，即没有重复边的环，其它环都可以通过这些环的亦或操作得到。我们可以通过LCT维护生成树，之后一旦新加的边构成了环，就不加入该边同时将环的亦或和加入到线性基中。

# LUOGU4137

**题目**

[https://www.luogu.org/problemnew/show/P4137](https://www.luogu.org/problemnew/show/P4137)

**题解**

有两种做法。

第一种莫队，但是使用块状链表维护每个出现的数，这样每次查询mex只需要$O(\sqrt{n})$的时间复杂度。总的时间复杂度为$O(n\sqrt{n})$

第二种线段树。首先将数据离散化，之后按照请求的右边界从小到大排序请求。之后从左往右遍历数组，遍历到第i个元素的时候，将$a_i$在线段树中的值更新为i。这样我们要查询mex，只需要查询第一个值小于查询左边界的数。这种方法的时间复杂度为$O(n\log_2n)$

# LUOGU3431

**题目**

[https://www.luogu.org/problemnew/show/P3431](https://www.luogu.org/problemnew/show/P3431)

**题解**

首先可以知道抵达点$(i,j)$之前，上一次接客一定发生在点$(x,y)$，其中$(x,y)$落在由$(0,0)$和$(i,j)$确定的矩形中。

现在要计算k个点的最优值，我们可以认为是k次查询。只是查询之间有拓扑关系。我们可以将离线处理查询，将查询按照y值排序，之后用线段树维护x轴。每处理一次请求(a,b)，只需要查询线段树中处于区间[0,a]之间的最大值，之后将查询结果一同更新到线段树中去。

# LUOGU3332

**题目**

[https://www.luogu.org/problemnew/show/P3332](https://www.luogu.org/problemnew/show/P3332)

**题解**

一开始看错题目了，以为是为区间中每个数增大c，始终想不出解法。后来发现原来是往区间每个下标放入一个数c。

怎么解决呢。我们发现每个数都有两个属性，所在的下标，以及它的值，记作(i,v)。由于是二维向量，我们将其绘制在二维坐标系中。每次查询操作都对应查询某个矩形中第k高的点，我们可以借助二分来猜测该点的高度。

到此容易想到用二维线段树来维护。由于预先开点需要消耗过多内存，因此可以改成动态开点。但是修改操作呢，该如何实现。我们可以调整线段树的含义，外部的线段树表示的是权值线段树，内部的线段树表示的是区间线段树，这样修改操作对于外部来说仅更新了一个点，是不需要打标记的，而内部线段树一次性更新了一段区间，是需要打标记的。

之后由于我们查询操作是之前是通过二分来做的，但是在我们将外部线段树改成权值线段树后，可以发现外部线段树的每次查询也带有二分操作，因此我们就不需要二分了，直接在外部线段树上进行二分。

总的时间复杂度为$O(m(\log_2n)^2)$，空间复杂度和时间复杂度一致。


# LUOGU2839

**题意**

[https://www.luogu.org/problem/P2839](https://www.luogu.org/problem/P2839)

**题解**

题目的数据范围使用int就足够了，题目中序列的意思是连续的一段区间。

要给数x是区间[l,r]的中位数，当且仅当在区间[l,r]中大于等于x的数占了至少半成。

对于每个询问a,b,c,d，我们可以二分中位数x。当x确认时，我们希望判断中位数是否大于等于x，可以通过下面流程得到：我们将数组中所有大于等于x的数替换为1，其它数我们替换为0，这样如果我们找到了一个区间[l,r]，其中l落在[a,b]中，r落在[c,d]中，区间中数字的和大于等于0，那么我们可以断定中位数至少为x。

现在我们考虑如何快速判断这样的子区间[l,r]是否存在，由于[b+1,c-1]是无论如何都需要统计的，而[a,b]中只需要统计一个非空后缀，[c,d]则只需要统计一个非空前缀。容易想到这是个动态规划问题，但是由于询问无法预先处理，因此我们需要做的实际是要利用线段树上合并动态规划实现动态询问。

我们可以为每个值域中的数建立一个线段树，这里我们需要建立的是持久化线段树，否则空间会不足。每个数组中的元素，随着x的增大，会从1变为0，因此每个元素对应两次插入操作，建树的时空复杂度为$O(n\log_2n)$。

回答询问q次，由于使用二分，因此发生了$q\log_2m$次的询问（m是值域的大小），每次询问由线段树处理，总的实际复杂度为$O(q\log_2m\log_2n)$。

# LUOGU4463

**题意**

[https://www.luogu.org/problem/P4463](https://www.luogu.org/problem/P4463)

**题解**

很容易想到DP，定义$f(i,j)$表示从[1,i]中选择j个不同数的所有序列的累乘的和。从而推出：


$$
f(i,j)=f(i-1,j)+i\cdot f(i-1,j-1)
$$


但是由于a的范围过大，使得DP不可行。

神奇的是$f(i,j)=p(j)(i)$，其中p(j)是仅关联于j的多项式。当$j=0$时，$p(j)=1$。注意到对于一个n阶多项式g，能够保证$g(x)-g(x-1)$一定是$n-1$阶多项式。


$$
f(i,j)-f(i-1,j)=i\cdot f(i-1,j-1)\\
\Rightarrow p(j)(i)-p(j)(i-1)=i\cdot p(j-1)(i-1)\\
\Rightarrow |p(j)|-1=|p(j-1)|+1\\
\Rightarrow |p(j)| = 2j
$$

由于$p(n)$的阶数是$2n$，因此我们利用$2n+1$个点就可以确认$p(n)$。随便算出$2n+1$个点，用拉格朗日公式插值出最终结果就行了。时间复杂度为$O(n^2)$。

# Codeforces1209E2

**题意**

[https://codeforces.com/contest/1209/problem/E2](https://codeforces.com/contest/1209/problem/E2)

**题解**

一开始以为是贪心或匹配问题，算算时间复杂度怎么都超。但是最后看题解发现是DP。

很显然m列我们最多只需要n列，这n列的最大值一定是最大的。因此提前排序后筛选，就只剩下n行n列。

我们用二进制表示某一行是否已经被选定，1为被选定，0为未选择。定义函数$g(i,s)$，表示第i列的选定状态为s，问最大总和是多少。首先每一列最多有n种形态（旋转的周期为n），之后对每种形态枚举即可。这里的时间复杂度为$O(n^32^n)$，可以稍加优化（在计算子集的同时计算总和），可以优化到$O(n^22^n)$。

之后记函数$f(i,s)$，表示只考虑前i列，选定状态为s的最大和。只需要简单枚举第i列的选定状态，就可以得出前i-1列的选定状态，这是一个子集问题，时间复杂度为$O(n3^n)$。

最后总的时间复杂度为$O(40(nm+m\log_2m+n3^n+n^22^n))$，计算量大概几亿，是可以过的。


# LUOGU1728

**题意**

[https://www.luogu.org/problem/P1728](https://www.luogu.org/problem/P1728)

**题解**

假如这个问题没有限制可以选择的技能数，那么实际上问题就可以转换成最大权闭合子图问题。但是很可惜并不是。

```
4 5
1 1 1 1
1 2 1
1 1
1
```

注意到每个数可以选择仅要求其上方和右上方的两个数被选择过即可。

假如我们从右往左处理（即先处理第n列，最后处理第1列），那么就非常简单了。

记$f(i,j,k)$表示第$i$列所有行号小于等于$j$行的数字都被选中，并且总共选择了$k$个数的最大选择值总和。

这样得出的递推关系为：
$$
f(i,j,k)=\max(f(i+1,j-1,k-j)+\sum_{t=1}^jgrid[t][i],f(i,j+1,k))
$$


最终结果为$f(1,0,m)$。

# LUOGU1285

**题意**

[https://www.luogu.org/problem/P1285](https://www.luogu.org/problem/P1285)

**题解**

看上去问题是要将图划分为两个团，使得团的差距尽可能小。看上去是个2-SAT问题，但是由于需要求尽可能平均，2-SAT是做不到的。

容易发现，找团是不容易的，但是如果a不认识b，那么我们会得到一个重要的性质，a、b必定处于不同的组。因此我们在不彼此认识的人之间加上一条边。

对于一个连通分量，其黑白染色要么不存在，要么只有两种可能性。对每个图上的连通分量染色后，计算每个连通分量的黑色顶点数和白色顶点数。

之后我们需要才从每个连通分量，要么选择全部黑色顶点加入组1，要么选择全部白色顶点加入组2。这实际上就是一个普通的DP问题了。

记
$$
DP(i,j)
$$
表示考虑前i个连通分量，是否可能正好选择j个人加入到组1中。之后就是DP了。

总的时间复杂度为$O(n^2)$。
