---
categories: problems
layout: post
---

- Table
{:toc}
# CF1175D

**题意**
[https://codeforces.com/contest/1175/problem/D](https://codeforces.com/contest/1175/problem/D)

**题解**

记S(i)=a(i)+a(i+1)+...+a(n)。分别记最优解的划分下，第i个分块的第一个元素下标为f(i)。那么问题下面式子在最优解下一定取最大值。


$$
1\cdot (S(f(1))-S(f(2)))+2\cdot (S(f(2)) - S(f(3)))\\+\ldots + (n-1)(S(f(n-1))-S(f(n)))+nS(f(n))\\
=\sum_{i=1}^nS(f(i))
$$


由于f(1)一定是取到1，我们可以将S(2),S(3),...,S(n)排序后取前面最大的k-1个的和加上S(1)就是结果。

# CF1175F

**题意**
[https://codeforces.com/contest/1175/problem/F](https://codeforces.com/contest/1175/problem/F)

**题解**

我们可以逐个统计每个有效子排列。寻找所有1出现的位置，很显然一个有效排列必定包含且只保护其中之一的1。

我们维护一个函数R，R(i)表示形如a(i),a(i+1),...的无重复元素的最长序列的长度。

之后我们遍历每个1出现的位置i。之后包含i的序列的右边界只可能为j=i,i+1,..., i+R(i)-1。之后假设序列中最大的元素落在i的右边，因此我们只需要知道m=max(a(i),a(i+1),...,a(j))，而序列有效的必要条件是长度等于m，因此我们可以推出左边界k=j-m+1。之后只需要快速判断子序列a(k),...,a(j)是否是一个有效序列就可以了。判断的方法很简单，首先要求R(k)>=max，其次min(a(k),...,a(j))=1且max(a(k),...,a(j))=m。

对于最大元落在左边的情况，只要翻转序列后重新用上面过程处理一次就可以了。

利用线段树就可以在O(nlogn)的时间复杂度内解决。

# BZOJ1345

**题意**
[https://www.lydsy.com/JudgeOnline/problem.php?id=1345](https://www.lydsy.com/JudgeOnline/problem.php?id=1345)

**题解**

很显然最后留下的是序列中的最大值。选择最大值，处于最大值左侧区间中的最大值最后只能与全局最大值合并，对于右侧同理。这提示了我们可以以全局最大值为根建立一棵树，根的左节点是左侧区间最大值，右节点是右侧区间最大值。建树可以通过递归实现。而对于每个结点，其提供的费用是结点对应的值乘上结点的子节点数目，汇总所有结点的费用就是结果。

还有注意如果你利用递归建树，那么就需要用到一些平衡树结构，这样时间复杂度为$O(n\log_2n)$。但是实际上我们建出的是一个树堆，而建立树堆是可以通过单调栈实现的，这样时间复杂度就优化到了$O(n)$。

# BZOJ1816

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1816](https://www.lydsy.com/JudgeOnline/problem.php?id=1816)

**题解**

如果能组成k+1副牌，那么组成k副牌肯定不是难事。因此二分可以组成的牌数。

如果组成k组牌，需要x张joker，x满足x<=k且x<=m，那么我们就一定能组成k组牌。

# BZOJ1863

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1816](https://www.lydsy.com/JudgeOnline/problem.php?id=1816)

**题解**

对于分配给将军1的奖牌，我们称为特殊奖牌。假设我们我们造好了k种颜色，那么是不是存在一种符合需求的分配方案。这里可以用贪心的方法，对于将军i，如果i与n同奇偶性，则分配尽可能少的特殊奖牌，否则分配尽可能多的特殊奖牌。如果最后将军n得到了至少一个特殊奖牌，那么方案不存在，否则存在。

贪心也可以替换为动态规划，记f(i)、g(i)表示分配前i个人后，第i个人可以得到最多多少特殊奖牌以及最少多少特殊奖牌。这里不考虑第1个人和第n个人的邻接关系。很显然$f(i)=\min(a_1-g(i-1), a_i)$，$g(i)=\max(0, a_i-(k-a_1-(a_{i-1}-f(i-1))))$。如果$g(n)>0$那必定无解，否则有解。

由于方案的存在性随着k的增加递增，因此可以用二分法优化。

# BZOJ3293

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=3293](https://www.lydsy.com/JudgeOnline/problem.php?id=3293)

**题解**

咋一看，最小费用最大流。但是看看数据量，10w级别，再见。

这个问题可以转换为另外一个耳熟能详的形式。记$s_i$表示第i个人初始的金币，$x_i$表示第i个人给后面那个人的金币数，记t为平均金币。那么在进行交换后，第i个人持有的金币应该满足：


$$
s_i+x_{i-1}-x_i=t
$$


$x_1$一旦确认，其他几个未知变量也会对应确认。将所有的变量用$x_1$来表示，可以得出：


$$
x_i=\sum_{j=2}^i(s_j-t)+x_1
$$


我们要做的就是最小化式子


$$
\sum_{i=1}^n|x_i|=\sum_{i=1}^n|\sum_{j=2}^i(s_j-t)+x_1|=\sum_{i=1}^n|x_1-p_i|
$$


这个问题，可以转化为这样的形式：在x轴上放置n个点$p_1,p_2,\ldots ,p_n$，要求我们选择一个点，这个点到其它所有点距离和最小。

很显然无论在哪个位置，当$x_1$向中点靠近时，距离和会递减。因此我们可以选择$x_1$为中点即可。

# BZOJ1150

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1150](https://www.lydsy.com/JudgeOnline/problem.php?id=1150)

**题解**

比较奇怪的一道题。很容易发现电线只会连接邻近的两个点，我们可以根据点下标的奇偶性生成二分图，之后要求的实际上是这副二分图上的最小费用最大流。但是数据量有点大，费用流是过不了的。

仔细观察，可以发现这幅二分图是很特殊的，每个顶点的度都不超过2。我们知道费用流是不断找最短费用路进行增广，最短费用路在这里一定是交错路，我们可以动态维护所有的路径，再手动模拟增广，就可以在不使用费用流算法时达到费用流的效果。

我的方法的时间复杂度是$O(n\log_2n)$。记$d_t$表示第$t$与$t+1$的距离，那么从$i$到$j$的交错路的费用为$\sum_{k=i}^{j-1}(-1)^{k-i}d_k$，这个可以通过前缀和技术预先处理。之后我们将所有的路径维护在一个树集中，并维护一个左结点的可行点集合和右结点的可行点集合。每次我们增广后，都可能会向路径集合增加四条路径。

# BZOJ1053

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1053](https://www.lydsy.com/JudgeOnline/problem.php?id=1053)

**题解**

要计算一个数$x$的因子数，我们需要先利用算术基本定理将其分解为若干个不同的素数的幂的乘积。


$$
x=p_1^{c_1}\ldots p_k^{c_k}
$$


而$x$的因子数可以表示为$g(x)=\prod_{i=1}^k(1+c_i)$。

而我们要找的是小于等于N的因子数最多的x，如果有多个拥有相同因子数的数，那么需要取最小的。很显然要让因子数尽可能多，那么我们可以选择较小的几个素数组成x，实际上较小的素数可以获得的x也是较小的，这与我们目标吻合。

这里只需要小于等于23的所有素数即可，之后深搜暴力，时间复杂度这种东西不重要。

# BZOJ1112

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1112](https://www.lydsy.com/JudgeOnline/problem.php?id=1112)

**题解**

枚举所有可能的区间，共n-k+1种。之后对于每个区间，我们将其中的高度从小到大排序，而在最终高度取到区间高度的中位数时费用最小。

因此用平衡树维护一下区间，之后找一下中位数就好了。

# TIMUS1032

**题意**

[http://acm.timus.ru/problem.aspx?space=1&num=1032](http://acm.timus.ru/problem.aspx?space=1&num=1032)

**题解**

组合数学书上一道用于介绍鸽巢定理的例题。如果以前没看过，我应该也做不出来。

首先给出n个值a1,a1+a2,...,a1+a2+...+an，如果其中有一个模n为0，那么就找到了解。否则由于有n个值落在1~n-1之间，因此至少有两个数有相同值，找到这两个数，其中一个必定是另外一个的前缀，从较长的序列中移除较短的序列那部分就找到解了。

# BZOJ1025

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1025](https://www.lydsy.com/JudgeOnline/problem.php?id=1025)

**题解**

记$f(x,y,n)$表示将边长为x，y的矩形分给n个人的最优解。容易知道


$$
f(x,y,n)=\min(\\
\min_i(\max(f(x\cdot \frac{i}{n},y,i),f(x\cdot \frac{n-i}{n},y,n-i))),\\
\min_i(\max(f(x,y\cdot \frac{i}{n},i),f(x\cdot \frac{n-i}{n},y\cdot \frac{i}{n},n-i)))\\
)
$$


记$T(n)$表示执行形如$f(x,y,n)$所需要的时间。那么有


$$
T(n)=2nT(n-1)+1=\ldots\approx 2^n\cdot n!
$$


注意到


$$
\max(f(x\cdot \frac{i}{n},y,i),f(x\cdot \frac{n-i}{n},y,n-i))
=\max(f(x\cdot \frac{n-i}{n},y,n-i),f(x\cdot \frac{i}{n},y,i))
$$


我们在遍历$i$时，只需要遍历$1~\frac{n}{2}$。利用这个优化可以得到修正后的时间复杂度：


$$
T(n)=nT(n-1)+1\approx n!
$$


由于n只能取到10，而$10!=3628800$，因此足够通过题目了。

# BZOJ1029

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1029](https://www.lydsy.com/JudgeOnline/problem.php?id=1029)

**题解**

解法是贪心，我们先对t2按从小到大排序，之后按序处理所有建筑。

1. 如果还有多余的时间分配给当前建筑用于修复，那么就修复建筑。
2. 否则如果之前修复的建筑的中修复时间最长的建筑的修复时间多余当前建筑的修复时间，则取消对该建筑的修复，转而将时间分配给当前建筑。
3. 否则，就跳过当前建筑。

在处理完第i个建筑后，得到的策略是能修复最多建筑的策略中花费总时间最少的。如果单独将策略中前k个费用最小的建筑提出来，那么提出来的建筑会组成新的策略，是处理完前i个建筑后，共修复k个建筑且费用最小的策略。

# BZOJ1106

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1106](https://www.lydsy.com/JudgeOnline/problem.php?id=1106)

**题解**

记i的出现的左边坐标为l(i)，右边坐标为r(i)。

那么如果l(i)<l(j)<r(j)<r(i)，那么先消除j会让之后消除i少交换两次，而先消除i并不会减少j消除需要的交换次数。其余的值对没有明显先后要求。

我们可以对r(i)-l(i)的大小对所有的值对位置进行排序，从区间较小的开始消除就可以了。

# LUOGU5419

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=5419](https://www.lydsy.com/JudgeOnline/problem.php?id=5419)

**题解**

首先题目上已经给出了最短上升路径的下界，n-1。下面就需要我们构建这样一个可能的完全图。

如果我们能将n(n-1)/2条边均分为n个不相交子集，每个子集大小为(n-1)/2，且相同子集中的边不共享端点。这样我们为相同的子集中的边分配连续的权重，就能保证每次移动都会经过不同子集中的边，从而保证最多移动n-1次，即最长上升路径的长度为n-1。

下面我们考虑分组的策略。

考虑n是奇数的情况，首先我们建立一个顶点序列\[1,2,...,n\]，之后我们构建第一个子集，加入边(2,n),(3,n-1)...之后我们旋转序列一个单位，得到[n,1,2,...,n-1]，之后用类似的方法构建第二个子集，加入边(1,n-1),(2,n-2)...。重复上面过程直到构建了n个子集。可以证明每个子集的大小都是(n-1)/2，且子集中的边无公共端点。接着考虑顶点u，v。由于u、v在序列中的距离一端为奇数，一端为偶数，边(u,v)被处理仅在u、v为奇数一端的中间顶点作为序列起点的时候才会发生，且仅发生一次。这样我们就得到了n个满足条件的大小为(n-1)/2的分组了。

现在考虑n是偶数的情况，先处理1~n-1顶点（奇数个顶点），得到n-1个满足条件的大小为n/2-1的分组后，考虑每个分组，向分组中加入缺少的那个顶点和顶点n组成的边之后，我们就得到了n-1个满足条件的大小为n/2的分组。

# LUOGU1729

**题意**

[https://www.luogu.org/problem/P1792](https://www.luogu.org/problem/P1792)

**题解**

神奇脑回路题。

维护一个双端链表表示环，每次从双端链表中取权重最大的顶点（用堆优化），同时移除它的前驱和后继。

假设被移除的顶点为y，y的前驱为x，后继为z。那么我们能保证必定存在一个最优方案S，其要么包含y，要么同时包含x和z。先假设S不包含x、y、z，那么我们知道S中一定有权重比y小的顶点，我们将其替换为y可以得到更大的总权，因此不可能。若y出现，那么很显然x、z一定不出现与S，下面考虑y不出现的情况。由之前的证明知道x、z至少出现一个，假如仅出现一个，那么可以直接将出现的那个替换为y得到更优解，因此x、z一定成对出现。

考虑到上面提到的内容，我们已经处理了y出现的情况，但是并没有考虑x与z同时出现的情况。我们可以将x、y同时出现的情况作为一个新的结点w替换x、y、z，同时w的权值为x-y+z（因为我们弹出y时已经加上了y的权值，这里换成x、z同时出现的策略，那么总权需要先减去y之后加上x+z）。

# LUOGU3620

**题意**

[https://www.luogu.org/problem/P3620](https://www.luogu.org/problem/P3620)

**题解**

同LUOGU1729。

很显然最终结果中电线只会连接相邻的大楼。

首先我们可以将电线视作点，那么问题就变成了给出若干个带权的点组成的链表，允许选取k个不相邻的点，问最小可能总权值。

我们可以加入一条权值为无穷的点，这个点连接链表的头尾，这样就形成了环。之后就和LUOGU1729一致了。

# LUOGU4131

**题意**

[https://www.luogu.org/problem/P4131](https://www.luogu.org/problem/P4131)

**题解**

首先因为$a\|b-c\|=\|ab-ac\|$，所以可以将$C_i$直接乘到对应的属性里。

接下来考虑到$\|x-y\|\geq x-y$，因此我们可以直接暴力枚举前k-1个属性的符号，来获得前k-1个属性和的上界。

但是第k个属性的符号是负数，而我们没有技术可以枚举其上界怎么办？我们注意到存在遍历顺序，我们可以提前将生物按照第k个属性排序后，按序逐一处理生物，这样就能直接使用减法而不用考虑绝对值问题了。

# LUOGU4528

**题意**

[https://www.luogu.org/problem/P4528](https://www.luogu.org/problem/P4528)

**题解**

观察公式：


$$
f(1324)-f(1243)-f(1432)\\
=(f(1x2x)-f(1423))-f(1432)-f(1243)\\
=f(1x2x)-f(14xx)-f(12xx)+f(1234)\\
=f(1x2x)-f(1xxx)+f(13xx)+f(1234)
$$


最后得出的就是我们要算的。

- f(1x2x)，考虑将第i个值作为2，难点在左边元素的计数，首先统计i左边的小于$y_i$的数的数目c，并统计这些数的下标和s，左边的序列数目应该为$c(i-1)-s-{c \choose 2}$。
- f(1xxx)，非常简单
- f(13xx)，考虑价格第i个值作为3，4的可选值为i右边大于$y_i$的数的数目。现在仅考虑2对应的值，我们需要统计形如$a<i<b,y_a < y_b < i$的数对数目，这个用线段树可以完成，只需要注意到每当i自增1时，实际上带来的影响可以通过线段树批量操作快速完成。
- f(1234)，这个就是一般的统计长度为4的递增序列问题。用线段树统计即可。

# LUOGU4643

**题意**

[https://www.luogu.org/problem/P4643](https://www.luogu.org/problem/P4643)

**题解**

将边权平摊到顶点上，之后统计的时候能保证二者的差值不变。

# Codeforces1209B

**题意**

[https://codeforces.com/contest/1209/problem/B](https://codeforces.com/contest/1209/problem/B)

**题解**

我做的顺序是D、A、C。。。B。这道题还是有点东西的。

一开始看，以为是中国余数定理（怎么可能，C还是一个贪心呢，B怎么可能）。后来搞了搞贪心，没搞出来。最后实际一看，a、b范围很小，只有5。

实际上问题非常简单，由于b范围很小，那么我们可以保证灯下一次亮的时间不会超过10。而a范围很小，我们可以推出灯亮的间隔不会超过10。因此10秒之后，L=lcm(2,4,6,8,10)是所有灯状态的一个周期。因此我们只要暴力枚举到130左右，就能遍历所有可能了。

当然保险起见，枚举个10000也未尝不可。

# Atcoder jsc2019_qual_c

**题意**

[https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_c](https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_c)

**题解**

挺难的题。

首先我们注意到操作顺序不重要。

之后还需要注意到对于两次操作(l1,r1),(l2,r2)，等价于(l1,r2),(l2,r1)。

现在我们需要为每个操作分配一个L、R属性，分配到L的表示其作为操作左端点，R的表示作为操作右端点。

继续观察发现如果一个i位置为L，那么i和i-1在所有操作完成后具有不同的颜色（原本相同变作不同，原本不同变作相同）。如果位置j为R，那么j和j+1在所有操作完成后具有不同的颜色。当然如果两个相连的位置为RL，那么就会相互抵消，两者颜色保留。

通过上面观察我们找到了一个唯一分配L，R的方案，利用这个思路$O(n)$内可以分配LR。

之后为了统计操作数，我们首先要找出左右括号的配对可能数。之后结果还要乘上$n!$，作为操作执行顺序对结果的贡献。

