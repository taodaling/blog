---
categories: technology
layout: post
---

- Table
{:toc}
# 模块

模块可能是一个文件，也可能是一个目录。如果模块是一个目录，Node通常会在这个目录下找一个叫index.js的文件作为模块的入口。

典型的模块是一个包含exports对象属性定义的文件，这些属性可以是任意数据。

下面建立一个currency.js文件作为示范：

```js
var canadianDollar = 0.91;
function roundTwoDecimals(amount)
{
    return Math.round(amount * 100) / 100;
}
exports.canadianToUS = function(canadian){
    return roundTwoDecimals(canadian * canadianDollar);
}
exports.USToCanadian = function(us){
    return roundTwoDecimals(us / canadianDollar);
}
```

这里我们导出了两个函数`canadianToUS`和`USToCanadian`，但是`roundTwoDecimals`和`canadianDollar`依旧是私有的。

要引入模块，需要用到Node的require函数，这个函数以模块路径为参数，Node以同步的方式定位并加载文件。

> require是Node中少数的几个同步I/O操作之一。但是同步调用会阻塞Node，比如在服务器接受请求时用上require，就会遇到性能问题，所以通常都只在程序加载时才使用require和其它同步操作。

之后在相同目录创建一个test-currency.js文件，输入以下内容：

```js
var currency = require('./currency');
console.log('100C = ' + currency.canadianToUS(100) + "U");
console.log('100U = ' + currency.USToCanadian(100) + "C");
```

如果你仅希望导出一个变量，由于不能重写`exports`，因此你需要使用`module.exports`。如果`exports`和`module.exports`同时在一个模块文件中出现，那么仅`module.exports`生效。实际上`exports`是`module.exports`的一个全局引用，而最终导出的实际上是`module.exports`。

## node_modules

前面引入模块使用的是`./currency`，使用的是相对路径。如果只使用`currency`，Node会遵照几个规则搜索这个模块：

1. 如果模块是核心模块，那么直接返回
2. 从当前目录下的node_modules目录开始，不断向上搜索，直到找到目录下有该模块，就返回。
3. 如果模块在环境变量NODE_PATH指定的目录下，就返回。
4. 抛出异常。

## 目录模块

如果模块是目录，加载规则如下：

1. 如果目录下的package.json文件，且文件中包含main元素，那么main元素指定了模块的入口。
2. 在目录下查找index.js作为模块的入口。
3. 抛出异常。

## 模块缓存

Node会把模块作为对象缓存起来。如果程序中两个文件引入了相同的模块，第一次加载会把模块对应的数据存在内存中，这样第二次加载就不会去重新去读取文化。

# 异步回调

创建一个echo.js文件，输入下面内容：

```js
var net = require('net');
var server = net.createServer(function(socket){
    socket.on('data', function(data){
        socket.write(data);
    });
});
server.listen(3000);
```

上面的程序会不断地重述用户的输入。你也可以修改为仅响应第一次：

```js
var net = require('net');
var server = net.createServer(function(socket){
    socket.once('data', function(data){
        socket.write(data);
    });
});
server.listen(3000);
```

## 事件发射器

```js
var EventEmitter = require('events').EventEmitter;
var channel = new EventEmitter();
channel.on('join', function(){
    console.log('Welcome');
});
channel.emit('join');
```

事件只是关键字，可以是任何字符串，但是事件error是特殊的。



# 参考文献

- 《Nodejs实战》