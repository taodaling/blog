---
layout: post
categories: algorithm
---

# 问题描述

提供一段字符串s，s的长度为n。记s\[l..r]表示由s\[l], s\[l+1], ... , s\[r]组成的字符串。
给出Q个请求，每个请求指定l1,l2,r1,r2,其中0<=l1<=r1<n,0<=l2<=r2<n，要求判断s\[l1..r1],s\[l2..r2]是否相同。

# 思路

可以利用哈希解决。对于长度为m的字符串s，我们定义函数h，使得h(s,x)=s\[0]\*x^0+s\[1]\*x^1+...+s\[m-1]\*x^(m-1)。
我们再扩增h的含义，令h(s,x,l,r)=s\[l]\*x^0+s\[l+1]\*x^1+...+s\[r]\*x^(r-l)。
利用差分技术我们能得知h(s,x,l,r)=(h(s,x,0,r)-h(s,x,0,l-1))\*x^(-l)。
这样我们只需要缓存h(s,x,0,0),h(s,x,0,1),...,h(s,x,0,n-1)，以及x^(-0),x^(-1),...,x^(1-n)即可以O(1)时间复杂度算出h(s,x,l,r).

由于h(s,x,0,i+1)=h(s,x,0,i)+s\[i+1]\*x^(i+1)，以及x^(-i-1)=x^(-i)\*x^(-1)，因此可以以递推的方式在O(n)时间复杂度内算出所有缓存值，空间复杂度为O(n)。

但是由于数值可能会过大，超出计算机的有效计算范围，因此我们先取一个大的素数P，一般可以取1e9+7。之后将所有运算都视作在模P的剩余类域中，因此用64位整数既可以表示。

而在模P的剩余类域中任意非0数x，我们知道x^(p-1)=1，因此x^(p-2)=x^(-1)。而计算x^(p-2)可以通过快速幂乘法，时间复杂度为O(log2P)。

因此预处理总的时间复杂度和空间复杂度为O(n)。后面Q个请求可以直接通过比较r1-l1是否等于r2-l2以及h(s,x,l1,r1)是否等于h(s,x,l2,r2)，这是O(1)时间复杂度的操作，因此总的时间复杂度为O(Q)。

这里也说明一下x的选择问题。对于两个长度均为k+1的字符串s，t，若h(s,x)=t(t,x)，则(s\[0]-t\[0])\*x^0+(s\[1]-t\[1])\*x^1+...+(s\[k]-t\[k])\*x^k=0。
即x是一个阶数不大于k的多项式的零点。我们知道除非该多项式为0（即s=t），否则多项式在模P的剩余类域中最多有k个零点，而取到一个零点的概率仅为k/P。当k远小于P时，s与t相等的概率为1-k/P，其接近于1。

# 应用

## 字符串查找

*问题描述*：提供两个字符串s，t，查找所有t在s中出现的位置。

*解法*：t可能出现的下标为0，1，...，因此我们可以通过局部哈希进行判断，这样时间复杂度为O(|s|+|t|)。

```java
n = s.length;
m = t.length;
for(i = 0; i + m < n; i++)
{
  if(h(s,x,i,i+m-1) != h(t,x,0,m-1))
  {
    continue;
  }
  //find a substring of s match t
}
```

## 最长回文

*问题描述*：提供字符串s，查找s中最长的回文。

*解法*：很显然s[i..j]是以i作为起始下标的回文，当且仅当s\[i+1..j-1]是回文，且s\[i]==s[j]。并且我们知道以i为起始下标的最长回文长度至多为以i+1为起始下标的最长回文长度+2。这样我们就可以在O(\|s\|)的时间复杂度内找到最长回文。

```java
n = s.length;
r = s.reverse(); //reverse s and store it into r
lastLength = 1;
maxLength = 1;
for(i = n - 2; i >= 0; i--)
{
  j = min(n - 1, i + lastLength + 2);
  while(h(s,x,i,j)!=h(r,x,n-1-j,n-1-i))
  {
    j--;
  }
  lastLength = j - i + 1;
  maxLength = max(maxLength, lastLength);
}
```
