---
categories: problem
layout: post
---

- Table
{:toc}
# 括号序列判定有效

问题：判断一个括号序列是否合法。

一个有效的括号序列要满足下面两条性质：

**左偏性：任何序列的前缀中左括号出现次数不少于右括号出现次数**

**右偏性：任何序列的后缀中右括号出现次数不少于左括号出现次数**

因此只需要从左往右扫描一次，并从右向左扫描一次。

如果序列中左括号出现次数和右括号出现次数相同，那么满足条件1就意味着满足条件2，而在从左往右扫描结束后可以得到序列中左括号和右括号出现次数的差，因此只需要扫描一次就行了。

**匹配性：序列中左括号出现次数和右括号出现次数相同**

# 带占位符的括号序列求解

问题：判断一个带?占位符的括号序列是否合法，其中?可以替换为左括号或右括号（多个问号可以有独立的取值），如果合法就求出一组可行的替换方案。

我们知道序列中左括号出现次数和右括号出现次数相同是括号序列有解的必要条件，因此我们可以估算出?最终会有多少被替换为左括号，多少被替换为右括号。

好了，我们现在给出另外一个命题：

**任意合法的括号序列中，如果一个右括号出现在左括号之前，那么我们可以交换这两个括号的位置，序列依旧有效。**

这个命题比较简单，因为交换不会影响到序列的左偏性和匹配性，因此交换后的括号也是有效的。

那么我们可以利用这个命题解决我们的问题。如果有一组可行方案，它会导出一个有效的括号序列，如果存在i,j，其中i<j且i下标的?替换为右括号且j下标的?替换为左括号，那么我们就交换二者位置，不断重复上面这个过程，最终会得到另外一个有效序列，其中前几个问号被替换为了左括号，而后面的问号都被替换为右括号。

考虑到我们之前已经得到有多少问号会被分别替换为左括号和右括号，分别数量记为n，m，我们只需要将前n个问号替换为左括号，后m个问号替换为右括号，之后验证序列是否有效。如果有效就找到了一组解，如果无效，就不存在可行的替换方案。

# 利用前视图，左视图和上视图还原积木

问题：在一个n\*n表格中堆积积木，分别给出前视图front，左视图left和上视图top，要求还原积木。

我们可以在每个点尽可能多放积木，只要不违反三个视图的约束即可，即(i,j)可以放置min(front[i],left[j])*top\[i\]\[j\]个积木。

# 矩阵四角逆判同

问题：给出两个n\*m矩阵A，B，矩阵中仅包含0与1，每次选出两个不同的x1,x2和不同的y1,y2，将A\[x1\]\[y1\],A\[x1\]\[y2\],A\[x2\]\[y1\],A\[x2\]\[y2\]取逆，问是否可以通过多次该流程将A转换为B。

我们可以发现每次转换后第x1、x2行，第y1、y2列中1出现次数的奇偶性都不会发生改变。因此我们可以对于任何等于1的A\[x\]\[y\]，其中x<n，y<m，选择x1=x,y1=y,x2=n,y2=m。这样就会将A\[x\]\[y\]置为0。重复上面过程直到不能重复，这时候A的第n行和第m列保存的就是A每列每行的奇偶信息。同样处理B，之后判断A与B是否相同即可。

这里需要说明两点，可以互相转换的矩阵经过处理后一定是相同的。并且由于重复取逆两次可以撤销操作，因此操作存在逆操作，我们对A处理后，按照对B处理的逆序将操作应用到A上，这样就可以将A转换为B。

# 最大权线性基

问题：要求创建一个线性基，每个基都有对应的权重，要求得到的结果权和最大。

很容易想到贪心的方法，将可能的基按权值从大到小加入到线性基中。下面证明正确性。

贪心算法的证明方法一般是证明第一个选择的必定是结果的部分，之后剩下可选择的就变少了，循环证明下去即可。

这里我们证明假设存在一组线性基B，设x为最大权非0基，很显然x一定是结果的一部分，否则我们可以用x替换B中某个基得到更好的结果。之后将所有剩余数与x做亦或和，接下来的问题就变成了除x外的可能基中选取最大权线性基，之后加上x即可。

# 特殊亦或和出现次数

问题：给出一个正整数集合S，提供数$x$，问有多少S的子集C，满足集合C的亦或和xor(C)等于$x$。

首先我们要在S上建立线性基B。存在子集满足集合亦或和等于$x$，等价于线性基与$x$线性无关。很显然对于任意S-B的子集C，都能找到一个B的唯一子集B'，满足xor(B')=x^xor(C)。因此每种S-B的子集都对应一种方案，共$2^{\mid S \mid - \mid B \mid}$方案。

# Codeforces 1152F:Neko Rules the Catniverse

问题：有n个星球，分别标记为1~n，你可以从任意一个星球开始，移动k次。如果你处于x星球，你下一步能移动到1~x+m中你没有到过的星球，问有多少种移动方案。n上限为$10^9$，m上限为4，k上限为12。



首先，可以发现，$m$非常的小。我们可以从n遍历到1，定义动态规划函数$f$，其中$f(i,j,k)$表示考虑第$i$个星球时，总共走过$j$个星球，后面$m$个星球是否走过状态为$k$。如果当前星球加入路径，假设当前路径经过的星球为$p_1,p_2,\ldots,p_{j-1}$，那么仅考虑第i个星球我们有$bitcount(k)+1$种加入方案，第一种是加入到路径的尾部，当然我们还可以加入到后面m个星球中我们途经的星球之前，共$bitcount(k)$种。

由于n很大，不可能直接动态规划解决，但是我们可以利用矩阵的快速幂进行加速。将动态规划转移关系以矩阵进行表示，之后对矩阵进行快速幂后就可以求解了。

# Codeforces 1119H:Triple

问题：给定一个整数$k$。有$n$个集合，第$i$个集合为$\{a_i,b_i,c_i\}$，其中三个整数都小于$2^k$。给定三个数$x,y,z$，对每个集合应用下面变换，将第$i$个集合转换为$x$个$a_i$，$y$个$b_i$，$z$个$c_i$。我们从每个集合中抽取一个整数，并计算异或和。问对于$0,1,\ldots,2^k-1$，分别有多少种方案，使得抽取结果的异或和为该数。其中$n\leq 10^5$，$x,y,z\leq 10^9$。



难题。首先我们可以推出动态规划函数$f$，其中$f(i,j)$表示仅考虑前$i$个集合，从每个集合抽取一个整数，抽取结果异或和为$j$的方案数。可以推出递推公式：


$$
f(i,j)=\sum_{k=0}^{2^k-1}f(i-1,j\oplus k)\cdot p_{i}(k)
$$


其中$p_i$是我们以第$i$个集合建立的多项式，其中项$x^j$的系数表示第$i$个集合中有多少个数$j$。可以看出上面的公式表示的是多项式的异或和卷积，可以利用快速沃尔什变换在$O(k2^k)$的时间复杂度内解决。

但是上面的卷积要发生$n$次，显然会超时。下面就是神奇的官方方法了：

首先很显然将第i个集合中的三个数分别都异或上$a_i$，这样在抽取完后的异或和在异或上$a_1\oplus a_2\oplus \ldots a_n$就可以还原为原先同样抽取方案下的异或和。

现在多项式$p_i$的第$a_i\oplus a_i=0$项系数为$x$，而第$b_i\oplus a_i$项系数为$y$，第$c_i\oplus a_i$项系数为$z$，第$b_i\oplus c_i$项的系数为$w$，其它系数都为$0$。由$FWT$的定义可知：


$$
FWT(p_i)=\sum_{j=1}^{2^k-1}x^j(\sum_{k\&j\in E}p_{ik}-\sum_{k\&j\in O}p_{ik})
$$


可以看出$FWT(p_i)$的所有系数只可能为下面四种$x+y+z+w$、$x+y-z-w$、$x-y+z-w$、$x-y-z+w$。考虑所有多项式$p_1,p_2,\ldots,p_n$的第$j$项的和应该为：


$$
(x+y+z+w)a+(x+y-z-w)b+(x-y+z-w)c+(x-y-z+w)d
$$


很显然对于不同的x,y,z,w的取值，a,b,c,d都是不变的，因此我们可以通过不断改变x,y,z,w的取值，获得一个包含四个方程的线性方程组，这里我们可以第一组取x=1，其余为0，第二组取y=1，其余为0，第三组取z=1，其余为0，第四组取z=1，其余为0。得到下面函数：


$$
\left( \begin{array}{cccc}
1 & 1 & 1 & 1\\
1 & 1 & -1 & -1\\
1 & -1 & 1 & -1\\
1 & -1 & -1 & 1
\end{array} \right)
\left( \begin{array}{cccc}
a\\
b\\
c\\
d\\
\end{array} \right)
=
\left( \begin{array}{cccc}
s_x\\
s_y\\
s_z\\
s_w\\
\end{array} \right)
$$


由于左边多项式的秩非0，因此可以求逆，我们可以得到$a,b,c,d$的一组唯一解。

注意由于$FWT$函数是线性函数，因此$FWT(\sum_ip_i)=\sum_iFWT(p_i)$。我们可以通过4次的$FWT$变换就可以求出需要的四组$s_x,s_y,s_z,s_w$。在得知了第$j$列的$a,b,c,d$解后，我们可以推得


$$
\prod_{i=1}^{n}FWT(p_i)_j=(x+y+z+w)^a(x+y-z-w)^b(x-y+z-w)^c(x-y-z+w)^d
$$


对每一列应用上面的过程，就可以得到$\prod_{i=1}^{n}FWT(p_i)$，时间复杂度为$O(k2^k+n\log2_n)$。

最后我们利用$FWT^{-1}$恢复多项式，得到解。

# Codeforces 1155F:Delivery Oligopoly

这道题有两种解法，先说难的。

动态规划可以用于解决这个问题。一个二边图指图中任意两个顶点之间都有两条没有相同边的路径。可以证明，一个拥有2个以上顶点的二边图G，一定可以由一个较小的二边图S和一条G中的路径P合并而成，S与P没有共用的顶点。

所以我们可以建立两个动态规划公式$f$和$g$。其中$f(i,j,s)$表示由$s$中顶点组成的一条以$i$和$j$为端点的路径中边的数量，而$g(s)$表示顶点集合s组成二边图所需的最少边数目。我们只要处理出这样两个动态规划公式，找到最少边后，逆向求出所有保留的边。

下面说简单的做法。

我们可以发现，图G是二边图等价于G中只有一个强连通分量，因此，我们可以尝试删除一部分边后通过Tarjan算法判断是否只有一个强连通分量。但是边有2^E种可能性，我们不能尝试所有的方案，但是我们可以选择使用贪心算法，遍历所有的边，如果删除这条边后图依旧是双边图，那么我们就把它删除掉。上面这个过程我们需要重复多次，每次都需要随机化排列E。最终取其中表现最好的一次即可。