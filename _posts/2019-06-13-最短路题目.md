---
categories: problems
layout: post
---

- Table
{:toc}

# Floyd-Warshall算法

FW算法可以用于计算图中每个点对的最短距离。这个算法相较Dijkstra算法来说会简单一些，但是如果你会Dijkstra算法，那你应该知道计算单源最短路径的时间复杂度为O(min(V^2, (V+E)logV))，实际上将每个顶点作为源头跑一遍Dijkstra算法的时间复杂度是不逊色于FW算法的，因此非FW算法不可的场景几乎没有。FW算法和Dijkstra算法一样不适用于带负权边的图。

我们用动态规划来计算所有点对的最短距离。由于s与t的最短距离必定会对应至少一条最短路径s..t，而s..t中除了两个端点外序号最大的点记为M(s..t)，称为路径的最大点。利用函数M，我们可以将将图中所有路径分类为n种，第i类路径，其最大点为i。

FW算法的原理就是按分类从小到大处理所有路径，并利用这些路径计算得到所有点对之间的最短距离。记D(i,j,k)表示所有从i到j的前k类路径中最短的路径长度。对于D(i,j,k+1)，很显然i与j之间的最短路要么是前k类路，要么就是第k+1类路。如果是第k+1类路，这条路中的最大点为k+1，将路以k+1为断点分裂为两条，i..k+1，k+1..j，很显然两条路都是前k类路。因此：


$$
D(i,j,k+1)=\min(D(i,j,k), D(i,k+1,k)+D(k+1,j,k))
$$


之后动态规划，O(n^3)可以解决。

# BZOJ1491

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1491](https://www.lydsy.com/JudgeOnline/problem.php?id=1491)

**题解**

Floyd+DP



# 参考文献

[https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95](https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95)