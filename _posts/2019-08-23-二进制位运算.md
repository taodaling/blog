---
categories: algorithm
layout: post
---

- Table
{:toc}

# LUOGU4152

**题意**

[https://www.luogu.org/problem/P4151](https://www.luogu.org/problem/P4151)

**题解**

好题。

首先我们考虑两条不同的从1到n的路径。将两条路径进行亦或操作（公共路径去除，非公共路径保留），我们一定得到若干个环。这也预示着任何从1到n的路径，都可以通过任选一条从1到n的路径后，并亦或上一些环得到。

因此，我们可以找到所有的环，并用线性基处理。之后我们取得任意一条从1到n的路径之后，计算线性基能提供的最大亦或和即可。

要寻找所有的环，我们实际上只需要找到简单环即可，即没有重复边的环，其它环都可以通过这些环的亦或操作得到。我们可以通过LCT维护生成树，之后一旦新加的边构成了环，就不加入该边同时将环的亦或和加入到线性基中。

# Codeforces1208F

**题意**

[https://codeforces.com/contest/1208/problem/F](https://codeforces.com/contest/1208/problem/F)

**题解**

好题。直接给出解法：

我们先处理
$$
a_j \& a_k
$$
，我们定义函数$f(x)$，其值表示x的所有二进制超集中的下标，如果不存在则返回-1。我们可以为每个可能值（M个）维护一个集合，之后按x从大到小计算$f(x)$。注意到我们实际上只需要考虑这些集合中最大的两个下标，因此可以用一个大小为2的最大堆替代上面提到的集合。

之后问题就变成了问集合中任取两个下标不同的元素，求最大或。

我们可以遍历所有可能的第一个元素x。之后我们求不在x中出现的最大位对应的值t，判断t是否出现在x右边，如果出现，则表示可以取到，否则取不到。之后继续处理剩余的位。

时间复杂度为$O((N+M)\log_2M)$，其中M为取值范围，N为数组大小。