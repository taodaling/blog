---
categories: algorithm
layout: post
---

- Table
{:toc}

# LUOGU4152

**题意**

[https://www.luogu.org/problem/P4151](https://www.luogu.org/problem/P4151)

**题解**

好题。

首先我们考虑两条不同的从1到n的路径。将两条路径进行亦或操作（公共路径去除，非公共路径保留），我们一定得到若干个环。这也预示着任何从1到n的路径，都可以通过任选一条从1到n的路径后，并亦或上一些环得到。

因此，我们可以找到所有的环，并用线性基处理。之后我们取得任意一条从1到n的路径之后，计算线性基能提供的最大亦或和即可。

要寻找所有的环，我们实际上只需要找到简单环即可，即没有重复边的环，其它环都可以通过这些环的亦或操作得到。我们可以通过LCT维护生成树，之后一旦新加的边构成了环，就不加入该边同时将环的亦或和加入到线性基中。

# Codeforces1208F

**题意**

[https://codeforces.com/contest/1208/problem/F](https://codeforces.com/contest/1208/problem/F)

**题解**

好题。直接给出解法：

我们先处理
$$
a_j \& a_k
$$
，我们定义函数$f(x)$，其值表示x的所有二进制超集中的下标，如果不存在则返回-1。我们可以为每个可能值（M个）维护一个集合，之后按x从大到小计算$f(x)$。注意到我们实际上只需要考虑这些集合中最大的两个下标，因此可以用一个大小为2的最大堆替代上面提到的集合。

之后问题就变成了问集合中任取两个下标不同的元素，求最大或。

我们可以遍历所有可能的第一个元素x。之后我们求不在x中出现的最大位对应的值t，判断t是否出现在x右边，如果出现，则表示可以取到，否则取不到。之后继续处理剩余的位。

时间复杂度为$O((N+M)\log_2M)$，其中M为取值范围，N为数组大小。

# ARC066B

**题意**

[https://atcoder.jp/contests/arc066/tasks/arc066_b](https://atcoder.jp/contests/arc066/tasks/arc066_b)

**题解**

首先我们需要意识到
$$
a+b=a \oplus b +2\cdot(a\& b)
$$
。

对于只有a为1，而b为0的二进制位，我们可以该二进制位改为a为0，b为1，这样做，$a\oplus b$和$a+b$都不会发生改变。因此处理过后的a是b的一个二进制子集。

现在我们仅考虑符合上面性质的a、b对（a是b的二进制子集），如果有


$$
a\oplus b= u =c\oplus d\\
a+b=v=c+d\Rightarrow a\&b=c\&d
$$


那么我们可以发现对于u中出现的二进制1，b和d都是1，而a和c都是0。而对于u中出现的二进制0，由第二个式子知道，b和d拥有相同的值。故a和c也拥有相同的值。

这样我们就证明了符合条件的(a,b)和(u,v)一一对应。要统计所有的(u,v)，可以通过统计(a,b)得到。

这边可以通过数位DP求解。

# CF1174D

**题意：**

[https://codeforces.com/contest/1174/problem/D](https://codeforces.com/contest/1174/problem/D)

**题解：**

我们可以记构造好的序列为a，而序列a的前缀为b，即b\[i\]=a\[1\]^...^a\[i\]。

任意一段子序列，都可以表示为两个前缀的亦或和，换言之，我们现在需要找到满足条件的一组前缀，使得两两亦或和不为0和x。不为0意味着每个前缀都不同。不为x，意味着对于任意一个数t，t与t^x只能选择一个。因此我们可以通过维护1~2^n个数的可用状况，构造最长的一个前缀，之后将前缀转换为数组。

# 位运算典型问题

给定一个序列$a_1,a_2,\ldots,a_n$，满足$0\leq a_i < 2^k$

**问题1：要求找到两个不同的下标$i\neq j$，使得$a_i \& a_j$最大。**

这个问题的经典做法就是维护一颗二叉树，之后遍历整个序列，当处理$a_i$的时候，我们先进入二叉树贪心搜索与它且最大的数，之后将$a_i$也插入到二叉树中。整体的时间和空间复杂度为$O(nk)$。

**问题2：要求找到两个不同的下标$i\neq j$，使得$a_i | a_j$最大。**

很显然，
$$a_i | a_j\geq \max(a_i\|a_i,a_j|a_j)$$
，因此$i\neq j$的约束可以无视。
我们需要建立一个数组$B$，其中
$$B[i]$$
表示的是序列a中i的二进制超集的数目。这个我们可以利用快速沃什尔变换得到。
之后对于每个数$a_i$，我们从最高比特开始枚举到最低比特，二分判断当一个数为$a_i$时，可以通过或运算得到最大的数是什么。
这个算法的时间复杂度为$O(k2^k)$，空间复杂度为$O(2^k)$。

**问题3：要求找到两个不同的下标$i\neq j$，使得$a_i \oplus a_j$最大。**

这个做法同且运算，也是维护一颗二叉树，遍历序列，贪心找最大。整体的时间和空间复杂度为$O(nk)$。

**问题4：要求找到两个不同的下标$i\leq j$，使得$a_i \oplus a_{i+1} \oplus \ldots \oplus a_j$最大。**

首先我们维护一个新的序列$b_0,b_1,b_2,\ldots, b_n$，其中$b_0=0$，且$b_i=b_{i-1}\oplus a_i$。那么原问题中任意连续区间的亦或和都满足
$$a_i \oplus a_{i+1} \oplus \ldots \oplus a_j=b_{i-1}\oplus b_j$$
，因此现在的问题就变成了在序列$b$中找两个数令其亦或值最大，同问题3。

**问题5：要求找到$a$的某个子序列（子集），使得子序列中的所有数的亦或和最大。**

线性基裸题。时间复杂度为$O(nk)$。

**问题5：要求找到$a$的某个子序列（子集），问可以得到多少不同的亦或和**

线性基裸题。时间复杂度为$O(nk)$。

**问题5：要求找到$a$的某个子序列（子集），问所有可以得到的亦或和中第k小的亦或和**

线性基裸题。时间复杂度为$O(nk)$。

**问题7：要求将序列$a$分成非空两部分，记两部分的亦或和分别为$x$和$y$，要求$x+y$最大**

设两部分分别为$B=\{b_i\}$和$C=\{c_i\}$。分别记大小为$l$和$t$。

由于
$$
x+y=x\oplus y+2\cdot (x\&y)
$$
，而$x\oplus y$是固定的，因此我们需要让$x\&y$最大化。考虑到$x\&y\geq 0$，因此题目中$B$和$C$非空的约束可以忽略。

考虑如果在原序列$a$中，第$i$比特位之和为奇数，那么$x\&y$的第$i$比特一定是0。因此我们将这些和为奇数的比特删除也不会影响$x\&y$的值。之后仅剩下为偶数的比特位，考虑到此时一定有$x=y$，因此我们只需要让$x$最大即可。

我们现在面临的问题是，从修正后的序列（删除和为奇数的比特后）中，挑选一些数值，令其亦或和最大。这个问题实际上就是问题5，用线性基处理一下就好了。

# ABC141F

**题意**

[https://atcoder.jp/contests/abc141/tasks/abc141_f](https://atcoder.jp/contests/abc141/tasks/abc141_f)

**题解**

位运算典型问题第7题。