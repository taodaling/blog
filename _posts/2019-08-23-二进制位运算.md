---
categories: algorithm
layout: post
---

- Table
{:toc}

# LUOGU4152

**题意**

[https://www.luogu.org/problem/P4151](https://www.luogu.org/problem/P4151)

**题解**

好题。

首先我们考虑两条不同的从1到n的路径。将两条路径进行亦或操作（公共路径去除，非公共路径保留），我们一定得到若干个环。这也预示着任何从1到n的路径，都可以通过任选一条从1到n的路径后，并亦或上一些环得到。

因此，我们可以找到所有的环，并用线性基处理。之后我们取得任意一条从1到n的路径之后，计算线性基能提供的最大亦或和即可。

要寻找所有的环，我们实际上只需要找到简单环即可，即没有重复边的环，其它环都可以通过这些环的亦或操作得到。我们可以通过LCT维护生成树，之后一旦新加的边构成了环，就不加入该边同时将环的亦或和加入到线性基中。

# Codeforces1208F

**题意**

[https://codeforces.com/contest/1208/problem/F](https://codeforces.com/contest/1208/problem/F)

**题解**

好题。直接给出解法：

我们先处理
$$
a_j \& a_k
$$
，我们定义函数$f(x)$，其值表示x的所有二进制超集中的下标，如果不存在则返回-1。我们可以为每个可能值（M个）维护一个集合，之后按x从大到小计算$f(x)$。注意到我们实际上只需要考虑这些集合中最大的两个下标，因此可以用一个大小为2的最大堆替代上面提到的集合。

之后问题就变成了问集合中任取两个下标不同的元素，求最大或。

我们可以遍历所有可能的第一个元素x。之后我们求不在x中出现的最大位对应的值t，判断t是否出现在x右边，如果出现，则表示可以取到，否则取不到。之后继续处理剩余的位。

时间复杂度为$O((N+M)\log_2M)$，其中M为取值范围，N为数组大小。

# ARC066B

**题意**

[https://atcoder.jp/contests/arc066/tasks/arc066_b](https://atcoder.jp/contests/arc066/tasks/arc066_b)

**题解**

首先我们需要意识到
$$
a+b=a \oplus b +2\cdot(a\& b)
$$
。

对于只有a为1，而b为0的二进制位，我们可以该二进制位改为a为0，b为1，这样做，$a\oplus b$和$a+b$都不会发生改变。因此处理过后的a是b的一个二进制子集。

现在我们仅考虑符合上面性质的a、b对（a是b的二进制子集），如果有


$$
a\oplus b= u =c\oplus d\\
a+b=v=c+d\Rightarrow a\&b=c\&d
$$


那么我们可以发现对于u中出现的二进制1，b和d都是1，而a和c都是0。而对于u中出现的二进制0，由第二个式子知道，b和d拥有相同的值。故a和c也拥有相同的值。

这样我们就证明了符合条件的(a,b)和(u,v)一一对应。要统计所有的(u,v)，可以通过统计(a,b)得到。

这边可以通过数位DP求解。

# CF1174D

**题意：**

[https://codeforces.com/contest/1174/problem/D](https://codeforces.com/contest/1174/problem/D)

**题解：**

我们可以记构造好的序列为a，而序列a的前缀为b，即b\[i\]=a\[1\]^...^a\[i\]。

任意一段子序列，都可以表示为两个前缀的亦或和，换言之，我们现在需要找到满足条件的一组前缀，使得两两亦或和不为0和x。不为0意味着每个前缀都不同。不为x，意味着对于任意一个数t，t与t^x只能选择一个。因此我们可以通过维护1~2^n个数的可用状况，构造最长的一个前缀，之后将前缀转换为数组。

# 位运算典型问题

给定一个序列$a_1,a_2,\ldots,a_n$，满足$0\leq a_i < 2^k$，其中$k\leq 20$，$n\leq 2^k$。

**问题1：要求找到两个不同的下标$i\neq j$，使得$a_i \& a_j$最大。**

这个问题的经典做法就是维护一颗二叉树，之后遍历整个序列，当处理$a_i$的时候，我们先进入二叉树贪心搜索与它且最大的数，之后将$a_i$也插入到二叉树中。整体的时间和空间复杂度为$O(nk)$。

**问题2：要求找到两个不同的下标$i\neq j$，使得**
$$a_i | a_j$$
**最大。**

很显然，
$$a_i | a_j\geq \max(a_i|a_i,a_j|a_j)$$
，因此$i\neq j$的约束可以无视。
我们需要建立一个数组$B$，其中
$$B[i]$$
表示的是序列a中i的二进制超集的数目。这个我们可以利用快速沃什尔变换得到。
之后对于每个数$a_i$，我们从最高比特开始枚举到最低比特，二分判断当一个数为$a_i$时，可以通过或运算得到最大的数是什么。
这个算法的时间复杂度为$O(k2^k)$，空间复杂度为$O(2^k)$。

**问题3：要求找到两个不同的下标$i\neq j$，使得$a_i \oplus a_j$最大。**

这个做法同且运算，也是维护一颗二叉树，遍历序列，贪心找最大。整体的时间和空间复杂度为$O(nk)$。

**问题4：要求找到两个不同的下标$i\leq j$，使得$a_i \oplus a_{i+1} \oplus \ldots \oplus a_j$最大。**

首先我们维护一个新的序列$b_0,b_1,b_2,\ldots, b_n$，其中$b_0=0$，且$b_i=b_{i-1}\oplus a_i$。那么原问题中任意连续区间的亦或和都满足
$$a_i \oplus a_{i+1} \oplus \ldots \oplus a_j=b_{i-1}\oplus b_j$$
，因此现在的问题就变成了在序列$b$中找两个数令其亦或值最大，同问题3。

**问题5：要求找到$a$的某个子序列（子集），使得子序列中的所有数的亦或和最大。**

线性基裸题。时间复杂度为$O(nk)$。

**问题5：要求找到$a$的某个子序列（子集），问可以得到多少不同的亦或和**

线性基裸题。时间复杂度为$O(nk)$。

**问题5：要求找到$a$的某个子序列（子集），问所有可以得到的亦或和中第k小的亦或和**

线性基裸题。时间复杂度为$O(nk)$。

**问题7：要求将序列$a$分成非空两部分，记两部分的亦或和分别为$x$和$y$，要求$x+y$最大**

设两部分分别为$B=\{b_i\}$和$C=\{c_i\}$。分别记大小为$l$和$t$。

由于
$$
x+y=x\oplus y+2\cdot (x\&y)
$$
，而$x\oplus y$是固定的，因此我们需要让$x\&y$最大化。考虑到$x\&y\geq 0$，因此题目中$B$和$C$非空的约束可以忽略。

考虑如果在原序列$a$中，第$i$比特位之和为奇数，那么$x\&y$的第$i$比特一定是0。因此我们将这些和为奇数的比特删除也不会影响$x\&y$的值。之后仅剩下为偶数的比特位，考虑到此时一定有$x=y$，因此我们只需要让$x$最大即可。

我们现在面临的问题是，从修正后的序列（删除和为奇数的比特后）中，挑选一些数值，令其亦或和最大。这个问题实际上就是问题5，用线性基处理一下就好了。

**问题8：要求在$a$序列中选择两个不同的元素$x$和$y$（值允许相同），要求$x$与$y$进行二进制且运算后包含最多的1。**

这问题实际上要求我们找到某个特殊的数$t$，使得$t$的超集在序列$a$中出现不少于两次。一种简单的方式就是直接统计$0$到$2^k-1$中每个数的超集在序列中出现次数，这个可以直接通过快速沃什尔变换以$O(k2^k)$的时间复杂度计算得到。之后找到这个数$t$后，扫描一遍序列，从中任意拎两个$t$的超集出来。

总的算法时间复杂度为$O(k2^k+n)$

**问题9：要求在$a$序列中选择两个不同的元素$x$和$y$（值允许相同），要求$x$与$y$进行二进制或运算后包含最多的1。**

这里的不同是没有意义的，因为要或运算后包含最多的1，那么必定会选择两个不同的值。

我们可以这样求解，维护一个特殊的数组$b$，$b_i$记录序列$a$中与$i$进行且运算后包含最多$1$的数。这个数组可以这样求，首先对于任意序列中的数$a_i$，很显然与$b_{a_i}=a_i$。之后我们可以进行下推操作，将$b_i$中的数下推给所有$b_j$，其中$j\in i$。之后我们再进行一次上推操作，将每个数$b_i$上推给自己的超集。

上面这个算法看起来应该是$O(3^k)$，但是我们可以仅枚举恰好比当前集合小1和大1的子集或超集，就可以将时间复杂度降低为$O(k2^k)$。

现在我们要找或运算后拥有最多1的家伙了，直接暴力遍历每个序列$a$中的值，记现在的$a_i$，那么要找与$a_i$或运算后含最多$1$的数，实际上就是在找$b_{(2^k-1)\oplus a_i}$，其中$\oplus$表示亦或运算。

总的算法时间复杂度为$O(k2^k+n)$

**问题10：要求在$a$序列中选择两个不同的元素$x$和$y$（值允许相同），要求$x$与$y$进行二进制亦或运算后包含最多的1。**

我没有特别好的解法，不知道别人有没有，我只想出了一个$O(k2^k+3^k)$的算法。

我们可以保留问题9中的数组$b$，只是修改一下定义，$b_i$记录序列$a$中$i$的超集中，拥有最少$1$的数。这样的话，我们的下推操作还是可以执行的，时间复杂度为$O(k2^k)$。

但是在真正计算结果的时候，我们对于每个$a_i$，我们要找到$((2^k - 1)\oplus a_i)$的所有子集$j$，并尝试$a_i$与$b_j$的组合。这样的话这一段的总的时间复杂度为$O(3^k)$。

**问题11：要求在$a$序列中选择两个不同的元素$x$和$y$（值允许相同），要求$x$与$y$进行二进制且运算后包含最多的0。**

问题8要求包含最多的1，这个问题要求包含最多的0，由于1的数目和0的数目的和是常数，因此问题实际上要求我们包含最少的1。

要解决这个问题，需要注意到或运算和且运算的不同，或运算仅在两个数都为0的时候返回0，而且运算仅在两个数都为1的情况下放回1，因此我们可以利用这个性质。事实上下面公式是恒成立的：

$x\land y = \lnot(\lnot x\lor \lnot y)$

因此我们可以直接将所有序列$a$中的二进制位取反，之后利用问题9去寻找或运算后包含最多1的两个数即可。

**问题12：要求在$a$序列中选择两个不同的元素$x$和$y$（值允许相同），要求$x$与$y$进行二进制或运算后包含最多的0。**

同问题11，只要将所有序列$a$中的二进制位取反，之后利用问题8去寻找且运算后包含最多1的两个数即可。

**问题13：给出m个请求，第$i$个请求给定$l_i$和$r_i$，要求在$a_{l_i},\ldots,a_{r_i}$中挑选两个数，使得两个数且运算后拥有最多的1。这个问题额外满足下面条件：$l_i<r_i$，$a_i$最多包含$8$个1，$m\leq 5\cdot 10^6$。**

首先我们定义一个特殊的函数$f$，$f(i,j)$表示仅考虑前$i$个数，值是$j$的超集的最靠右的数的下标。同时我们需要定义另外一个辅助函数$g$，$g(i,j)$表示仅考虑前$i$个数中，所有答案为$j$（在最优策略下取出的两个数且运算后含有$j$个1）的区间的最大左边界。

从左到右处理所有的$a$中元素，就可以很简单的处理出$f$和$g$，而且需要注意的是我们可以直接在$f(i-1,j)$上进行修改得到$f(i,j)$，换言之我们可以复用之前的数据。预处理的时间复杂度为$O(2^8n)$。

下面我们考虑如何处理每个请求，我们注意到对于请求$i$，注意到$g(i,k)$随着$k$的增大而变小，因此我们可以进行二分，但是实际上我们可以直接提前排序请求，这时候按序遍历一次即可。要处理所有右边界为$i$的请求，我们只需要遍历一次k，同时按照左边界从大到小遍历一遍请求即可，总的时间复杂度为$O(M_i+8)$，这里$M_i$表示右边界为$i$的请求数。

整体的时间复杂度为$O((8+2^8)n+m\log_2m)$。还是非常快的。

**问题14：给出m个请求，第$i$个请求给定$l_i$和$r_i$，要求在$a_{l_i},\ldots,a_{r_i}$中挑选两个数，使得两个数或运算后拥有最多的1。这个问题额外满足下面条件：$l_i<r_i$，$a_i$最多包含$8$个1，$m\leq 5\cdot 10^6$。**

与问题13相同，同样定义函数$f(i,j)$和函数$g(i,j)$，只不过$f$对$g$的贡献不同而已。



# ABC141F

**题意**

[https://atcoder.jp/contests/abc141/tasks/abc141_f](https://atcoder.jp/contests/abc141/tasks/abc141_f)

**题解**

位运算典型问题第7题。

# 加法和位运算的转换

**形式1：在区间$[L,R]^2$中有多少个整点$(a,b)$，满足$a+b=a\oplus b$**

这个问题非常简单，只需要了解：$a+b=a\oplus b + 2(a\&b)$。因此问题的实际意思是问区间有多少对数$a$，$b$，满足二者的且运算结算没有1。这个数位DP即可。

**形式2：在区间$[L,R]^2$中有多少个整点$(a,b)$，满足$a+b=a \| b$**

依旧很简单，只需要了解：$a+b=a \| b + a\&b$。因此问题的实际意思是问区间有多少对数$a$，$b$，满足二者的且运算结算没有1。这个数位DP即可。

**形式2：在区间$[L,R]^2$中有多少个整点$(a,b)$，满足$a\oplus b=a \| b$**

还是很简单，只需要了解：$a\|b=a+b-a\&b=a\oplus b+a\&b$。因此问题的实际意思是问区间有多少对数$a$，$b$，满足二者的且运算结算没有1。这个数位DP即可。

# AGC015D

**题意**

[https://atcoder.jp/contests/agc015/tasks/agc015_d](https://atcoder.jp/contests/agc015/tasks/agc015_d)

**题解**

问题问有多少个数可以通过$[A,B]$中的一个或多个数二进制或运算得到。

首先，很显然，区间$[A,B]$中的数肯定都能得到的。

这样我们手动排除一种特殊情况，$A=B$的情况，这时候结果一定为1。之后仅考虑$A<B$的情况。

接下来以二进制的视角观察数值。我们可以无视$A$和$B$的公共二进制前缀，因为这是一定会出现在或运算结果中的。这样我们可以认为$A$和$B$的最开头的二进制位不同，$B$的为1，$A$的为0。记此时$B$的有效长度为$L$。

接下来我们可以将区间$[A,B]$进行拆解，拆解为两部分$[A,2^L-1]$，以及$[2^L,B]$。

先看第二部分，假设$B-2^L$的有效长度为$K$，那么区间$[2^L,B]$可以生成$2^K$个不同的值。

现在考虑$[A,2^L-1]$，由于任意两个数或运算的结果一定不会小于任意一个操作数，因此可以直接断定$[A,2^L-1]$最多生成$2^L-A$个不同的数。

现在考虑两个不同的区间合作可以生成多少个不同的数值。事实上，可以分两种情况考虑，如果$2^K\geq A$，那么我们可以生成额外的$2^L-2^K$个数值。而在$2^K<A$的情况下，实际上我们要考虑的是从区间$[A,2^L-1]$和$[2^L,2^L+2^K-1]$中各取一个数进行或运算，我们提到过，任意两个数位运算或运算结果不会小于任意一个操作数，因此我们可以得到的数一定处于区间$[2^L+A,2^{L+1}-1]$中，总共$2^L-A$个。

# 亦或归0问题

**序列版本：给定一个序列$a_1,a_2,\ldots, a_n$，保证$a_1\oplus a_2 \oplus \ldots \oplus a_n=0$，且$a_i<16$。现在我们希望通过下面操作将整个序列中每个数都化作0：**

**每次操作，你都可以任意选择两个不同的下标$1\leq i<j\leq n$，之后选择任意一个非负整数$x$，并用$a_i\oplus x$替换$a_i$，$a_j\oplus x$替换$a_j$。**

**问最少需要多少次上面所说的操作才能达成目标。**

如果我们对$i$和$j$执行了一次上面的操作，可以发现$a_i\oplus a_j$在操作前后是不变的。我们可以在$a_i$和$a_j$之间连一条边。

考虑通过这些边形成的一个连通块，连通块中每个数可以化为0当且仅当连通块中所有数的亦或和为0。（事实上连通块是一株树，直接在树上dfs即可得到一组方案）

接下来问题就是我们希望使用最少的边，连接一些不连通的连通块，使得每个连通块中数值的异或和为0。

设m是连通块数目，E是使用的边数，那么有等式$n-E=m$成立。因此要让边最少，等价于让连通块的数量最多。

现在考虑如何让连通块的数量最多。

可以证明数值为0的顶点v一定单独形成一个连通块，否则我们从它所在的连通块中可以分离出v，得到更多的连通块。同时如果两个数值相同的顶点u、v存在，那么我们可以始终连接它们两个行程独立的连通块，这样依旧能保证得到的结果中连通块最多在这个性质。（比如u、v在不同连通块中，则从两个连通块中删除这两个顶点，并将u、v连边，同时将两个连通块连边即可，这样连通块的总数不变）。

因此通过上面这个过程，我们可以解决一部分顶点，之后每个数值$x$，$1\leq x\leq 15$，我们最多都只剩下一个顶点。我们可以直接在上面进行位压DP即可，总的时间复杂度为$O(3^{16}+16\cdot 2^{16})$。

**树上版本：给定一株树拥有n个顶点的树，树上的边有边权（边权小于16）。我们希望通过执行若干次下面操作，将每条边的权重变为0：**

**每次操作，你都可以任意选择两个顶点以及一个非负整数$x$，并将两个顶点决定的简单路径中所有的边的权重都亦或上$x$。**

**问最少需要多少次上面所说的操作才能达成目标。**

我们可以将每个顶点的值设置为与它相连的边的权重的亦或和。那么原来操作等价于选择两个顶点，将两个顶点的值亦或上x。

可以证明树上所有边的权重都化为0，当且仅当树上所有顶点的值都化作了0（叶顶点的值为0，当然连它的唯一边的权值也是0，可以用归纳法证明其它情况）。

因此问题等价于有一个值序列，我们每次操作都选择两个值亦或上x，直到序列所有数都为0，这就是序列版本的亦或归0问题。

[题目链接](https://atcoder.jp/contests/apc001/tasks/apc001_f)


# 线形基的一些问题

**问题1：给定一组数$A=\{a_1,a_2,\ldots,a_n\}$，判断通过异或操作可以得到多少不同的数。**

用这组数构建线性基，记$r$为线性基的大小，每个数都可以表示为线性基中若干个数的异或和，因此结果为$2^r$。

**问题2：给定一组数$A=\{a_1,a_2,\ldots,a_n\}$，判断其中有多少个子集，其异或和为0。**

用这组数构建线性基，记$r$为线性基的大小。所有线性基的非空子集的异或和都必定非0，因此所有异或和为0的子集必定包含不属于线性基中的向量。事实上，我们考虑任意非线性基中向量的子集$S$，记其异或和为$x$，我们必定能找到线性基的某个子集$T$使得其异或和为$x$，这样我们就能确定一个异或和为0的子集$S\cup T$。因此所有子集中异或和为0的子集共有$2^{n-r}$个。

**问题3：给定一组数$A=\{a_1,a_2,\ldots,a_n\}$，判断其中有多少个子集，其异或和为$x$。**

假设有两个子集$A$和$B$的亦或和均为$x$，那么$X\oplus Y=0$，这意味着$B$可以通过向集合$X$中加入$X\oplus Y$即可得到$Y$，这边集合的亦或操作是指删除已有的，加入未有的元素。

因此我们需要做的就是建立一个线性基，之后尝试找到线性基的一个子集，令其亦或和为$x$。如果不存在这样的子集，那么就无解。否则设该子集为$X$，设$r$为线性基的大小，我们知道$A$中共有$2^{n-r}$个子集的亦或和为0，我们用这些子集和$X$做亦或操作可以得到所有亦或和为$x$的所有子集，因此可以直接确定亦或和为$x$的子集数目为$2^{n-r}$。

**问题4：给定一组数$A=\{a_1,a_2,\ldots,a_n\}$，问可以切分为最多多少个连续的子序列，要要求任意多个（至少一个）子序列的亦或和都不为0。**

首先所有数亦或和一定不能为0，否则无解。

首先计算所有亦或前缀和，得到新的序列$B=b_1,b_2,\ldots, b_n$，其中$b_i=a_1\oplus a_2\oplus \ldots \oplus a_i$。那么$A$序列中任意子序列的亦或和都可以表示为$B$序列中两个数的亦或和。考虑一个子序列划分，子序列的亦或和线性无关，假设子序列的结尾下标分别为$i_1,i_2,\ldots, i_k$。那么如果我们建立线性基，将$b_{i_1},b_{i_1}\oplus b_{i_2}, \ldots, b_{i_{k-1}}\oplus b_{i_k}$放入其中，由线性基的性质知道，我们可以等价将$b_{i_1},b_{i_2},\ldots, b_{i_k}$放入而不会影响结果。

因此问题变成，从$B$序列中选择一个子集（$b_n$必须选择），使得它们线性无关。我们可以先将$b_n$加入线性基，之后随便按什么顺序加入其它元素，最后线性基的大小就是所要的结果。

提供一个[例题](https://codeforces.com/contest/1101/problem/G)。

**问题5：给定一颗有$n$个顶点的树，每个顶点上都写了一个数字。对于每个顶点，回答在以该顶点为根的子树中，任意选取顶点上的数字，有多少种不同的亦或和**

这个问题实际上问的是线性基合并，某个集合上的线性基，可以通过亦或得到这个集合上的所有数值。而两个集合的线性基合并后，可以通过亦或得到这两个集合上所有的数值。

**问题6：给定一组数$A=\{a_1,a_2,\ldots,a_n\}$，之后q次修改操作，每次操作给定两个下标$i$,$j$，要求交换$a_i$和$a_j$。每次操作后问可以切分为最多多少个连续的子序列，要求任意多个（至少一个）子序列的亦或和都不为0。**

这个问题是问题4的强化版本，我们接下来证明交换操作不会影响最终结果。

问题4中将问题转换为从$B$序列得到线性基。现在考虑交换带来的影响，我们只需要证明在交换$i$和$j=i+1$时不会影响结果即可，因为任意交互都可以通过若干次相邻交换得到。

考虑交换带来的影响，只有1个数发生了变化$b'_i=a_{i+1}\oplus b_{i-1}$。而其它数都没有变化。而$b'_i$和$b_{i+1}$构成的线性基与$b_i$和$b_{i+1}$构成的线性基相同，因此结果不变。

**问题7：给定一个$A=\{a_1,a_2,\ldots, a_n\}$，提供$q$个请求，请求分两类，查询请求和修改请求。修改请求修改某个$a_i$的值。查询请求由三个数确定$l,r,x$，从$a_l,a_{l+1},\ldots, a_r$中选取任意个数，将这些数的亦或和再亦或上$x$后得到结果，问最大的结果是多少。其中$n,q\leq 10000$，$a_i\leq 2^{20}$**

这个问题是询问区间元素上的线性基。由于线性基支持$O((log_2MAX)^2)$的时间复杂度的合并操作，因此我们可以把区间上的线性基放到线段树上维护，这样总的时间复杂度为$O((n+q)(\log_2MAX)^3)$。

**问题8：给定一个$A=\{a_1,a_2,\ldots, a_n\}$，提供$q$个请求，请求由三个数确定$l,r,x$，从$a_l,a_{l+1},\ldots, a_r$中选取任意个数，将这些数的亦或和再亦或上$x$后得到结果，问最大的结果是多少。其中$n,q\leq 500000$，$a_i\leq 2^{20}$**

类似问题7，但是不支持修改，$n$和$q$大了很多。

我们需要注意到线性基具有一个性质。考虑后缀$a_{i+1},a_{i+2},\ldots, a_n$，如果我们贪心构建线性基，且被加入的数为$a_{i_1},a_{i_2},\ldots, a_{i_k}$。那么在考虑后缀$a_i,a_{i+1},a_{i+2},\ldots, a_n$，贪心构建线性基，会被加入的数仅可能为$a_i,a_{i_1},a_{i_2},\ldots, a_{i_k}$的子集。因此我们可以在处理完以下标$i+1$开始的后缀后，记录下加入到线性基中的数的下标。之后在处理以$a_i$开始的后缀时，就可以复用这部分信息，在$O((\log_2MAX)^2)$的时间复杂度内完成构建。

于是我们可以在$O(n(\log_2MAX)^2)$的时间复杂度内得到所有连续子序列的线性基，在计算线性基的同时离线处理一下请求即可。总的时间复杂度为$O(n(\log_2MAX)^2+q\log_2MAX)$。

这题在CF上有一道[例题](https://codeforces.com/contest/1100/problem/F)。

**问题9：给定$n$个数$a_1,a_2,\ldots, a_n$，考虑所有$n^2$个二元组$(a_i,a_j)$，其亦或和为$a_i\oplus a_j$，我们将这些二元组的异或和按照从小到大排序后，问第k大的值为？其中$n\leq 10^6$**

我们可以将$a_i$放到前缀树上进行维护。同时维护多个指针，表示可能的两个元素对应的区间。这样我们就可以通过二分询问有多少个数对的亦或和大于等于$x$来得出第$k$大的值，考虑到在前缀树上的遍历实际上已经帮我们完成了二分的过程，因此只需要遍历前缀树即可。

这里有一个特殊的点就是前缀树可能会占用过大的空间，我们可以用排序后的数组来代替前缀树。（数组的区间对应某个前缀树顶点，区间中第$i$位为1的处于右孩子中，为0的处于左孩子中）

**问题10：给定一颗拥有$n$个顶点的树，树上每条边都有自己的权重，对于树上所有$n^2$顶点对$(u,v)$，我们记$f(u,v)$为从$u$到$v$的唯一路径上的所有边的权重的亦或和，将这些路径异或和从小到大排序后，问第$k$大的亦或和是多少，其中$n\leq 10^6, 1\leq k\leq n^2$**

首先我们需要将路径的异或和转换为路径两个端点的权重的异或和。方法记录每个顶点的权重为从该顶点到根的路径上所有边的权重的异或和。

现在问题变成了问题9。

这里有一道[题目](http://codeforces.com/contest/1055/problem/F)。

# Codeforces 1033F

**题意**

[https://codeforces.com/contest/1033/problem/F](https://codeforces.com/contest/1033/problem/F)

**题解**

首先$n$这个东西是障眼法，因为取值只可能有$2^w$种，我们可以一开始就记录下每个数出现的次数。下面考虑单独处理每个请求，对于一个请求，考虑它的第$i$位的运算，我们可以发现要保证这一位为0，那么最多有3种可能性（总共4种可能性，但是由于至少有一种可能性的结果为1，因此最多还剩3种可能性）。于是我们可以递归暴力枚举，这样的时间复杂度为$O(n+m3^w)$，稍微有点大。

但是注意到所有位运算符都满足交换性，因此我们可以把01和10两种情况压缩成一种，我们可以将00记作0，01和10记作1，11记作2（就是1出现的数目而已）。这样我们发现每个运算符最多只能在两种可能性下给出结果0，因此我们可以暴力枚举这两种可能性，总的时间复杂度就降为了$O(n+m2^w)$。

具体实现，我们可以维护一个多维数组，记录每一位和满足某个条件的二元组数目。这里由于会出现动态维护的多维数组，比较麻烦，我们可以直接将其作为三进制进行压缩即可。

总的时间复杂度为$O(n+m2^w+w(2^w)^2)$。

这里还有一个发现，就是如果我们将每个数先转成二进制形式，之后将二进制直接当成三进制处理的话，就可以直接用加法来预处理那个多维数组了。即多维数组的第$k$项的值为$\sum_{i+j=k}C_iC_j$，其中$C_i$表示三进制为$i$的数出现次数，$C_j$同理。这是一个卷积，我们可以直接用FFT计算，这样预处理的时间复杂度就会从$w(2^w)^2$降低到$w3^w$。