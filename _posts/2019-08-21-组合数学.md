---
categories: math
layout: post
---

- Table
{:toc}
# Catalan数

## 理论

假设我们有n个1和m个-1，我们希望排列这n+m个数，并且要求排列$a_i$满足下面条件：

- 对于任意$0 \leq j \leq n+m$，都有$\sum_{i\leq j} a_i \geq -k$。

我们希望求出有多少种不同的排列满足条件。

首先如果$m > n+k$，那么有效排列数一定为0。下面仅考虑$m\leq n+k$的情况。

我们知道总共的排列数为$n+m \choose n$，因此只要减去不满足条件的排列数，就可以得到满足的排列数了。下面我们考虑怎么计算不满足条件的排列数。

对于某个不满足条件的排列$B=[b_i]$，一定能找到最小的下标，一定能找到最小的下标j，使得，使得\sum_{i\leq j} a_i = -(k+1)。我们将排列。我们将排列B的从第的从第j+1个下标开始的值全部取相反值，即改为，改为。这样我们就得到了一个个下标开始的值全部取相反值，即1改为-1，-1改为1。这样我们就得到了一个m-1-k个和个1和n+1+k个的排列。要还原，我们只需要找到最小的下标个-1的排列。要还原，我们只需要找到最小的下标j，使得，使得\sum\_{i\leq j} a_i = -(k+1)，将后面的元素取反就好了。这似乎暗示了，将后面的元素取反就好了。这似乎暗示了n个和个1和m个的无效排列与个-1的无效排列与m-1-k个和个1和n+1+k个的排列之间存在类似双射的关系。首先很明显从前者到后者一定是单射，即不同的输入对应不同的输出，同时由于个-1的排列之间存在类似双射的关系。首先很明显从前者到后者一定是单射，即不同的输入对应不同的输出，同时由于m-1-k个和个1和n+1+k个的排列中必定能找到这样的个-1的排列中必定能找到这样的j$，使得前j个数的和为-(k+1)，因此映射是满射。

满射意味着$n$个1和$m$个-1的无效排列与$m-1-k$个1和$n+1+k$个-1的排列数目相同，即总有效排列数为：


$$
{n+m\choose n} -{n + m \choose n + 1 + k}
$$




## 例子1

Catalan数最简单的例子就是n个左括号和n个右括号能构成多少有效的括号序列了。



首先一个括号序列有效，当且仅当排列中所有前缀部分中，左括号数不少于右括号数。如果我们将左括号视作1，右括号视为-1，取$k=0$，那么就转换为Catalan数问题了。有效数为



$$
{2n\choose n} -{2n \choose n + 1}
$$



# 分配问题

对于n个非负变量$x_1,x_2,\ldots,x_n$，问满足下面等式的分配方案有多少种：


$$
x_1+x_2+\ldots+x_n=m
$$


这等价于m个小球，我们向其中插入$n-1$个挡板，将其切分为n部分的方案数，因此我们可以直接得出方案数为：
$$
{m+n-1 \choose n-1}
$$
。



现在考虑满足下面不等式的分配方案有多少种：


$$
L\leq x_1+x_2+\ldots+x_n\leq R
$$


我们现在进行推导：


$$
\sum_{i=L}^R{i+n-1\choose i}\\
=\sum_{i=L}^R{i+n-1\choose i}+{L+n-1\choose L-1}-{L+n-1\choose L-1}\\
=\sum_{i=L+1}^R{i+n-1\choose i}+{L+n-1\choose L}+{L+n-1\choose L-1}-{L+n-1\choose L-1}\\
=\sum_{i=L+1}^R{i+n-1\choose i}+{L+n\choose L}-{L+n-1\choose L-1}\\
\ldots\\
={R+n\choose R}-{L+n-1\choose L-1}
$$


现在考虑一个更简单的不等式的分配方案：


$$
x_1+x_2+\ldots+x_n\leq m
$$


进行推导：


$$
\sum_{i=0}^m{i+n-1\choose i}\\
=\sum_{i=1}^m{i+n-1\choose i}+1\\
={m+n\choose m}-{n\choose 0}+1\\
={m+n\choose m}
$$


其实这个问题也等价于下面等式成立的前提下，前n个变量有多少种分配方案。


$$
x_1+x_2+\ldots+x_n+x_{n+1}=m
$$

由于前n个变量唯一决定变量$x_{n+1}$，因此等于等式的总分配数。



# 容斥原理

假设有全集$S$，以及全集的若干子集$A_1,A_2,\ldots, A_k$。

在实际应用中要统计多个子集的交集的大小是比较容易的，但是要统计多个子集的并集的大小则比较困难。对于这种情况，我们可以使用容斥原理将并运算简化为若干次交运算。

容斥原理的公式如下：


$$
|A_1\cup A_2 \cup \ldots \cup A_k|\\
=\sum_i|A_i|-\sum_{i,j|i\neq j}|A_i\cap A_j|+\ldots+(-1)^{k+1}\sum_{i_1,i_2,\ldots,i_k|i_1\neq i_2\neq\ldots \neq i_k}|A_{i_1}\cap A_{i_2}\cap\ldots\cap A_{i_k}|
$$

$$
|\overline{A_1\cup A_2 \cup \ldots \cup A_k}|\\
=|S|-|A_1\cup A_2 \cup \ldots \cup A_k|\\
=|S|-\sum_i|A_i|+\sum_{i,j|i\neq j}|A_i\cap A_j|+\ldots+(-1)^{k}\sum_{i_1,i_2,\ldots,i_k|i_1\neq i_2\neq\ldots \neq i_k}|A_{i_1}\cap A_{i_2}\cap\ldots\cap A_{i_k}|
$$


## 例子1

统计1~100中能被2,3同时整除的数的数目。

记$S=\{1,2,\ldots, 100\}$，记$A_i$表示$S$中所有能被i整除的数的集合。那么我们要求的实际上就是：


$$
|A_2 \cup A_3|=|A_2|+|A_3|-|A_2\cap A_3|\\
=\lfloor 100 /2 \rfloor+\lfloor 100 / 3 \rfloor - \lfloor 100 / 6 \rfloor
=50+33-16=67
$$

# 第一类斯特林数

第一类斯特林数
$$
s(n,k)
$$
定义为下面公式的系数：


$$
x^{\underline{n}}=\sum_{k=0}^n
s(n,k)
x^k
$$


定义无符号斯特林数为：


$$
c(n,k)=
\left[
\begin{array}{c}
n\\
k
\end{array}
\right]
=|s(n,k)|
$$


可以利用下面公式通过无符号斯特林数计算有符号斯特林数：


$$
s(n,k)=(-1)^{n-k}c(n,k)
$$


无符号斯特林数满足：


$$
x^{\overline{n}}=\sum_{k=0}^n
c(n,k)
x^k
$$


无符号斯特林数的递推关系为：


$$
\left[
\begin{array}{c}
n+1\\
k
\end{array}
\right]
=
n
\left[
\begin{array}{c}
n\\
k
\end{array}
\right]
+
\left[
\begin{array}{c}
n\\
k-1
\end{array}
\right]
$$


有符号斯特林数的递推公式为：


$$
s(n+1,k)=-ns(n,k)+s(n,k-1)
$$


无符号斯特林数的组合意义是：将$n$个元素分成$k$个环（都不空）的方案数为
$$
\left[
\begin{array}{c}
n\\
k
\end{array}
\right]
$$


## 生成函数

对于给定的n，设$F^{(n)}$为第一类斯特林数的生成函数，即
$$
F^{(n)}_i=
\left[
\begin{array}{c}
n\\
i
\end{array}
\right]
$$
。由于无符号斯特林数满足：



$$
x^{\overline{n}}=\sum_{k=0}^n
c(n,k)
x^k
$$


因此可以直接得到：


$$
F^{(n)}(x)=x^{\overline{n}}=\prod_{i=0}^{n-1}(x+i)
$$


乘积符号内是n个多项式，我们可以用分治+FFT在$O(n(\log_2n)^2)$时间复杂度内计算得到。下面介绍用倍增+FFT在$O(n\log_2n)$的算法。

容易发现下面公式成立：



$$
F^{(n)}(x)=
\left\{
\begin{array}{ll}
F^{(\frac{n}{2})}(x)F^{(\frac{n}{2})}(x+\frac{n}{2})&, 2|n\\
(x+n-1)F^{n-1}(x)&,else
\end{array}
\right.
$$


我们可以用倍增算法来解决。下面给出计算$F^{(n)}(x+n)$的方法：

$$
F^{(n)}(x+n)\\
=\sum_{i=0}^nF^{(n)}_i(x+n)^i\\
=\sum_{i=0}^nx^i\sum_{j=i}^nF^{(n)}_jn^{j-i}{j\choose i}\\
=\sum_{i=0}^nx^i\sum_{j=i}^nF^{(n)}_jn^{j-i}\frac{j!}{i!(j-i)!}\\
=\sum_{i=0}^n\frac{1}{i!}x^i\sum_{j=i}^n[F^{(n)}_jj!][\frac{n^{j-i}}{(j-i)!}]\\
$$


可以看出后面项是等差卷积，可以用FFT直接得到。

总的时间复杂度为

$$
T(n)=T(\frac{n}{2})+O(n\log_2n)=O(n\log_2n)
$$


# 第二类斯特林数

第二类斯特林数
$$
\begin{Bmatrix}
n\\
k
\end{Bmatrix}
$$
的定义为下面公式的系数：


$$
x^n = \sum_{k=0}^n
\begin{Bmatrix}
n\\
k
\end{Bmatrix}
x^{\underline{k}}
$$


第二类斯特林数的递推公式为：


$$
\begin{Bmatrix}
n+1\\
k
\end{Bmatrix}
=
k \begin{Bmatrix}
n\\
k
\end{Bmatrix}
+
\begin{Bmatrix}
n\\
k-1
\end{Bmatrix}
$$


第二类斯特林数的直接计算公式为：


$$
\begin{Bmatrix}
n\\
k
\end{Bmatrix}
=
\frac{1}{k!}\sum_{i=0}^k(-1)^i{k\choose i}(k-i)^n
$$


第二类斯特林数
$$
\begin{Bmatrix}
n\\
k
\end{Bmatrix}
$$
的可以用来表示将n个元素拆分成k个非空子集的方法数。



## 生成函数

对于某个n，以及所有$0\leq k \leq n$计算
$$
\begin{Bmatrix}
n\\
k
\end{Bmatrix}
$$
，可以利用快速卷积在
$$
O(n\log_2n)
$$
的时间复杂度内实现。

观察下面第二类斯特林数的直接计算公式：


$$
\begin{Bmatrix}
n\\
k
\end{Bmatrix}
=
\frac{1}{k!}\sum_{i=0}^k(-1)^i{k\choose i}(k-i)^n\\
=\sum_{i=0}^k(-1)^i(k-i)^n\frac{1}{i!(k-i)!}\\
=\sum_{i=0}^k[(-1)^i\frac{1}{i!}][(k-i)^n\frac{1}{(k-i)!}]
$$


记第二类斯特林数的生成函数为$F$，
$$
F_k=\begin{Bmatrix}n\\k\end{Bmatrix}
$$
那么我们可以推出$F$是另外两个多项式的卷积：


$$
F(x)=[\sum_{i=0}^n(-1)^i\frac{1}{i!}] \times [\sum_{i=0}^ni^n\frac{1}{i!}]
$$


因此利用快速卷积算法就可以得到第二类斯特林数的生成函数。

# 斯特林反演

反演内容：


$$
f(n)=\sum_{k=0}^n
\begin{Bmatrix}n\\k\end{Bmatrix}
g(k)
\Leftrightarrow
g(n)=
\sum_{k=0}^n
s(n,k)f(k)
=
\sum_{k=0}^n
(-1)^{n-k}
\left[
\begin{array}{c}
n\\
k
\end{array}
\right]
f(k)
$$


以及反转公式：


$$
\sum_{k=m}^n (-1)^{n-k}\begin{bmatrix}n\\k\end{bmatrix} \begin{Bmatrix}k\\m\end{Bmatrix}=[m=n]\\
\sum_{k=m}^n (-1)^{n-k}\begin{Bmatrix}n\\k\end{Bmatrix} \begin{bmatrix}k\\m\end{bmatrix}=[m=n]
$$



# 最值反演(min-max容斥)

$$
\max\{S\}=\sum_{T\subseteq S}(-1)^{|T|+1}\min\{T\}\\
\min\{S\}=\sum_{T\subseteq S}(-1)^{|T|+1}\max\{T\}
$$



证明：

考虑第一个公式。假设x为S中的第i+1大元素。那么x的展开项系数为：


$$
\sum_{j=0}^i(-1)^j{i\choose j}=(1-1)^i=0^i
$$

因此只有当i为0时，系数为1，其它情况都为0。第二个公式同理可证。

# 几类组合数加总的计算方式

## 类型1

对于所有
$$
k=0,1,2,\ldots,n
$$
，要求计算：


$$
f(k)=\sum_{i=0}^nc_i{k\choose i}
$$


很显然存在$O(n^2)$的算法，但是这太慢了，下面我们利用多项式进行加速计算。


$$
f(k)=\sum_{i=0}^nc_i{k\choose i}\\
=\sum_{i=0}^nc_i\frac{k!}{i!(k-i)!}\\
=k!\sum_{i=0}^n\frac{c_i}{i!}\frac{1}{(k-i)!}\\
$$


其中
$$
\sum_{i=0}^n\frac{c_i}{i!}\frac{1}{(k-i)!}
$$
可以表示为下面两个函数的卷积


$$
A(x)=\sum_{i=0}^n\frac{c_i}{i!}x^i\\
B(x)=\sum_{i=0}^n\frac{1}{i!}x^i
$$


利用快速卷积可以在$O(n\log_2n)$的时间复杂度内实现。记
$$
C(x)=A(x)\times B(x)
$$
 ，那么
$$
f(k)=k!C_k
$$

## 类型2

对于所有
$$
k=0,1,2,\ldots,n
$$
，要求计算：


$$
f(k)=\sum_{i=0}^nc_i{i\choose k}
$$


很显然存在$O(n^2)$的算法，但是这太慢了，下面我们利用多项式进行加速计算。


$$
f(k)=\sum_{i=0}^nc_i{i\choose k}\\
=\sum_{i=0}^nc_i\frac{i!}{k!(i-k)!}\\
=\frac{1}{k!}\sum_{i=0}^nc_ii!\frac{1}{(i-k)!}
$$


其中右边部分
$$
\sum_{i=0}^nc_ii!\frac{1}{(i-k)!}
$$
是等差卷积，即令


$$
A(x)=\sum_{i=0}^nc_{n-i}(n-i)!x^i\\
B(x)=\sum_{i=0}^ni!x^i
$$


令
$$
C(x)=A(x)\times B(x)
$$


那么有
$$
f(k)=\frac{1}{k!}C_{n-k}
$$


利用快速卷积算法我们可以在$O(n\log_2n)$的时间复杂度内计算出所有结果。

## 类型3

统计：

$$
\sum_{i=0}^a\sum_{j=0}^b{n \choose i}{n - i\choose j}
$$

其中$a+b + 1\geq n$。

先来考虑其组合意义，这个问题等价于，有一个序列，取值范围为0~2。我们希望0出现的次数不会超过a，1出现的次数不会超过b。问有多少这样的序列。

我们可以用容斥来解决，问题变成四个：

- 总共有多少个序列（$3^n$)
- 0出现a次以上的序列数
- 1出现b次以上的序列数
- 0、1各出现a、b次以上的次数（0）

因此我们只需要解决第二个和第三个问题，比如第二个问题：

$$
\sum_{i=a+1}^n{n\choose i}2^{n-i}
$$

这只是一趟循环，第三个问题同。整个时间复杂度为$O(n)$。

如果不能保证$a+b+1\geq n$，那么我们可以将问题现在转换为类型1，之后求解，时间复杂度为$O(n\log_2n)$。

# Codeforces1204E

**题意**

[https://codeforces.com/contest/1204/problem/E](https://codeforces.com/contest/1204/problem/E)

**题解**

枚举可能的f取值，0~n，之后用Catalan数统计g(i)，其中g(i)表示f取值小于等于i的序列数。之后求解。时间复杂度为$O(n+m)$。



# Codeforces449D

**题意**

[https://codeforces.com/problemset/problem/449/D](https://codeforces.com/problemset/problem/449/D)

**题解**

要统计有多少个序列且运算和为0，可以通过统计有多少序列且运算和非0得到。而要统计后者，容易观察一个序列且运算非0，则至少存在一个二进制位，序列中所有元素在这个二进制位处值都是1。

记$A_i$表示所有且运算结果中第i个二进制位为1的所有序列组成的集合。那么我们实际上要统计的就是$\|A_0\cup A_1\cup \ldots \cup A_k \|$，这里k取20。这可以利用容斥得到。

下面我们说明如何快速计算上面提到的若干个元素的交集大小。首先我们先统计每个数在序列中出现的次数，记作$f(x)$。之后统计$g(x)$，表示所有x的超集y（y&x=x）出现的次数，这可以利用快速沃什尔变换得到。

最后比如要统计$\|A_0\cap A_1\|$，即有多少序列的且运算结果是3的超集，首先我们容易得知序列中的所有元素都来自3的超集，而3的超集的大小为$g(x)$，每个数都有出现和不出现两种情况，因此总的序列数为$2^{g(x)}-1$，这里减去1是因为序列的长度不能为0。

# BZOJ5093

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=5093](https://www.lydsy.com/JudgeOnline/problem.php?id=5093)

**题解**

先推出公式，记$f(n,k)$为我们要求的：


$$
f(n,k)=\sum_{E}\sum_{i=0}^n(\sum_{(i,j)\in E}1)^k\\
=\sum_{i=0}^n\sum_{E}(\sum_{(i,j)\in E}1)^k\\
=\sum_{i}^n\sum_{j=0}^{n-1}j^k{n-1\choose j}2^{n\choose 2}\\
=n2^{n\choose 2}\sum_{j=0}^{n-1}j^k{n-1\choose j}
$$


接下来我们计算


$$
\sum_{j=0}^{n-1}j^k{n-1\choose j}
$$


套入第二类斯特林数定义：


$$
x^n = \sum_{k=0}^n
\begin{Bmatrix}
n\\
k
\end{Bmatrix}
x^{\underline{k}}
$$


得到：


$$
\sum_{j=0}^{n-1}j^k{n-1\choose j}\\
=\sum_{j=0}^{n-1}{n-1\choose j}\sum_{i=0}^k
\begin{Bmatrix}
k\\
i
\end{Bmatrix}
j^{\underline{i}}\\
=\sum_{j=0}^{n-1}{n-1\choose j}\sum_{i=0}^k
\begin{Bmatrix}
k\\
i
\end{Bmatrix}
{j\choose i}i!\\
=\sum_{i=0}^k
\begin{Bmatrix}
k\\
i
\end{Bmatrix}
i!
\sum_{j=0}^{n-1}{n-1\choose j}{j\choose i}
$$


考虑形如
$$
g(n,i)=\sum_{j=0}^n{n\choose j}{j\choose i}
$$
的组合数的意义，其等价于从n个标记为0的石头中取任意块，之后标记为1，之后从取出的j块石头中再取i块，标记为2。问有多少种标记法。我们可以提前从n块石头取出i块石头标记2，之后其余n-i块石头可以标0或标1。因此总共取法为
$$
{n\choose i}2^{n-i}
$$


代入简化公式得到：


$$
\sum_{j=0}^{n-1}j^k{n-1\choose j}\\
=\sum_{i=0}^k
\begin{Bmatrix}
k\\
i
\end{Bmatrix}
i!
{n-1\choose i}2^{n-1-i}
$$


其中斯特林数可以通过快速卷积得到。总的时间复杂度为$O(k\log_2k)$。

# Codeforces960G

**题意**

[https://codeforces.com/contest/960/problem/G](https://codeforces.com/contest/960/problem/G)

**题解**

由于无论从左边开始还是右边开始，最后拿的一定是最大值。因此最大值将序列分为了左右两边。称一个数为局部最大，当且仅当这个数之前没有比它大的数。那么我们实际上从左边能拿到a个数，就意味着最大值坐标，共有a-1个局部最大值。同理最大值右边有b-1个局部最大值。

定义函数$f(i,j)$表示拥有j个局部最大值的长度为i的排列数目。那么我们要求的实际上就是：


$$
g(n,a,b)=\sum_{i=0}^{n-1}{n - 1\choose i}f(i,a-1)f(n-1-i,b-1)
$$


考虑如何放置排列中的最小值，容易发现$f$满足下面递推性质：


$$
f(i,j)=f(i-1,j-1)+(i-1)f(i-1,j)
$$


这个递推式与第一类stirling数是相同的，同时在边界情况与第一类stirling数拥有相同值，因此可以认为：
$$
f(i,j)=c(i,j)
$$


第一类stirling数表示的是将i个数分成j个环的策略数。利用这个性质我们可以简化要求的结果：


$$
g(n,a,b)=c(n-1,a+b-2){a+b-2\choose a-1}
$$


stirling数可以通过快速卷积得到。总的时间复杂度为$O(n\log_2n)$。

# Atcoder jsc2019_qual_f

**题意**

[https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_f](https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_f)

**题解**

毒瘤题。假设满足第一个条件的数目为$f(n,L,R)$，利用组合数学可以直接得到：


$$
f(n,L,R)={n+R\choose R}-{n+L-1\choose L-1}
$$


接下来考虑第二个条件，很讨厌的条件。会导致重复统计的问题。现在我们可以考虑在满足第一个条件的前提下，统计不满足第二个条件的方案数，之和通过总方案数减去不符合条件2的方案数得到符合条件2的方案数。

在不满足条件2的前提下，第M大的数和第M+1大的数不同。假设第M大的数为x，那么序列中包含M个大于等于x的数，和N-M个小于x的数，并且前者中至少包含一个x。

记录$g(x,y)$表示满足第一个条件的前提下，M个数大于等于x，而另外M-N个数小于y的方案数。那么我们之前要统计的结果就是$g(x,x)-g(x+1,x)$。

现在考虑如何统计$g(x,y)$，对于前M个数，由于都大于等于x，因此，我们可以将它们提前减去x，同时r和l减去xM。而后面的N-M个数，要小于y，这个是不好统计的，我们可以用容斥反过来处理。

由于随着x的增大，实际上容斥的过程会不断缩短（因为不可能同时有$r/x$个条件被满足)，简单计算就可以得出最终的时间复杂度为$O(n\log_2n)$。

# 数字匹配问题（自创）

**题意**

假设有一个长度为nk的数字，其中包含n个1，n个2，...，n个k。我们将整个序列分裂为n个子序列，每个子序列需要同时包含1，2，...，k，且这k个数字按顺序出现。问有多少种分裂方案。

比如k为2，n为2，那么考虑这样一个序列1,1,2,2，就有两种分裂方案，第一个1和第一个2在一个子序列，或第一个1和第二个2在一个子序列。

**题解**

当k为2的时候，问题非常简单，从左到右扫描，找到2的时候，就向结果乘上之前出现的1的数目减去2的数目即可。

下面解决k>2的情况。如果在结果中某个$i$与某个$i+1$出现在同一个子序列中，称二者匹配。容易证明1与2的匹配关系与2与3的匹配关系是独立的，因此记$C_i$表示$i$与$i+1$的可能匹配方案数，那么我们最终结果就是
$$
\prod_{i=1}^{k-1}C_i
$$
。

在计算匹配的时候由于每个数字x只会贡献2两次（计算与x-1的匹配以及与x+1的匹配时），因此时间复杂度为$O(nk)$。

提供一个Atcoder的[题目](https://atcoder.jp/contests/sumitrust2019/tasks/sumitb2019_e)。

# LUOGU4827

**题意**

[https://www.luogu.org/problem/P4827](https://www.luogu.org/problem/P4827)

**题解**

神题。

对于点x，我们推一下它的指标：


$$
f(x)=\sum_{i=1}^ndist(x,i)^k
$$


带入第二类斯特林数公式：


$$
x^n = \sum_{k=0}^n
\begin{Bmatrix}
n\\
k
\end{Bmatrix}
x^{\underline{k}}
$$


得到：


$$
f(x)=\sum_{i=1}^n
\sum_{j=0}^k
\begin{Bmatrix}
k\\
j
\end{Bmatrix}
dist(x,i)^{\underline{j}}\\
=\sum_{i=1}^n
\sum_{j=0}^k
\begin{Bmatrix}
k\\
j
\end{Bmatrix}
{dist(x,i)\choose j}j!
\\
=\sum_{j=0}^k
\begin{Bmatrix}
k\\
j
\end{Bmatrix}
j!
\sum_{i=1}^n
{dist(x,i)\choose j}
$$


为了计算上式，我们记

$$
down(x,j)=\sum_{i\in T(x)}
{dist(x,i)\choose j}\\
up(x,j)=\sum_{i\notin T(x)}
{dist(x,i)\choose j}\\
$$


其中$T(x)$表示以x为根的子树中的所有顶点组成的集合。记$C(x)$表示x的所有直接的子结点。下面继续推导：


$$
down(x,j)=\sum_{i\in T(x)}{dist(x,i)\choose j}\\
=\sum_{i\in C(x)}\sum_{t\in T(i)}{dist(i,t)+1\choose j}\\
=\sum_{i\in C(x)}\sum_{t\in T(i)}{dist(i,t)\choose j}+{dist(i,t)\choose j-1}\\
=\sum_{i\in C(x)}down(i,j)+down(i,j-1)
$$


同理推导$up$，记录$fa(x)$表示x的父结点：


$$
up(x,j)=\sum_{i\in T(fa(x)) \land i\notin T(x)}{dist(fa(x),i)+1\choose j}+\sum_{i\notin T(fa(x))} {dist(fa(x),i)+1\choose j}\\
=\sum_{i\in T(fa(x)) \land i\notin T(x)}[{dist(fa(x),i)\choose j}+{dist(fa(x),i)\choose j-1}]\\+\sum_{i\notin T(fa(x))} [{dist(fa(x),i)\choose j}+{dist(fa(x),i)\choose j-1}]\\
=down(fa(x),j)+down(fa(x),j-1)-down(x,j)-2down(x,j-1)-down(x,j-2)\\+up(fa(x),j)+up(fa(x,j-1))
$$


之后我们用一般的树上DP就可以预处理$up$和$down$函数。而结果则是：


$$
f(x)=\sum_{j=0}^k
\begin{Bmatrix}
k\\
j
\end{Bmatrix}
j!
(up(x,j)+down(x,j))
$$

# Atcoder AtCoder Grand Contest 001E

**题意**

[https://atcoder.jp/contests/agc001/tasks/agc001_e](https://atcoder.jp/contests/agc001/tasks/agc001_e)

**题解**

神题。

考虑i和j，对结果的贡献为
$$
a_i+b_i+a_j+b_j\choose a_i+a_j
$$
。其在组合数学上的含义为从点
$$
(-a_i,-b_i)
$$
到
$$
(a_j,b_j)
$$
的路径数，每一步只能沿着x正轴或y正轴方向移动单位1。

我们将所有点绘制再4000\*4000的网格中，在这上面做DP就好了，最后统计需要去重。

# Atcoder code festival 2016 qualc E

**题意**

[https://atcoder.jp/contests/code-festival-2016-qualc/tasks/codefestival_2016_qualC_e](https://atcoder.jp/contests/code-festival-2016-qualc/tasks/codefestival_2016_qualC_e)

**题解**

设$P$表示所有$N$个元素的排列，而$P'$为指定了若干个元素后的排列集合。

那么要计算每个$P'$中元素的序号之和，等价于找到对于$P$中的每个元素，有多少个$P'$中元素大于等于它。


$$
\sum_{s\in P'}\sum_{t\in P}[s\geq t]\\
=\sum_{s\in P'}\sum_{t\in P}[s = t] + \sum_{s\in P'}\sum_{t\in P}[s > t]\\
=|P'|+\sum_{s\in P'}\sum_{t\in P}[s > t]
$$


注意到$s > t$，等价于存在下标$i$，满足对于任意$1\leq j < i$，都有$s_j = t_j$，且$s_i > t_i$。

因此我们枚举下标$i$，得出：


$$
\sum_{s\in P'}\sum_{t\in P}[s > t]\\
=\sum_{i=1}^n\sum_{s\in P'}\sum_{t\in P}[s_1=t_1\land s_2=t_2\land \ldots \land s_{i-1}=t_{i-1}\land s_i>t_i]\\
=\sum_{i=1}^n\sum_{s\in P'}(s_i-1-\sum_{j=1}^{i-1}[s_i>s_j])\cdot (n-i)!\\
=\sum_{i=1}^n(n-i)!\sum_{s\in P'}(s_i-1-\sum_{j=1}^{i-1}[s_i>s_j])\\
=\sum_{i=1}^n(n-i)!\sum_{s\in P'}(s_i-1)-\sum_{i=1}^n(n-i)!\sum_{s\in P'}\sum_{j=1}^{i-1}[s_i>s_j]
$$


上面这个式子可以利用BIT和一些枚举技巧就可以解决了，总的实际复杂度为$O(n\log_2n)$。



这个问题说明了一种计算在字典序上小于某个字符串的字符串数目的计算方法。


# Burnside定理

Burnside定理用于计算集合X的非等价着色数。

设$C$是$X$的着色集合，$G$是$X$的置换群，且$G$作用在$C$上，即$\forall f \in G,c\in C(f \ast c \in C)$。

定义函数$C(f)$:


$$
C(f)=\{c|c\in C, f\ast c = c\}
$$



记$N(G,C)$表示在$G$作用下，$C$中非等价的着色数目。

Burnside公式如下：


$$
N(G,C)=\frac{1}{|G|}\sum_{f\in G}|C(f)|
$$



## 例子1

举个简单的例子，将n个不同的对象放在一个环上，有多少种不同的放法。

如果一种方法可以通过另外一种方法通过旋转得到，就认为两种方法等价，比如n=3的情况下，(1,2,3)与(2,3,1)，(3,1,2)被认为是等价的方法。

容易发现$G=\{r^0,r^1,\ldots, r^{n-1}\}$，其中$r=(2,3,\ldots, n, 1)$。

由于每个对象都不同，因此一定有$C(r^1)=C(r^2)=\ldots = C(r^{n-1})=\emptyset$。而$C(r^0)$，由于所有着色方案在$r^0$下保持不变，因此$C(r^0)=C$。

带入到Burnside公式中，可以得到：


$$
N(G,C)=\frac{1}{|G|}\sum_{f\in G}|C(f)|=\frac{|C(r^0)|}{|G|}=\frac{n!}{n}=(n-1)!
$$


是不是很简单啊...

# Polya定理

一个置换可以分解为若干个循环节，比如$(2,1,3)$，它可以被分解为两个循环节$\[12\]\[3\]$。一个置换分解的循环节个数是固定的。

记$\#(f)$表示置换f分解后的循环节数目。

对于置换$f$，其分解的循环节，长度为$i$的有$e_i$个循环节，定义$type(f)=(e_1,e_2,\ldots, e_n)$。

由于$f$分解的循环节的总长度一定是$n$，因此满足



$$
1e_1+2e_2+\ldots + ne_n=n\\
\#(f)=e_1+e_2+\ldots+e_n
$$



引入$n$个变量$z_1,z_2,\ldots, z_n$，记$mon(f)=z_1^{e_1}z_2^{e_2}\ldots z_n^{e_n}$。

定义函数$P(G)$如下：


$$
P_G(z_1,z_2,\ldots,z_n)=\frac{1}{|G|}\sum_{f\in G}mon(f)
$$


Polya定理给出了下面命题：

假设有$k$种不同的颜色，有$N(G,C)=P_G(k,k,\ldots, k)$。

假设有$k$种不同的颜色，限制第i种颜色必须正好出现$p_i$次，我们引入$k$个新的变量$u_1,u_2,\ldots, u_k$代表$k$种颜色，我们可以保证$N(G,C)$的生成函数



$$
P_G(\sum_{i=1}^ku_i,\sum_{i=1}^ku_i^2,\ldots, \sum_{i=1}^ku_i^n)
$$



即$N(G,C)$是上式展开后项$u_1^{p_1}u_2^{p_2}\ldots u_k^{p_k}$的系数。

## 例子1

对于一个四边形，每个顶点都可以用k种颜色着色。问有多少种不等价的着色方案。

如果一个着色可以通过另外一种着色方案，通过旋转，则认为两个着色不等价。

首先G由下面元素组成：


$$
(1,2,3,4)=[1][2][3][4]\\
(2,3,4,1)=[1,2,3,4]\\
(3,4,1,2)=[1,3][2,4]\\
(4,1,2,3)=[1,4,3,2]\\
$$


利用Polya定理计算：


$$
P_G(k,k,k,k)=\frac{1}{|G|}\sum_{f\in G}mon(f)=\frac{1}{4}(k^4+k^1+k^2+k^1)
$$


设$k=2$带入可以得到$P_G(2,2,2,2)=6$。

# BZOJ1004

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1004](https://www.lydsy.com/JudgeOnline/problem.php?id=1004)

**题解**

题目中少了重要条件，m个置换加上不变置换能构成置换群。之后Polya定理解之。

# 非连续0问题

**形式1：对于一个包含k个1的二进制序列，如果没有任意两个0相邻，且第一个数一定是0，那么称该序列为良好的。问，对于所有长度为n的二进制序列，其中有多少是良好的。**

这个问题不是很难，我们可以直接用动态规划进行解决。但是除了动态规划，组合数学能提供一种更加简单快捷的解决方案。

这个问题实际上等价于，有两种子序列：
- 10
- 1

我们希望用k个上面子序列来，来组成一个长度为n-1的二进制序列。通过方程组可以简单地推出10序列出现的次数a和1出现的次数b。

$$
\left\{
\begin{array}{lll}
a+b & = & k\\
2a+b & = & n-1
\end{array}
\right.
$$

之后我们进行多重排列的计算就可以得出总的数目了，结果是$\frac{k!}{a!b!}$。

下面我们修改一下原来问题：

**形式2：对于一个包含k个1的二进制序列，如果没有任意两个0相邻，且第一个数一定是1，那么称该序列为良好的。问，对于所有长度为n的二进制序列，其中有多少是良好的。**

这个问题实际上比上一个问题还要简单，用同样的理论，只是方程组稍微变动一下：

$$
\left\{
\begin{array}{lll}
a+b & = & k\\
2a+b & = & n
\end{array}
\right.
$$

**形式3：对于一个包含k个1的二进制序列，如果没有任意两个0相邻，且第n个数一定是1（0），那么称该序列为良好的。问，对于所有长度为n的二进制序列，其中有多少是良好的。**

直接翻转一下二进制序列，计算完成后翻转回去即可。

**形式4：对于一个包含k个1的二进制序列，如果没有任意两个0相邻，且第1个数和第n个数一定是0，那么称该序列为良好的。问，对于所有长度为n的二进制序列，其中有多少是良好的。**

先考虑第一个数为0的所有良好序列，其中一部分的尾部是0，其余的则是1。为0表示10子串进行结尾的，因此修改方程组即可。

$$
\left\{
\begin{array}{lll}
a+b & = & k-1\\
2a+b & = & n-3
\end{array}
\right.
$$

# AGC040C

**题意**

[https://atcoder.jp/contests/agc040/tasks/agc040_c](https://atcoder.jp/contests/agc040/tasks/agc040_c)

**题解**

考虑一种放置方案，我们将所有奇数下标的A改成B、B改成A，那么现在不允许合并的就是AA和BB。

这样结果一下明显了起来，如果一种方案中A的数目或B的数目超过一半，那么一定不可消，否则一定可消。

因此问题实际上要我们统计的是有多少种方案，其中A不超过半数，B也不超过半数。

剩下的参考几类组合数加总的计算方式类型3即可。

# Atcoder Balanced Piles

**题意**

[https://atcoder.jp/contests/diverta2019-2/tasks/diverta2019_2_e](https://atcoder.jp/contests/diverta2019-2/tasks/diverta2019_2_e)

**题解**

记$f(i,j)$表示最大值为i时，且有j处堆积了i个方块的方案总数。

可以简单推出$f(i,j)=\sum_{t=1}^{d}\sum_{k=1}^nf(i-t,k)$。但是这里没有考虑相同数目方块之间的处理顺序，一种简单的技巧，就是我们重新定义$f(i,j)$，最大值为i时，且有j处堆积了i个方块，且我们已经确认了每个方块之间的处理顺序的方案总数。显然此时$f(0,n)$为$n!$。

修改了定义后，我们的递推公式也需要修改，新的递推公式为：$f(i,j)=j!\sum_{t=1}^{d}\sum_{k=1}^nf(i-t,k)$。

但是$O(n^2)$肯定过不去的，我们定义新的函数$g(i)$：最大值为i时，且我们已经确认了每个方块之间的处理顺序的方案总数。

这样新的递推公式即为$g(i)=\sum_{j=1}^nf(i,j)=\sum_{j=1}^nj!\sum_{t=1}^{d}\sum_{k=1}^nf(i-t,k)=(\sum_{j=1}^nj!)(\sum_{t=1}^{d}g(i-t))$。

上面的公式可以用前缀和线性处理。于是时间复杂度为$O(n)$。


# 统计选球方案

**问题1：有n个球，m种颜色。其中第i种颜色的球有$a_i$个。我们现在希望从所有球中挑选$k$个球，问有多少种选取方案。$n,m\leq 10^5$。**

考虑从n个球种挑选若干个球的方案。仅考虑颜色为$i$的球，其挑选方案的生成函数为$f_i(x)=x^{a_1}+x^{a_1-1}+\ldots+x^1+1$。当有m种球时，颜色的生成函数为$f(x)=\prod_{i=1}^mf_i(x)$。

我们可以用快速卷积+分治来计算，总的时间复杂度为$O(n\log_2m\log_2n)$。

**问题2：有m种颜色，每种颜色的球都有无数个，现在从中取出n个球（两种取法不同当且仅当存在某种颜色，该种颜色的球的数目在两种方案中不同），问有多少种取法。$n,m\leq 10^5$。**

记$x_i$表示取出的第$i$种颜色的球的数目，那么有$x_1+x_2+\ldots+x_m=n$且$x_i\geq 0$。取法的数目通过隔板法可以直接得出${m+n-1\choose n-1}$。

**问题3：有m种颜色，每种颜色的球都有无数个，现在从中取出n个球（两种取法不同当且仅当存在某种颜色，该种颜色的球的数目在两种方案中不同），问每种颜色的球都至少取出一个的前提下有多少种取法。**

记$x_i$表示取出的第$i$种颜色的球的数目，那么有$x_1+x_2+\ldots+x_m=n$且$x_i\geq 1$。取法的数目通过隔板法可以直接得出${m-n+n-1\choose n-1}$。

**问题4：有m种颜色，每种颜色的球都有无数个，现在从中取出n个球（两种取法不同当且仅当存在某种颜色，该种颜色的球的数目在两种方案中不同），问每种颜色的球取出数目不超过$k$的前提下有多少种取法。$n,m\leq 10^5$。**

这个可以用容斥进行解决。记录$A_i$表示第$i$种颜色出现不超过$k$次的所有方案的集合。那么结果为：

$$
|A_1\cap A_2\cap \ldots\cap A_n|=\sum_{i=0}^m(-1)^i{m-(k+1)i+n-1 \choose n-1}
$$

**问题5：有m种颜色，每种颜色的球有$R$个。现在从中取出n个球（两种取法不同当且仅当存在某种颜色，该种颜色的球的数目在两种方案中不同），要求每种颜色的球至少被取出$L$个，问有多少种取法。$n,m\leq 10^5$。**

首先我们可以消除左边界带来的影响，那么问题就变成了$x_1+\ldots +x_m=n$，且$x_i\leq R$。这个可以用容斥来处理。我们定义$C_i$表示所有满足$x_i>R$的方案组成的集合。那么问题的解就是：

$$
|\overline{C_1}\cap \overline{C_2}\cap \ldots \cap \overline{C_n}|\\
=\sum_{i=0}^m(-1)^i{m \choose i}{n-i(R+1)+m-1\choose m - 1}
$$

**问题6：有m种颜色，每种颜色的球都有无数个，现在从中依次取出n个球（两种取法当且仅当两种取法得到的颜色序列不同），问有多少种取法。$n,m\leq 10^5$。**

这个问题非常容易，每次取的时候有$m$种可能，因此结果为$m^n$。

**问题7：有m种颜色，每种颜色的球都有无数个，现在从中依次取出n个球（两种取法当且仅当两种取法得到的颜色序列不同），且要求每种颜色的球都至少被取出一个，问有多少种取法。$n,m\leq 10^5$。**

这个可以用容斥进行解决。记录$A_i$表示第$i$种颜色出现的所有方案的集合。那么结果为：

$$
|A_1\cap A_2\cap \ldots\cap A_n|=\sum_{i=0}^m(-1)^i{m \choose i}(m-i)^n
$$

**问题8：有m种颜色，每种颜色的球都有无数个，现在从中依次取出n个球（两种取法当且仅当两种取法得到的颜色序列不同），且要求第$i$种颜色的球出现的次数$x_i$满足$L_i\leq x_i\leq R_i$，问有多少种取法。$n,m\leq 500$,$L_i\leq R_i \leq 500$。**

用动态规划解决。记录$dp(i,j)$表示前$i$种颜色选择$j$个球的方案数。这里没有考虑到排列带来的影响，因此$dp(i-1,j)$对$dp(i,j+t)$的贡献应该为$dp(i-1,j){j+t\choose t}$。

这个问题还可以通过卷积来做，只是比较复杂一些。

# Codeforces 1251F

**题意**

[https://codeforces.com/problemset/problem/1251/F](https://codeforces.com/problemset/problem/1251/F)

**题解**

首先弄明白题目到底问的是个啥。

有$a+b$种不同颜色的球，其中$a$种颜色只有一个球，$b$种颜色各有两个球。现在有两个不同的袋子，我们希望往两个袋子中放入总共k个球。问对于所有$k\leq a+2b$，各有多少种不同的放法。

假如$b=0$，那么放法一定是${a \choose k}2^a$，即选出${a \choose k}$个球，之后将每个球放入一个袋子种。

假如$a=0$，那么放法一定是$f(k)=\sum_{i=0}^k{b\choose i}{b\choose k-i}$，即独立考虑装入两个袋子中的球。

我们可以通过枚举只有一个球的颜色加入数目来进行统计：

$$
g(k)=\sum_{i=0}^{k}2^i{a\choose i}f(k-i)
$$

可以发现$f$函数和$g$函数都是卷积的结果，因此它们的生成函数可以用卷积进行计算，因此总的时间复杂度为$O((a+b)\log_2(a+b))$。

# 容斥与动态规划

容斥与动态规划可以很好地结合，因为容斥真正重要的只有奇偶性，这意味着我们用动态规划来表示容斥的各种选择情况。

比如这道[问题](https://atcoder.jp/contests/arc101/tasks/arc101_c)，提供一颗树，将树上2n个顶点分为n类，每类两个顶点，要求对于任意一条边，存在一类顶点在边删除后属于不同的连通块。这个问题我们可以通过对边进行容斥来解决，在树上进行DP，定义$dp(u,i,k)$表示以u为根的子树正好i个顶点未分组，且不能被覆盖的边的数目模2的结果为k。这样我们就可以发现可以用DP来统计最终的结果。

还有一个类似的问题，需要利用到容斥的奇偶性结合DP解决的[问题](https://atcoder.jp/contests/dp/tasks/dp_y)。

# 统计所有和方案数问题

考虑有n个未知数$x_1,x_2,\ldots, x_n$，其中每个未知数$x_i$都可以取$0$到$10$之间的若干个数（不同未知数的可能的取值范围可能不同）。现在问，对于$\[0,10n\]$之间的任意数$t$，有多少种不同的未知数选择方案，可以使得所有未知数之和正好为$t$。

这个问题是一个很明显的用生成函数来求解的问题。对于第$i$个未知数$x_i$，我们建立一个多项式$f_i$，如果$x_i$可以取值$k$，那么我们就讲$f_i$的$x^k$项系数设置为1，否则设置为0。

可以发现$\prod_{i=1}^nf_i(x)$的$x^s$项系数表示的是有多少种不同方案，可以使得所有未知数之和为$s$。

# 拆分数方案

给定方程$\sum_{i=1}^ni\cdot x_i=m$，其中$x_i\geq 0$,$m\leq n$，问这个公式有多少种不同的赋值方案，记其为$h(m)$。

很容易想到一个暴力DP，记录$f(i,j)$表示仅考虑$1$到$i$，有多少方案可以使它们的和为$j$。可以得出$f(i,j)=f(i-1,j)+f(i,j-i)$。但是这种做法是$O(n^2)$的。

我们可以考虑分块，块的大小为$k$，我们记录$A(x)$表示用$1,2,\ldots, k-1$这些数组成$x$的方案数，而记录$B(x)$为用$k,\ldots, n$这些数组成$x$的方案数。

那么有$h(i)=\sum_{0\leq j\leq i}A(j)B(i-j)$。我们可以利用卷积得到$h(0),h(1),h(2),\ldots, h(n)$。

函数$A$，我们可以直接用暴力DP的方式进行计算。

对于函数$B$，我们记录$g(i,j)$表示$\sum_{t=k}^n x_t = i$的前提下使得$\sum_{t=k}^n t\cdot x_t=j$的方案数。可以分两种情况讨论，如果方案中下标最小的非0未知数的下标为$k$，那么此时方案数为$g(i-1,j-k)$，否则此时有$\sum_{t=k+1}^n t\cdot x_t=j\Rightarrow i+\sum_{t=k}^{n-1} t\cdot x_{t+1}=j$，即此时的方案数为$g(i,j-i)$。利用这两种情况，可以得出递推公式：$g(i,j)=g(i-1,j-k)+g(i,j-i)$。注意到$g$只有$(n-k+1)\cdot \frac{n}{k}=O(\frac{n^2}{k})$个有效状态。

整体的时间复杂度为$O(nk+\frac{n^2}{k}+n\log_2n)$，如果我们取$k=\sqrt{n}$，那么时间复杂度则为$O(n\sqrt{n}+n\log_2n)$。

# 错位排序的一些问题

**问题1：给定一个$1$到$n$的排列$P$，要求计算有多少排列$S$满足对于所有$1\leq i\leq n$有$P_i\neq S_i$。其中$1\leq n \leq 10^6$**

可以直接容斥解决。定义$A_i$表示满足$P_i=S_i$的所有排列$S$组成的集合。我们要求的是：$\|\overline{S_1}\cap \ldots \cap \overline{S_n}\|$。

注意到$S_i\cap S_j$表示的是所有已知$S_i=P_i,S_j=P_j$的排列，其大小应该为$(n-2)!$。

直接代入公式可以得出：$\sum_{i=0}^n {n\choose i}(-1)^i(n-i)!$，这就是要求的结果，提前预处理组合数，可以在$O(n)$时间复杂度内计算出结果。

**问题2：给定一个$1$到$n$的排列$P$，其中$P$的$k$个位置为空（表示这些位置不限制）。设$g(n,k)$表示有有多少排列$S$满足对于所有$1\leq i\leq n$有$P_i\neq S_i$，要求输出$g(0,0),g(1,0),g(1,1),\ldots,g(n,0),g(n,1),\ldots, g(n,n)$。其中$1\leq n \leq 3000$**

这个问题可以动态规划解决。定义$f(i,j)$表示还需要放置$i$个错排，之前还有$j$个元素未放入（对应还有$j$个空槽）。那么考虑转移公式有哪些贡献。

考虑处理第$i$个位置，以及其禁止放置的元素$P_i$，那么有四种情况：

1. $P_i$不会放入之前$j$个空槽中的任意一个，且之前的$j$个元素也不会放入第$i$个位置。
2. $P_i$会放入之前$j$个空槽中的任意一个，但是之前的$j$个元素也不会放入第$i$个位置。
3. $P_i$不会放入之前$j$个空槽中的任意一个，但是之前的$j$个元素中的一个会放入第$i$个位置。
4. $P_i$会放入之前$j$个空槽中的任意一个，且之前的$j$个元素中的一个会放入第$i$个位置。

于是可以推出转移公式为$f(i,j)=f(i-1,j+1)+2j\cdot f(i-1,j)+j^2\cdot f(i-1,j-1)$

接下来我们考虑怎么计算$g(i,j)$，容易发现当$j=0$时，直接有$g(i,0)=f(i,0)$。接下来我们考虑其它情形。我们可以这样思考，现在我们有$j$个位置没有约束，$i-j$个位置是存在约束的。我们可以将所有没有约束的位置按照位置的下标从小到大进行处理，因此如果$j>0$，那么我们可以选择最小下标的没有约束的位置，设置它的值，值可能是没有出现在$P$中的（对应的就是$j$种），也可能是出现在$P$中的（有$i-j$）种，后者会将一个有约束的位置转换为没有约束的。因此转移为$g(i,j)=j\cdot g(i,j-1) + (i-j)g(i-1,j)$，特殊的有$g(i,0)=f(i,0)$。

到此我们可以以$O(n^2)$的时间复杂度实现算法。

# 参考资料

- [斯特林数WIKI](https://zh.wikipedia.org/wiki/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0)
- [https://www.cnblogs.com/hchhch233/p/10016543.html](https://www.cnblogs.com/hchhch233/p/10016543.html)
- [https://blog.csdn.net/zhouyuheng2003/article/details/85055709](https://blog.csdn.net/zhouyuheng2003/article/details/85055709)
