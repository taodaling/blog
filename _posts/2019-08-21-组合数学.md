---
categories: math
layout: post
---

- Table
{:toc}
# Catalan数

## 理论

假设我们有n个1和m个-1，我们希望排列这n+m个数，并且要求排列$a_i$满足下面条件：

- 对于任意$0 \leq j \leq n+m$，都有$\sum_{i\leq j} a_i \geq -k$。

我们希望求出有多少种不同的排列满足条件。

首先如果$m > n+k$，那么有效排列数一定为0。下面仅考虑$m\leq n+k$的情况。

我们知道总共的排列数为$n+m \choose n$，因此只要减去不满足条件的排列数，就可以得到满足的排列数了。下面我们考虑怎么计算不满足条件的排列数。

对于某个不满足条件的排列$B=\[b_i\]$，一定能找到最小的下标$j$，使得$\sum_{i\leq j} a_i = -(k+1)$。我们将排列$B$的从第$j+1$个下标开始的值全部取相反值，即1改为-1，-1改为1。这样我们就得到了一个$m-1-k$个1和$n+1+k$个-1的排列。要还原，我们只需要找到最小的下标$j$，使得$\sum\_{i\leq j} a_i = -(k+1)$，将后面的元素取反就好了。这似乎暗示了$n$个1和$m$个-1的无效排列与$m-1-k$个1和$n+1+k$个-1的排列之间存在类似双射的关系。首先很明显从前者到后者一定是单射，即不同的输入对应不同的输出，同时由于$m-1-k$个1和$n+1+k$个-1的排列中必定能找到这样的$j$，使得前j个数的和为-(k+1)，因此映射是满射。

满射意味着$n$个1和$m$个-1的无效排列与$m-1-k$个1和$n+1+k$个-1的排列数目相同，即总有效排列数为：


$$
{n+m\choose n} -{n + m \choose n + 1 + k}
$$




## 例子1

Catalan数最简单的例子就是n个左括号和n个右括号能构成多少有效的括号序列了。



首先一个括号序列有效，当且仅当排列中所有前缀部分中，左括号数不少于右括号数。如果我们将左括号视作1，右括号视为-1，取$k=0$，那么就转换为Catalan数问题了。有效数为



$$
{2n\choose n} -{2n \choose n + 1}
$$



# 分配问题

对于n个非负变量$x_1,x_2,\ldots,x_n$，问满足下面等式的分配方案有多少种：


$$
x_1+x_2+\ldots+x_n=m
$$


这等价于m个小球，我们向其中插入$n-1$个挡板，将其切分为n部分的方案数，因此我们可以直接得出方案数为：
$$
{m+n-1 \choose n-1}
$$
。



现在考虑满足下面不等式的分配方案有多少种：


$$
L\leq x_1+x_2+\ldots+x_n\leq R
$$


我们现在进行推导：


$$
\sum_{i=L}^R{i+n-1\choose i}\\
=\sum_{i=L}^R{i+n-1\choose i}+{L+n-1\choose L-1}-{L+n-1\choose L-1}\\
=\sum_{i=L+1}^R{i+n-1\choose i}+{L+n-1\choose L}+{L+n-1\choose L-1}-{L+n-1\choose L-1}\\
=\sum_{i=L+1}^R{i+n-1\choose i}+{L+n\choose L}-{L+n-1\choose L-1}\\
\ldots\\
={R+n\choose R}-{L+n-1\choose L-1}
$$


现在考虑一个更简单的不等式的分配方案：


$$
x_1+x_2+\ldots+x_n\leq m
$$


进行推导：


$$
\sum_{i=0}^m{i+n-1\choose i}\\
=\sum_{i=1}^m{i+n-1\choose i}+1\\
={m+n\choose m}-{n\choose 0}+1\\
={m+n\choose m}
$$


其实这个问题也等价于下面等式成立的前提下，前n个变量有多少种分配方案。


$$
x_1+x_2+\ldots+x_n+x_{n+1}=m
$$

由于前n个变量唯一决定变量$x_{n+1}$，因此等于等式的总分配数。



# 容斥原理

假设有全集$S$，以及全集的若干子集$A_1,A_2,\ldots, A_k$。

在实际应用中要统计多个子集的交集的大小是比较容易的，但是要统计多个子集的并集的大小则比较困难。对于这种情况，我们可以使用容斥原理将并运算简化为若干次交运算。

容斥原理的公式如下：


$$
|A_1\cup A_2 \cup \ldots \cup A_k|\\
=\sum_i|A_i|-\sum_{i,j|i\neq j}|A_i\cap A_j|+\ldots+(-1)^{k+1}\sum_{i_1,i_2,\ldots,i_k|i_1\neq i_2\neq\ldots \neq i_k}|A_{i_1}\cap A_{i_2}\cap\ldots\cap A_{i_k}|
$$

$$
|\overline{A_1\cup A_2 \cup \ldots \cup A_k}|\\
=|S|-|A_1\cup A_2 \cup \ldots \cup A_k|\\
=|S|-\sum_i|A_i|+\sum_{i,j|i\neq j}|A_i\cap A_j|+\ldots+(-1)^{k}\sum_{i_1,i_2,\ldots,i_k|i_1\neq i_2\neq\ldots \neq i_k}|A_{i_1}\cap A_{i_2}\cap\ldots\cap A_{i_k}|
$$


## 例子1

统计1~100中能被2,3同时整除的数的数目。

记$S=\{1,2,\ldots, 100\}$，记$A_i$表示$S$中所有能被i整除的数的集合。那么我们要求的实际上就是：


$$
|A_2 \cup A_3|=|A_2|+|A_3|-|A_2\cap A_3|\\
=\lfloor 100 /2 \rfloor+\lfloor 100 / 3 \rfloor - \lfloor 100 / 6 \rfloor
=50+33-16=67
$$



# 第一类斯特林数

第一类斯特林数
$$
s(n,k)
$$
定义为下面公式的系数：


$$
x^{\underline{n}}=\sum_{k=0}^n
s(n,k)
x^k
$$


定义无符号斯特林数为：


$$
c(n,k)=
\left[
\begin{array}{c}
n\\
k
\end{array}
\right]
=|s(n,k)|
$$


可以利用下面公式通过无符号斯特林数计算有符号斯特林数：


$$
s(n,k)=(-1)^{n-k}c(n,k)
$$


无符号斯特林数满足：


$$
x^{\overline{n}}=\sum_{k=0}^n
c(n,k)
x^k
$$


无符号斯特林数的递推关系为：


$$
\left[
\begin{array}{c}
n+1\\
k
\end{array}
\right]
=
n
\left[
\begin{array}{c}
n\\
k
\end{array}
\right]
+
\left[
\begin{array}{c}
n\\
k-1
\end{array}
\right]
$$


有符号斯特林数的递推公式为：


$$
s(n+1,k)=-ns(n,k)+s(n,k-1)
$$


无符号斯特林数的组合意义是：将$n$个元素分成$k$个环（都不空）的方案数为
$$
\left[
\begin{array}{c}
n\\
k
\end{array}
\right]
$$


## 生成函数

对于给定的n，设$F^{(n)}$为第一类斯特林数的生成函数，即
$$
F^{(n)}_i=
\left[
\begin{array}{c}
n\\
i
\end{array}
\right]
$$
。由于无符号斯特林数满足：



$$
x^{\overline{n}}=\sum_{k=0}^n
c(n,k)
x^k
$$


因此可以直接得到：


$$
F^{(n)}(x)=x^{\overline{n}}=\prod_{i=0}^{n-1}(x+i)
$$


乘积符号内是n个多项式，我们可以用分治+FFT在$O(n(\log_2n)^2)$时间复杂度内计算得到。下面介绍用倍增+FFT在$O(n\log_2n)$的算法。

容易发现下面公式成立：



$$
F^{(n)}(x)=
\left\{
\begin{array}{ll}
F^{(\frac{n}{2})}(x)F^{(\frac{n}{2})}(x+\frac{n}{2})&, 2|n\\
(x+n-1)F^{n-1}(x)&,else
\end{array}
\right.
$$


我们可以用倍增算法来解决。下面给出计算$F^{(n)}(x+n)$的方法：

$$
F^{(n)}(x+n)\\
=\sum_{i=0}^nF^{(n)}_i(x+n)^i\\
=\sum_{i=0}^nx^i\sum_{j=i}^nF^{(n)}_jn^{j-i}{j\choose i}\\
=\sum_{i=0}^nx^i\sum_{j=i}^nF^{(n)}_jn^{j-i}\frac{j!}{i!(j-i)!}\\
=\sum_{i=0}^n\frac{1}{i!}x^i\sum_{j=i}^n[F^{(n)}_jj!][\frac{n^{j-i}}{(j-i)!}]\\
$$


可以看出后面项是等差卷积，可以用FFT直接得到。

总的时间复杂度为

$$
T(n)=T(\frac{n}{2})+O(n\log_2n)=O(n\log_2n)
$$


# 第二类斯特林数

第二类斯特林数
$$
\begin{Bmatrix}
n\\
k
\end{Bmatrix}
$$
的定义为下面公式的系数：


$$
x^n = \sum_{k=0}^n
\begin{Bmatrix}
n\\
k
\end{Bmatrix}
x^{\underline{k}}
$$


第二类斯特林数的递推公式为：


$$
\begin{Bmatrix}
n+1\\
k
\end{Bmatrix}
=
k \begin{Bmatrix}
n\\
k
\end{Bmatrix}
+
\begin{Bmatrix}
n\\
k-1
\end{Bmatrix}
$$


第二类斯特林数的直接计算公式为：


$$
\begin{Bmatrix}
n\\
k
\end{Bmatrix}
=
\frac{1}{k!}\sum_{i=0}^k(-1)^i{k\choose i}(k-i)^n
$$


第二类斯特林数
$$
\begin{Bmatrix}
n\\
k
\end{Bmatrix}
$$
的可以用来表示将n个元素拆分成k个非空子集的方法数。



## 生成函数

对于某个n，以及所有$0\leq k \leq n$计算
$$
\begin{Bmatrix}
n\\
k
\end{Bmatrix}
$$
，可以利用快速卷积在
$$
O(n\log_2n)
$$
的时间复杂度内实现。

观察下面第二类斯特林数的直接计算公式：


$$
\begin{Bmatrix}
n\\
k
\end{Bmatrix}
=
\frac{1}{k!}\sum_{i=0}^k(-1)^i{k\choose i}(k-i)^n\\
=\sum_{i=0}^k(-1)^i(k-i)^n\frac{1}{i!(k-i)!}\\
=\sum_{i=0}^k[(-1)^i\frac{1}{i!}][(k-i)^n\frac{1}{(k-i)!}]
$$


记第二类斯特林数的生成函数为$F$，
$$
F_k=\begin{Bmatrix}n\\k\end{Bmatrix}
$$
那么我们可以推出$F$是另外两个多项式的卷积：


$$
F(x)=[\sum_{i=0}^n(-1)^i\frac{1}{i!}] \times [\sum_{i=0}^ni^n\frac{1}{i!}]
$$


因此利用快速卷积算法就可以得到第二类斯特林数的生成函数。

# 斯特林反演

反演内容：


$$
f(n)=\sum_{k=0}^n
\begin{Bmatrix}n\\k\end{Bmatrix}
g(k)
\Leftrightarrow 
g(n)=
\sum_{k=0}^n
s(n,k)f(k)
=
\sum_{k=0}^n
(-1)^{n-k}
\left[
\begin{array}{c}
n\\
k
\end{array}
\right]
f(k)
$$


以及反转公式：


$$
\sum_{k=m}^n (-1)^{n-k}\begin{bmatrix}n\\k\end{bmatrix} \begin{Bmatrix}k\\m\end{Bmatrix}=[m=n]\\
\sum_{k=m}^n (-1)^{n-k}\begin{Bmatrix}n\\k\end{Bmatrix} \begin{bmatrix}k\\m\end{bmatrix}=[m=n]
$$



# 最值反演(min-max容斥)

$$
\max\{S\}=\sum_{T\subseteq S}(-1)^{|T|+1}\min\{T\}\\
\min\{S\}=\sum_{T\subseteq S}(-1)^{|T|+1}\max\{T\}
$$



证明：

考虑第一个公式。假设x为S中的第i+1大元素。那么x的展开项系数为：


$$
\sum_{j=0}^i(-1)^j{i\choose j}=(1-1)^i=0^i
$$


因此只有当i为0时，系数为1，其它情况都为0。第二个公式同理可证。

# Codeforces1204E

**题意**

[https://codeforces.com/contest/1204/problem/E](https://codeforces.com/contest/1204/problem/E)

**题解**

枚举可能的f取值，0~n，之后用Catalan数统计g(i)，其中g(i)表示f取值小于等于i的序列数。之后求解。时间复杂度为$O(n+m)$。



# Codeforces449D

**题意**

[https://codeforces.com/problemset/problem/449/D](https://codeforces.com/problemset/problem/449/D)

**题解**

要统计有多少个序列且运算和为0，可以通过统计有多少序列且运算和非0得到。而要统计后者，容易观察一个序列且运算非0，则至少存在一个二进制位，序列中所有元素在这个二进制位处值都是1。

记$A_i$表示所有且运算结果中第i个二进制位为1的所有序列组成的集合。那么我们实际上要统计的就是$\|A_0\cup A_1\cup \ldots \cup A_k \|$，这里k取20。这可以利用容斥得到。

下面我们说明如何快速计算上面提到的若干个元素的交集大小。首先我们先统计每个数在序列中出现的次数，记作$f(x)$。之后统计$g(x)$，表示所有x的超集y（y&x=x）出现的次数，这可以利用快速沃什尔变换得到。

最后比如要统计$\|A_0\cap A_1\|$，即有多少序列的且运算结果是3的超集，首先我们容易得知序列中的所有元素都来自3的超集，而3的超集的大小为$g(x)$，每个数都有出现和不出现两种情况，因此总的序列数为$2^{g(x)}-1$，这里减去1是因为序列的长度不能为0。

# BZOJ5093

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=5093](https://www.lydsy.com/JudgeOnline/problem.php?id=5093)

**题解**

先推出公式，记$f(n,k)$为我们要求的：


$$
f(n,k)=\sum_{E}\sum_{i=0}^n(\sum_{(i,j)\in E}1)^k\\
=\sum_{i=0}^n\sum_{E}(\sum_{(i,j)\in E}1)^k\\
=\sum_{i}^n\sum_{j=0}^{n-1}j^k{n-1\choose j}2^{n\choose 2}\\
=n2^{n\choose 2}\sum_{j=0}^{n-1}j^k{n-1\choose j}
$$


接下来我们计算


$$
\sum_{j=0}^{n-1}j^k{n-1\choose j}
$$


套入第二类斯特林数定义：


$$
x^n = \sum_{k=0}^n
\begin{Bmatrix}
n\\
k
\end{Bmatrix}
x^{\underline{k}}
$$


得到：


$$
\sum_{j=0}^{n-1}j^k{n-1\choose j}\\
=\sum_{j=0}^{n-1}{n-1\choose j}\sum_{i=0}^k
\begin{Bmatrix}
k\\
i
\end{Bmatrix}
j^{\underline{i}}\\
=\sum_{j=0}^{n-1}{n-1\choose j}\sum_{i=0}^k
\begin{Bmatrix}
k\\
i
\end{Bmatrix}
{j\choose i}i!\\
=\sum_{i=0}^k 
\begin{Bmatrix}
k\\
i
\end{Bmatrix}
i!
\sum_{j=0}^{n-1}{n-1\choose j}{j\choose i}
$$


考虑形如
$$
g(n,i)=\sum_{j=0}^n{n\choose j}{j\choose i}
$$
的组合数的意义，其等价于从n个标记为0的石头中取任意块，之后标记为1，之后从取出的j块石头中再取i块，标记为2。问有多少种标记法。我们可以提前从n块石头取出i块石头标记2，之后其余n-i块石头可以标0或标1。因此总共取法为
$$
{n\choose i}2^{n-i}
$$


代入简化公式得到：


$$
\sum_{j=0}^{n-1}j^k{n-1\choose j}\\
=\sum_{i=0}^k 
\begin{Bmatrix}
k\\
i
\end{Bmatrix}
i!
{n-1\choose i}2^{n-1-i}
$$


其中斯特林数可以通过快速卷积得到。总的时间复杂度为$O(k\log_2k)$。

# Codeforces960G

**题意**

[https://codeforces.com/contest/960/problem/G](https://codeforces.com/contest/960/problem/G)

**题解**

由于无论从左边开始还是右边开始，最后拿的一定是最大值。因此最大值将序列分为了左右两边。称一个数为局部最大，当且仅当这个数之前没有比它大的数。那么我们实际上从左边能拿到a个数，就意味着最大值坐标，共有a-1个局部最大值。同理最大值右边有b-1个局部最大值。

定义函数$f(i,j)$表示拥有j个局部最大值的长度为i的排列数目。那么我们要求的实际上就是：


$$
g(n,a,b)=\sum_{i=0}^{n-1}{n - 1\choose i}f(i,a-1)f(n-1-i,b-1)
$$


考虑如何放置排列中的最小值，容易发现$f$满足下面递推性质：


$$
f(i,j)=f(i-1,j-1)+(i-1)f(i-1,j)
$$


这个递推式与第一类stirling数是相同的，同时在边界情况与第一类stirling数拥有相同值，因此可以认为：
$$
f(i,j)=c(i,j)
$$


第一类stirling数表示的是将i个数分成j个环的策略数。利用这个性质我们可以简化要求的结果：


$$
g(n,a,b)=c(n-1,a+b-2){a+b-2\choose a-1}
$$


stirling数可以通过快速卷积得到。总的时间复杂度为$O(n\log_2n)$。

# Atcoder jsc2019_qual_f

**题意**

[https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_f](https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_f)

**题解**

毒瘤题。假设满足第一个条件的数目为$f(n,L,R)$，利用组合数学可以直接得到：


$$
f(n,L,R)={n+R\choose R}-{n+L-1\choose L-1}
$$


接下来考虑第二个条件，很讨厌的条件。会导致重复统计的问题。现在我们可以考虑在满足第一个条件的前提下，统计不满足第二个条件的方案数，之和通过总方案数减去不符合条件2的方案数得到符合条件2的方案数。

在不满足条件2的前提下，第M大的数和第M+1大的数不同。假设第M大的数为x，那么序列中包含M个大于等于x的数，和N-M个小于x的数，并且前者中至少包含一个x。

记录$g(x,y)$表示满足第一个条件的前提下，M个数大于等于x，而另外M-N个数小于y的方案数。那么我们之前要统计的结果就是$g(x,x)-g(x+1,x)$。

现在考虑如何统计$g(x,y)$，对于前M个数，由于都大于等于x，因此，我们可以将它们提前减去x，同时r和l减去xM。而后面的N-M个数，要小于y，这个是不好统计的，我们可以用容斥反过来处理。

由于随着x的增大，实际上容斥的过程会不断缩短（因为不可能同时有$r/x$个条件被满足)，简单计算就可以得出最终的时间复杂度为$O(n\log_2n)$。

# 数字匹配问题（自创）

**题意**

假设有一个长度为nk的数字，其中包含n个1，n个2，...，n个k。我们将整个序列分裂为n个子序列，每个子序列需要同时包含1，2，...，k，且这k个数字按顺序出现。问有多少种分裂方案。

比如k为2，n为2，那么考虑这样一个序列1,1,2,2，就有两种分裂方案，第一个1和第一个2在一个子序列，或第一个1和第二个2在一个子序列。

**题解**

当k为2的时候，问题非常简单，从左到右扫描，找到2的时候，就向结果乘上之前出现的1的数目减去2的数目即可。

下面解决k>2的情况。如果在结果中某个$i$与某个$i+1$出现在同一个子序列中，称二者匹配。容易证明1与2的匹配关系与2与3的匹配关系是独立的，因此记$C_i$表示$i$与$i+1$的可能匹配方案数，那么我们最终结果就是
$$
\prod_{i=1}^{k-1}C_i
$$
。

在计算匹配的时候由于每个数字x只会贡献2两次（计算与x-1的匹配以及与x+1的匹配时），因此时间复杂度为$O(nk)$。

# LUOGU4827

**题意**

[https://www.luogu.org/problem/P4827](https://www.luogu.org/problem/P4827)

**题解**

神题。

对于点x，我们推一下它的指标：


$$
f(x)=\sum_{i=1}^ndist(x,i)^k
$$


带入第二类斯特林数公式：


$$
x^n = \sum_{k=0}^n
\begin{Bmatrix}
n\\
k
\end{Bmatrix}
x^{\underline{k}}
$$


得到：


$$
f(x)=\sum_{i=1}^n
\sum_{j=0}^k
\begin{Bmatrix}
k\\
j
\end{Bmatrix}
dist(x,i)^{\underline{j}}\\
=\sum_{i=1}^n
\sum_{j=0}^k
\begin{Bmatrix}
k\\
j
\end{Bmatrix}
{dist(x,i)\choose j}j!
\\
=\sum_{j=0}^k
\begin{Bmatrix}
k\\
j
\end{Bmatrix}
j!
\sum_{i=1}^n
{dist(x,i)\choose j}
$$


为了计算上式，我们记

$$
down(x,j)=\sum_{i\in T(x)}
{dist(x,i)\choose j}\\
up(x,j)=\sum_{i\notin T(x)}
{dist(x,i)\choose j}\\
$$


其中$T(x)$表示以x为根的子树中的所有顶点组成的集合。记$C(x)$表示x的所有直接的子结点。下面继续推导：


$$
down(x,j)=\sum_{i\in T(x)}{dist(x,i)\choose j}\\
=\sum_{i\in C(x)}\sum_{t\in T(i)}{dist(i,t)+1\choose j}\\
=\sum_{i\in C(x)}\sum_{t\in T(i)}{dist(i,t)\choose j}+{dist(i,t)\choose j-1}\\
=\sum_{i\in C(x)}down(i,j)+down(i,j-1)
$$


同理推导$up$，记录$fa(x)$表示x的父结点：


$$
up(x,j)=\sum_{i\in T(fa(x)) \land i\notin T(x)}{dist(fa(x),i)+1\choose j}+\sum_{i\notin T(fa(x))} {dist(fa(x),i)+1\choose j}\\
=\sum_{i\in T(fa(x)) \land i\notin T(x)}[{dist(fa(x),i)\choose j}+{dist(fa(x),i)\choose j-1}]\\+\sum_{i\notin T(fa(x))} [{dist(fa(x),i)\choose j}+{dist(fa(x),i)\choose j-1}]\\
=down(fa(x),j)+down(fa(x),j-1)-down(x,j)-2down(x,j-1)-down(x,j-2)\\+up(fa(x),j)+up(fa(x,j-1))
$$


之后我们用一般的树上DP就可以预处理$up$和$down$函数。而结果则是：


$$
f(x)=\sum_{j=0}^k
\begin{Bmatrix}
k\\
j
\end{Bmatrix}
j!
(up(x,j)+down(x,j))
$$

# Atcoder AtCoder Grand Contest 001E

**题意**

[https://atcoder.jp/contests/agc001/tasks/agc001_e](https://atcoder.jp/contests/agc001/tasks/agc001_e)

**题解**

神题。

考虑i和j，对结果的贡献为
$$
a_i+b_i+a_j+b_j\choose a_i+a_j
$$
。其在组合数学上的含义为从点
$$
(-a_i,-b_i)
$$
到
$$
(a_j,b_j)
$$
的路径数，每一步只能沿着x正轴或y正轴方向移动单位1。

我们将所有点绘制再4000\*4000的网格中，在这上面做DP就好了，最后统计需要去重。



# 参考资料

- [斯特林数WIKI](https://zh.wikipedia.org/wiki/%E6%96%AF%E7%89%B9%E6%9E%97%E6%95%B0)
- [https://www.cnblogs.com/hchhch233/p/10016543.html](https://www.cnblogs.com/hchhch233/p/10016543.html)
- [https://blog.csdn.net/zhouyuheng2003/article/details/85055709](https://blog.csdn.net/zhouyuheng2003/article/details/85055709)