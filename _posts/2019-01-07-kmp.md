---
categories: algorithm
layout: post
---

- Table
{:toc}
# KMP

> 在计算机科学中，**Knuth-Morris-Pratt字符串查找算法**（简称为**KMP算法**）可在一个**主文本字符串**`S`内查找一个**词**`W`的出现位置。此算法通过运用对这个词在不匹配时本身就包含足够的信息来确定下一个匹配将在哪里开始的发现，从而避免重新检查先前匹配的字符。
>
> 这个算法是由高德纳和沃恩·普拉特在1974年构思，同年詹姆斯·H·莫里斯也独立地设计出该算法，最终由三人于1977年联合发表。

## 最大有效重复度的计算

**对于字符串P，如果对于数0<=k<\|P\|，若长度为k的P的前缀和长度为k的P的后缀匹配，则称k是P的有效重复度，否则称k是P的无效重复度。**

比如对于"aba"，0是它的有效重复度（""与""匹配），1是它的有效重复度（"a"与"a"匹配），2则不是("ab"与"ba"不匹配)。

**很显然对于一个字符串，它可以有多个有效重复度k1,k2,...，我们将其中最大的值称为P的最大有效重复度，记作L(P)。**

因此L("aba")=1, L("aaa")=2。

**对于字符串S，我们记它的长度为k的前缀为S[k..]，而它的长度为k的后缀为S[..k]。记S[k]表示它的从前往后第k个字符。**

比如"abc"[2..]="ab", "abc"[..2]="bc"。

那么现在对于所有的1<=k<=\|P\|，我们希望能快速得到L(S[k..])。当然最好的方式是预先计算并缓存起来。但是计算缓存又需要花费多少时间呢？

很显然对于任意长度为n的字符串S，要计算L(S)，只需要从大到小枚举所有可能的最大有效重复度即可，其时间复杂度最优是O(n)，最坏时为O(n^2)。按照这样来算，要计算所有的S的前缀的最大有效重复度，其时间复杂度在最坏情况下将达到O(n^3)。

让我们仔细观察L(S[k..])与L(S[k+1..])之间的关系。

```
命题1：如果S[L(S[k..]) + 1]=S[k+1]，那么L(S[k..])+1是S[k+1..]的有效重复度。
```

```
命题2：max(L(S[k+1..])-1, 0)一定是S[k..]的有效重复度。
```

从上面的命题，我们可以得到当S[L(S[k..]) + 1]=S[k+1]，此时L(S[k..])+1是S[k+1..]的最大有效重复度，即L(S[k+1..])=L(S[k..])+1。

```
命题3：若S[L(S[k..]) + 1]=S[k+1]，则L(S[k+1..])=L(S[k..])+1。
```

那么如果S[L(S[k..]) + 1]不等于S[k+1]呢，情况又是如何。

我们再观察一个有趣的事实。我们记L(S)=Fst，对于任意小于L(S)的S的有效重复度Scd，有S[Scd..]=S[..Scd]，且由于S[Fst..]=S[..Fst]，可以推出S[Scd..]=S[..Scd]=S\[..Fst\]\[..Scd\]=S\[Fst..]\[..Scd]，且Scd<Fst，因此Scd一定是S[Fst..]的有效重复度。因此我们得出下面命题：

```
命题4：对于所有小于L(S)的S的有效重复度，它同样也是S[L(S)..]的有效重复度。
```

而若k是S[Fst..]的有效重复度，那么由于S[k..]=S\[Fst..\]\[..k]=S\[..Fst\]\[..k\]=S[..k]，因此k也是S的有效重复度。故S[Scd..]的所有有效重复度一定是S的有效重复度。给出下面命题：

```
命题5：S[L(S)..]的所有有效重复度一定也是S的有效重复度。
```

因此我们可以形成一个序列，记作A[0]，A[1]，...，其中A[0]=S[k..]，A[i+1]=S[L(A[i])..]，它们的最大重复度的并集{L(A[0]),L(A[1]),...}正好是S[k..]的所有有效重复度。而由命题2知，L(S[k+1..])或者为0，或者其是通过S[k..]的某个有效重复度加一后得到的，而此时L(S[k+1..])应为L(A[i])+1，且S[k+1]=S[L(A[i])+1]。

上面我们已经论证了两种情况下通过L(S[k..])计算L(S[k+1..])的方式，综合上面的论证，我们可以设计出算法计算所有S的前缀的最大有效重复度。

```java
maxValidRepetationOf(S):
	L[1] = 0;
	for(i = 2; i <= \|S\|; i = i + 1):
        j = L[i - 1];
		for(; j > 0 && S[i] != S[j + 1]; j = L[j]);
		if(S[j + 1] == S[i]):
			L[i] = j + 1;
		else:
			L[i] = 0;
	return L;
```

上面这段代码的时间复杂度是O(n)，n是S的长度，下面证明：

我们记D(S)表示S的不同有效重复度的数目。而扫描L[i]成功后的势能定义为D(S[i..])。观察嵌套的第二层for循环代码，其实际在按序扫描A[0],A[1],...，若我们在A[k]处停止，此时摊还费用为：1+k+D(S[i+1..])-D(S[i..])=1+k+D(S[i..])-k-D(S[i..])=1。

1+摊还总费用=实际总费用+D(S)-D(S[1..])
=>
实际总费用=1+摊还总费用-D(S)+0<=1+摊还总费用=O(n)

因此总的时间复杂度为O(n)。

## KMP算法

假设我们希望在S中查找所有P出现的起始坐标，其中S的长度为n，P的长度为m。

我们首先按照之前的算法以O(m)的时间复杂度计算出P的所有最大有效重复度L。之后令P与S开始匹配。

**定义F(A,B)表示A与B的最长公共前缀的长度**。

比如F("abc","aba")为2，因为他们的最长公共前缀为"ab"。

那么现在我们再回头来看我们的问题，要求出所有P在S中出现的起始下标。那么如果对于任意k满足0<k<=\|S\|，我们都能计算出F(S[..k],P)，那么我们只需要扫描一遍所有取值，并过滤出其中值为m的部分，就可以得到所有的起始下标。

很显然我们可以通过O(m)的时间复杂度计算F(S[..1],P),F(S[..2],P),...中的任一，因此总的时间复杂度可以控制在O(nm)。但是这并不是我们希望的答案，下面我将阐述如何利用之前计算出的所有P的最大重复度，跳过对S的一部分后缀计算与P的最长公共前缀的过程。

假如我们计算得到F(S,P)，简单记作x，那么诸如F(S[..m-1],P)，F(S[..m-2],P)，...，F(S[..m-(x-L[x]-1)],P)都不可能达到m值。不妨假设其中某一者F(S[..m-t],P)值为m，那么由于t<x-L[x]，则x-t>L[x]。由于S[..m-t]与P的公共前缀长度为m，而S与P的公共前缀长度为x，所以S[x-t..]=P[x-t..]=S\[..m-t\][x-t..]=S\[x..\][..x-t]，因此x-t也是P[x..]的一个有效重复度，而x-t>L[x]，很显然这与最大有效重复度的定义是相悖的，因此假设不成立。

```
命题6：对于字符串S，P，若F(S,P)=x，则诸如F(S[..m-1],P)，F(S[..m-2],P)，...，F(S[..m-(x-L[x]-1)],P)都不可能达到m值
```

这样我们就可以跳过一部分的S的后缀与P的最长公共前缀的计算。下面看我们的成果：

```java
kmp(S, P):
	L = maxValidRepetationOf(P);
	left = 1;
	right = 1;
	while(right <= \|S\|):
		if(S[right] != P[right - left + 1]):
			if(right == left):
				left = right = left + 1;
			else:
				left = right - L[right - left];
		else:
			right = right + 1;
			if(right - left == \|P\|):
                consume(left);
				left = right - L[right - left];
```

观察上面代码，每次循环，或者left增加或者right增加，而left始终小于等于right，而right小于等于n，因此总的时间复杂度上限为O(n)，加上去计算L的时间复杂度，时间复杂度应该为O(n+m)。