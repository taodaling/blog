---
categories: problem
layout: post
---

- Table
{:toc}

# Codeforces 1033E

**题意**

[https://codeforces.com/contest/1033/problem/E](https://codeforces.com/contest/1033/problem/E)

**题解**

我们可以尝试找出一株生成树，我们从前到后处理所有顶点，并且维护处理过的顶点形成边数最多的生成树。这样当新加入一个顶点的时候，我们可以二分查找，找到所有与新顶点存在边的连通块，之后对连通块进行二分查找，找到连通块中与新顶点之间恰好存在边的顶点，加入边即可。由于每次合并两个连通块都对应的会有$O(\log_2n)$次查询，因此最多的查询数目为$O(n\log_2n)$，这里常数不超过2，因此在$n=600$的时候总的请求数也不会超过$12000$。

最后我们找到了生成树就很容易判断是否有奇长环了，将树上顶点进行二分染色，之后观察同色顶点之间是否有边存在，如果有就存在了奇环。我们可以将该色的顶点压成一个序列，然后比遍历序列，直到找到某个特殊的点，这个点后面的所有顶点之间没有边，我们记这个顶为first，之后找到first后第一个顶点second，使得second与first之间有边，这里总共最多为$2n$次查询。要找到奇环，可以以first为根，搜索到second的唯一路径即可。

题目的核心是想到这题目所要求的输出，不需要你得到所有边，只需要一株生成树即可。

# Codeforces 1028G

**题意**

[https://codeforces.com/contest/1028/problem/G](https://codeforces.com/contest/1028/problem/G)

**题解**

定义$dp(l,q)$表示最大的$r-l+1$，满足在知道$x$落在$\[l,r\]$的前提下能够在$q$次请求内找到$x$。

那么可以很容易推出转移公式，同时利用$dp$也可以快速找到那些分隔点。

这个问题中由于每个请求中的值不能超过$x$，因此不可以直接均匀切分，这也是为什么要借助动态规划的原因。以后遇到这种复杂的二分查值交互题，一定不要嫌麻烦，写个动态规划。

# Codeforces 1307E

**题目**

[https://codeforces.com/contest/1307/problem/E](https://codeforces.com/contest/1307/problem/E)

**题解**

这是一道挺有趣的问题的，优化的空间很大。

首先吃同一类草的牛，一边最多只会有一只。

很容易想到一个$DP$的方式，时间复杂度为$O(n^3)$。但是这个方式铁定不行。

我们可以换一个思路，枚举从左走出走到最靠右的牛，以及从右走出走到最靠左的牛。之后我们发现其它牛就直接被分成了三类，第一类只能出现在左边，第二类只能出现在右边，第三类可以出现在两边。我们可以对吃一类草的牛独立统计贡献，总的方案数可以将所有贡献乘起来得到。

你可能会问，那时间复杂度不还是$O(n^3)$吗？是的，但是这样弄就有了优化的空间，而之前的$DP$绝对是死路一条。我们会发现为啥我们需要枚举左右两边最靠边的牛的位置呢，是为了防止重复统计，但是实际上如果从左边出来最靠右的牛确定了，右边的牛即使不确定也不会导致重复统计。因此我们这样就直接砍掉了一个$n$，时间复杂度降低为$O(n^2)$。

但是还能优化，如果我们从左往右枚举从左出发最靠右的牛时，每次下标变动的时，最多只有两只牛允许出现位置会变动。因此我们可以通过扫描并不断修改，就能保证时间复杂度为$O(n\log_2n)$，这里的$\log_2n$是因为需要用到求逆运算。

# Codeforces 1311E

**题意**

[https://codeforces.com/contest/1311/problem/E](https://codeforces.com/contest/1311/problem/E)

**题解**

很显然当树是一条链表的时候，深度之和会达到最大，而树除了深度最大的一层外，其它第$i$层正好$2^i$个顶点的时候深度最小。

总深度最小记作$m$，总深度最大记作$M$。下面我们给出一个构造性算法，每次操作都能将总深度减少1。我们从链表开始转换。现在我们开始尝试将总深度减少1：如果一个叶子的深度为$k$，且在深度$k-2$处存在一个顶点，它的孩子数少于2，那么我们称这个叶子是有效的。我们选择所有有效叶子中深度最小的，记它的深度为$k$，将其移动到某个孩子数少于2的深度为$k-2$的顶点下面。这个算法可以持续直到树的深度和达到最小。