---
categories: algorithm
layout: post
---

- Table
{:toc}
# 等式差分

差分约束系统的问题在于需要处理负环的情况，因此必须使用BF算法或Spfa算法，而这两个算法的最坏时间复杂度为$O(V(V+E))$，这在变量较多的时候往往是不可行的。

一般的差分约束系统的约束样式为：
$$
x_i-x_j\leq c
$$
，但是如果我们只允许等式出现，即：
$$
x_i-x_j=c
$$
，那么我们可以提出一个近线性的算法，判断差分约束系统是否有解，以及找到一组解。

这实际上是带路径压缩的并查集的一个拓展。我们发现路径并查集维护的是一片森林，我们可以为每个顶点赋予一个权值，这个权值表示的是改顶点与顶点所在树的根的差值，即假设顶点为$u$，而顶点所在的树的根为$r$，那么$u$的权重为：
$$
w(u)=value(u)-value(r)
$$
。

这样做的好处是，在执行路径压缩的时候，考虑当前顶点为$u$，$u$的父亲为$p$，$u$所在树的根为$r$，如果$p\neq r$，那么就会发生路径压缩。此时$w(p)$被更新为$w'(p)$，我们可以借助$w'(p)$和$w(u)$得到$w'(u)$：


$$
w'(u)=value(u)-value(r)\\
=value(u)-value(p)+value(p)-value(r)\\
=w(u)+w'(p)
$$


我们可以将权值的更新联系到并查集的路径压缩中，这样利用并查集的时间复杂度分析可以得出合并和查询操作都是线性的。



之后我们利用路径压缩来处理等式差分，对于等式
$$
value(u)-value(v)=c
$$
如果$u$和$v$处于相同并查集中，那么就可以用下面的方式进行验证：


$$
value(u)-value(v)=value(u)-value(r)-value(v)+value(r)=w(u)-w(r)
$$


当然如果处于不同的并查集中，我们就可以将两个并查集合并。



# BZOJ2330

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2330](https://www.lydsy.com/JudgeOnline/problem.php?id=2330)

**题解**

建立差分约束系统求解。这里需要注意的是，我们要求至少准备多少个糖果，即要最小化糖果总数。而我们通过差分约束系统求解得到的是最大化。因此我们需要建立辅助变量。原始变量记为$a_i$，而辅助变量记为$b_i$，使得$b_i=-a_i$。之后我们要建立的是$b_i$的差分约束系统，求得最优解后取反就是需要的最少糖果数。

为了保证每个$b_i$都一定要小于等于0，我们需要建立一个超级源点，并加入约束条件$b_i-s\leq 0$。之后搜索以s为源点的最短路。但是实际上，理解s真正起到的作用，由于s只有出边没有入边，我们可以去除s，而将所有其他结点的初始距离设为0即可。

还有需要注意的是数据有毒，在负环的时候spfa会被卡，需要使用深度优先版本的spfa。

# 一些差值问题

**问题1：给定$n$个未知数：$X_1,\ldots,X_n$。同时给定$m$个约束条件，第$i$个约束条件为$X_{i_1}-X_{i_2}=c_i$。之后要求输出$X_1-X_2,X_2-X_3,\ldots,X_{n-1}-X_n$，如果答案无法确定就输出0。**

可以发现我们可以用并查集来维护，每个元素都需要维护到父亲的差值。这样如果两个数处于同一个并查集，就能求解，否则无法确定。

**问题2：给定$n$个未知数：$X_1,\ldots,X_n$。同时给定$m$个约束条件，第$i$个约束条件为对于所有$j\in \[l_i,r_i\]$中所有未知数$X_j$的和为$c_i$。之后要求输出$X_1+X_2,X_2+X_3,\ldots,X_{n-1}+X_n$，如果答案无法确定就输出0。**

我们首先将数值转换为前缀和，记$S_i=\sum_{j=1}^iX_i$，那么每个约束条件都确定了两个前缀和的差值，因此就转换为了问题1。而对于要求的$X_i+X_{i+1}$，实际上要求的就是$S_{i+1}-S{i-1}$。