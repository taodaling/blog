---
layout: post
categories: problem
---

今天在学习Groovy入门的时候，Groovy使用了fibonacci数列作为例子，其代码大致如下：
```c
int fib(int n)
{
  return n < 2 ? n : (fib(n - 1) + fib(n - 2));
}
```

我突然想到了一个有趣的问题：*上面这段的代码计算fib(n)的时间复杂度上界是多少?*

下面是我个人的解法，仅供参考：
```
容易发现我们仅用0,1,...,n作为参数调用fib函数，而
fib(n)被调用1次，fib(n+1)被调用0次。而fib(n-1)被fib(n)给调用了一次，故总共1次。
fib(n+1) => 0
fib(n) => 1
fib(n - 1) => 1
是不是有点眼熟，这好像是fibonacci数列啊，下面给出我们的假设:
设C(i)表示fib(i)被调用的次数，则我们有C(i)=fib(n+1-i)。
当i为n+1,n,n-1时命题显然成立，下面考虑i<n-1的情况。
fib(i)仅被fib(i+1)和fib(i+2)直接调用，故C(i)=C(i+1)+C(i+2)=fib(n-i)+fib(n-i-1)=fib(n-i+1)。
命题得到证明。

之后我们分别通过fib(0),...,fib(n)的发生次数并加总即可得到一个不错的上界。
下面我们给出另外一个命题：
fib(0)+...+fib(k)=fib(k+2)-1
当k为0的时候命题成立，下面仅考虑k>=1的情况:
fib(0)+...+fib(k-1)+fib(k)=fib(k+1)-1+fib(k)=fib(k+2)-1

因此我们可以得出C(0)+...C(n)=fib(0)+fib(1)+...+fib(n+1)=fib(n+3)-1。
因此我们得到了上述程序计算fib(n)的一个时间复杂度上下界O(fib(n+3))。

fib(41)=165580141，而现代CPU一秒钟的运算次数也是亿级的，因此我们可以直接推断计算fib(38)能在一秒钟内得出。
```
