---
categories: problems
layout: post
---

- Table
{:toc}
# Codeforces 1146G

**问题:**

见链接[https://codeforces.com/contest/1146/problem/G](https://codeforces.com/contest/1146/problem/G)

**题解:**

令$dp(i,j,k)$表示仅考虑地点i..j，建立最高的屋子的高度不超过k时能获得的最大收益，其中惩罚条款仅考虑那些完全限于i..j内部的条款。要计算$dp(i,j,k)$，我们可以记m为房屋i..j中最高的那座，m可以通过枚举得到。之后如果$m<k$，那么很显然$dp(i,j,k)=dp(i,j,k-1)$。现在仅考虑$m=k$的情况。可以推出公式为：


$$
dp(i,j,k)=\min_m(dp(i,j,k-1),dp(i,m-1,k)+dp(m+1,j,k)+k^2-penalty)
$$



# Codeforces 1146H

**问题:**

见链接[https://codeforces.com/contest/1146/problem/H](https://codeforces.com/contest/1146/problem/H)

**题解:**

记$dp(i,j,k)$表示以顶点i开始结束，长度为k的凸包的数量。为了组成凸包，我们可以将一开始的所有线段按照斜率进行排序。之后我们可以遍历每条线段，并用线段对动态规划公式做补充，这样可以保证得到的折线的联结一定是凸包。

最后统计$\sum_idp(i,i,5)$即可。



# CF1168C

**问题:**

见链接[https://codeforces.com/contest/1168/problem/C](https://codeforces.com/contest/1168/problem/C)

**题解:**

定义dp(i,j)表示所有带j比特中能被i访问到的，且下标最小的数的下标。则可以认为数a[dp(i,j)]或者可以被a[i]直接访问或者被a[i]间接访问，可以被a[i]直接访问的数最多有20个。可以通过动态规划公式得到结果。



# CF1168D

**问题:**

见链接[https://codeforces.com/contest/1168/problem/C](https://codeforces.com/contest/1168/problem/C)

**题解:**

题解说可以通过树链剖分解决，不知道怎么做。按照题解里的来吧。

首先要满足条件，叶结点的深度一定相同。我们记$h_i$表示深度为i的结点的数目，那么不等式一定成立：$h_1\leq h_2 \leq \ldots$，如果我们发现两个相连的深度有等量结点，那么我们可以将两层压缩为一层。由于压缩后的数满足$h_1< h_2 < \ldots$，因此压缩后的树最高为$O(\sqrt(n))$

 # BZOJ1040

**问题**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1040](https://www.lydsy.com/JudgeOnline/problem.php?id=1040)

**题解**

首先把骑士作为结点，将讨厌关系作为边建立。容易发现两个连通分量之间的选择是独立的，因此我们只要为每一个连通分量选择最大的总权，之后加总就好了。

一个连通分量有k个骑士，则必定有k条边。我们知道这样的图本质是一个树加上一条边，即树中最多只有一个环。记X，Y为环的两个顶点，且X讨厌Y。那么我们知道X与Y不能同时出现，那么最优结果要么X不出现，要么Y不出现。我们分别尝试删除X以及删除Y两种策略，计算树形DP，就可以得到最优质值。



# BZOJ1079

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1079](https://www.lydsy.com/JudgeOnline/problem.php?id=1079)

**题解**

一开始以为是容斥，捂脸。

一种很简单的思路就是定义函数$f(i_1, i_2, \ldots, i_k, c)$表示用$i_j$种颜色j，有多少种有效排列，排列以颜色c作为结尾。但是函数的状态有$5^15\cdot k$种，这样的动态规划会超时。

实际上颜色具体是什么并不重要，重要的是数量为1的颜色有多少种，数量为2的颜色有多少种...因此我们定义的动态规划公式为$f(i_1,i_2,i_3,i_4,i_5, c)$，表示数量为j的颜色有$i_j$种，其中以数量为c的某种颜色作为开头的有效排列数目。这样总共状态为$15^5\cdot 5$，是可以求解的。



# BZOJ1010

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1010](https://www.lydsy.com/JudgeOnline/problem.php?id=1010)

**题解**

利用动态规划，定义$f(i)$表示要打包前i个物品的最小费用。容易推出：


$$
f(i)=\min_{j=0}^{i-1}(f(j)+(\sum_{k=j+1}^ic_k+(i-j-1)-L)^2)
$$


用原始的动态规划时间复杂度为$O(n^2)$，会超时。我们稍微简化一下公式，记$pre_i=\sum_{i=1}^nc_i$，$a_i=pre_i+i-L$，$b_i=pre_i+i+1$。代入上面式子中：


$$
f(j)+(\sum_{k=j+1}^ic_k+(i-j-1)-L)^2\\
=f(j)+(pre_i+i-L-(pre_j+j+1))\\
=f(j)+(a_i-b_j)^2\\
=f(j)+a_i^2+b_j^2-2a_ib_j
$$


我们可以改写递推公式：


$$
f(i)=a_i^2+\min_{j=0}^{i-1}(-2b_ja_i+f(j)+b_j^2)
$$


由于我们在计算$f(i)$的时候与j关联的变量都是已知的，因此可以视作常量，换一种表示，我们就会发现有min中的表达式对应一条直线，即$y=ax+b$，其中x需要我们用$a_i$代入。如果我们为这些直线维护一个上凸包，就可以利用凸包优化以$O(\log_2i)$的时间复杂度直接得到最优的j，而不需要以$O(i)$的时间复杂度遍历。这样时间复杂度就优化到$O(n\log_2n)$。

但是由于java没有long double类型，而数值的数据范围过大，所以精度不足会给出约莫的值，会WA。所以需要换种方法。

下面我们考虑使用斜率优化的方式。若存在$j>k$，且$-2b_ja_i+f(j)+b_j^2 \leq -2b_ka_i+f(k)+b_k^2$。继续推导：


$$
-2b_ja_i+f(j)+b_j^2 \leq -2b_ka_i+f(k)+b_k^2\\
\Rightarrow (f(j)+b_j^2)-(f(k)+b_k^2)\leq (2b_j-2b_k)a_i\\
\Rightarrow \frac{(f(j)+b_j^2)-(f(k)+b_k^2)}{2b_j-2b_k}\leq a_i
$$


记$Y(i)=f(i)+b_i^2$，记$X(i)=2b_i$，那么公式就转换为


$$
\frac{Y(j)-Y(k)}{X(j)-X(k)}\leq a_i
$$


而由于$a_i$是递增函数，因此可以利用斜率优化，时间复杂度为$O(n)$。

# BZOJ1222

**问题**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1222](https://www.lydsy.com/JudgeOnline/problem.php?id=1222)

**题解**

一开始以为是最大流，没想到解法。容易发现每个任务的费时都非常小，最多为5，因此需要在这里动手脚。

定义动态规划f(i,j,k)，表示是否有可能完成前i个任务，任务占用了机器A时间不超过j，任务占用了机器B时间不超过k，f(i,j,k)的返回值是布尔值。很显然当i和j固定时，f随着k的增大从false变为true，即$f_{ij}(k)=f(i,j,k)$使单调增函数。类似这类函数，我们只需要记录变为true的最小的k。因此我们将函数优化到了二维$g(i,j)=minarg_{k}f(i,j,k)=true$。这时候函数的整个状态只有$O(5n^2)$，是可以通过时限的。

我们将$g(i,j)$解读为当使用机器A时间少于等于j时，完成前i个任务至少需要占用机器B时间多少。这样就可以很容易推出递推公式。

# BZOJ1030

**问题**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1030](https://www.lydsy.com/JudgeOnline/problem.php?id=1030)

**题解**

要算有多少字符串合法，可以通过算多少字符串非法得到。首先对所有的子串通过AC自动机状态压缩，之后利用动态规划解决。$f(i,j)$表示有多少长度为i并处于状态j的字符串，之后递推就好了。

# BZOJ2326

**问题**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2326](https://www.lydsy.com/JudgeOnline/problem.php?id=2326)

**题解**

一开始想要使用数学公式推导。


$$
\sum_{i=1}^nix^i=x\sum_{i=1}^nix^{i-1}=x(\sum_{i=1}^nx^i)'\\
=x\cdot (\frac{x^{n+1}-x}{x-1})'=\frac{nx^{n+2}-(n+1)x^{n+1}+x}{(x-1)^2}
$$


但是模数m不一定是素数，因此除法不能实现。当然如果m是不同的素数的乘积，那么可以分解因子后对因子计算出结果，之后用中国余数定理恢复。但是这里也不能保证m一定是不同素数的乘积，捂脸。

但是实际上，公式是非常简单的，所以用动态规划试一下：


$$
f(i)=10^{D(i)+1}f(i-1)+i
$$


这里是一个线性方程。那么我们用矩阵乘法来表示：


$$
\left( \begin{array}{ccc}
10^{D(i)+1} & 1 & 0 \\
0 & 1 & 1 \\
0 & 0 & 1
\end{array} \right)
\left( \begin{array}{c}
f(i-1)\\
i\\
1
\end{array} \right)
=
\left( \begin{array}{c}
f(i)\\
i+1\\
1
\end{array} \right)
$$


用矩阵快速幂，分段处理就好了。

# HDU1693

**题意**

[http://acm.hdu.edu.cn/showproblem.php?pid=1693](http://acm.hdu.edu.cn/showproblem.php?pid=1693)

**题解**

 插头DP的入门题。类似于状态压缩动态规划，每个单元格可以填入六种图画，记$f(i,j,s)$表示为前i-1行放置好了，并放置好了第i行前j列，问从下往上看，能看到的m个单元格的状态为s，有多少种放置方案。

由于一个单元格只需要保存其是否与下侧单元格相连，如果相连，该列的状态为1，否则为0。这样就可以组成我们的状态。同时第i行j-1列单元格是否图画是否与右侧相连，相连记1，否则记0。这样我们需要维护的状态大小共m+1位，总状态数为$O(nm\cdot 2^{m+1})$。

# BZOJ1037

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1037](https://www.lydsy.com/JudgeOnline/problem.php?id=1037)

**题解**

这个问题有一个弱化的版本，不允许出现k个连续男孩或女孩的情况，问有多少种方案。这个问题比较简单，令$f(i,j,t)$表示排列i个男孩和j个女孩，使得不出现k个男孩或女孩连坐，且以t个男孩连坐作为结尾的情况下的方案数。同时令$g(i,j,t)$，表示排列i个男孩和j个女孩，使得不出现k个男孩或女孩连坐，且以t个女孩连坐作为结尾的情况下的方案数。计算所有结果，并最后加总就好了。

这个问题稍微有点绕。现在再简化成另外一个问题，给出一个排列，判断该排列是否出现某个连续段男孩与女孩数的差大于k。这可以通过动态规划实现。用同样的思路，我们记$f(i,j,a,b)$表示排列i个男孩和j个女孩，且该排列有效，且排列的所有的后缀中，男孩最多比女孩多a个，女孩最多比男孩多b个。之后统计即可。

# BZOJ1898

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1898](https://www.lydsy.com/JudgeOnline/problem.php?id=1898)

**题解**

题面比较复杂。记$f(i,j)$表示从起点出发，经过i秒后，落脚于j处的方案数。当鱼的位置都是固定的时候，可以发现存在一个复杂的动态规划关系，但好歹也是可以推导的。

再看看K特别的大，即动态规划需要迭代非常多轮，自然会想到用矩阵来做优化。

但是每个时刻食人鱼的位置也会变动该怎么办呢，题目给出了鱼的位置的周期仅为2，3，4，而对于三者的公倍数12来说，鱼一定会归位。因此容易想到分段DP的思路。

先将代表前面12秒的12个矩阵连乘，之后用快速幂进行迭代。最后会余下不超过12次的迭代，这时候暴力即可。

时间复杂度为$O(12\cdot n^3)$。

# BZOJ1260

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1260](https://www.lydsy.com/JudgeOnline/problem.php?id=1260)

**题解**

首先很容易发现连续的相同颜色可以合并。

之后定义$f(l,r,d)$表示绘制区间$[l,r]$所需要的最少步骤，且区间此时的默认色为$d$。很显然，在处理区间$[l,r]$时，点$l$可以第一个绘制。假设最优策略中我们将区间$[l,m]$绘制成点$l$所需的颜色，那么能够保证区间$[l+1,m]$上点的着色一定发生在该步骤之后（因为之前会浪费步骤）。

之后记忆化搜索就好了。好像别人的解法是$O(n^2)$的。。

# BZOJ1096

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1096](https://www.lydsy.com/JudgeOnline/problem.php?id=1096)

**题解**

很显然得用动态规划来解决。记$dp(i)$表示仅考虑前i个工厂，在第i个工厂建仓库的最小费用。可以得到递推公式：


$$
dp(i)=\min_{j<i}dp(j)+C(i)+\sum_{k=j+1}^{i-1}(X(i)-X(k))P(k)\\
=\min_{j<i}dp(j)+C(i)+X(i)\sum_{k=j+1}^{i-1}P(k)-\sum_{k=j+1}^{i-1}X(k)P(k)\\
=\min_{j<i}dp(j)+C(i)+X(i)(S(i-1)-S(j))-(F(i-1)-F(j))\\
=C(i)+X(i)S(i-1)-F(i-1)+\\
\min_{j<i}dp(j)-X(i)S(j)+F(j)
$$


很显然最后的min里面的内容可以用凸包技巧或斜率优化给优化掉。这里考虑斜率优化：


$$
dp(j)-X(i)S(j)+F(j)\leq dp(k)-X(i)S(k)+F(k)\\
\Rightarrow \frac{(dp(j)+F(j))-(dp(k)+F(k))}{S(j)-S(k)}\leq X(i)
$$
