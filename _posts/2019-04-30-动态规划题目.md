---
categories: problems
layout: post
---

- Table
{:toc}
# Codeforces 1146G

**问题:**

见链接[https://codeforces.com/contest/1146/problem/G](https://codeforces.com/contest/1146/problem/G)

**题解:**

令$dp(i,j,k)$表示仅考虑地点i..j，建立最高的屋子的高度不超过k时能获得的最大收益，其中惩罚条款仅考虑那些完全限于i..j内部的条款。要计算$dp(i,j,k)$，我们可以记m为房屋i..j中最高的那座，m可以通过枚举得到。之后如果$m<k$，那么很显然$dp(i,j,k)=dp(i,j,k-1)$。现在仅考虑$m=k$的情况。可以推出公式为：


$$
dp(i,j,k)=\min_m(dp(i,j,k-1),dp(i,m-1,k)+dp(m+1,j,k)+k^2-penalty)
$$



# Codeforces 1146H

**问题:**

见链接[https://codeforces.com/contest/1146/problem/H](https://codeforces.com/contest/1146/problem/H)

**题解:**

记$dp(i,j,k)$表示以顶点i开始结束，长度为k的凸包的数量。为了组成凸包，我们可以将一开始的所有线段按照斜率进行排序。之后我们可以遍历每条线段，并用线段对动态规划公式做补充，这样可以保证得到的折线的联结一定是凸包。

最后统计$\sum_idp(i,i,5)$即可。



# CF1168C

**问题:**

见链接[https://codeforces.com/contest/1168/problem/C](https://codeforces.com/contest/1168/problem/C)

**题解:**

定义dp(i,j)表示所有带j比特中能被i访问到的，且下标最小的数的下标。则可以认为数a[dp(i,j)]或者可以被a[i]直接访问或者被a[i]间接访问，可以被a[i]直接访问的数最多有20个。可以通过动态规划公式得到结果。



# CF1168D

**问题:**

见链接[https://codeforces.com/contest/1168/problem/C](https://codeforces.com/contest/1168/problem/C)

**题解:**

题解说可以通过树链剖分解决，不知道怎么做。按照题解里的来吧。

首先要满足条件，叶结点的深度一定相同。我们记$h_i$表示深度为i的结点的数目，那么不等式一定成立：$h_1\leq h_2 \leq \ldots$，如果我们发现两个相连的深度有等量结点，那么我们可以将两层压缩为一层。由于压缩后的数满足$h_1< h_2 < \ldots$，因此压缩后的树最高为$O(\sqrt(n))$

 # BZOJ1040

**问题**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1040](https://www.lydsy.com/JudgeOnline/problem.php?id=1040)

**题解**

首先把骑士作为结点，将讨厌关系作为边建立。容易发现两个连通分量之间的选择是独立的，因此我们只要为每一个连通分量选择最大的总权，之后加总就好了。

一个连通分量有k个骑士，则必定有k条边。我们知道这样的图本质是一个树加上一条边，即树中最多只有一个环。记X，Y为环的两个顶点，且X讨厌Y。那么我们知道X与Y不能同时出现，那么最优结果要么X不出现，要么Y不出现。我们分别尝试删除X以及删除Y两种策略，计算树形DP，就可以得到最优质值。



# BZOJ1079

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1079](https://www.lydsy.com/JudgeOnline/problem.php?id=1079)

**题解**

一开始以为是容斥，捂脸。

一种很简单的思路就是定义函数$f(i_1, i_2, \ldots, i_k, c)$表示用$i_j$种颜色j，有多少种有效排列，排列以颜色c作为结尾。但是函数的状态有$5^15\cdot k$种，这样的动态规划会超时。

实际上颜色具体是什么并不重要，重要的是数量为1的颜色有多少种，数量为2的颜色有多少种...因此我们定义的动态规划公式为$f(i_1,i_2,i_3,i_4,i_5, c)$，表示数量为j的颜色有$i_j$种，其中以数量为c的某种颜色作为开头的有效排列数目。这样总共状态为$15^5\cdot 5$，是可以求解的。



# BZOJ1010

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1010](https://www.lydsy.com/JudgeOnline/problem.php?id=1010)

**题解**

利用动态规划，定义$f(i)$表示要打包前i个物品的最小费用。容易推出：


$$
f(i)=\min_{j=0}^{i-1}(f(j)+(\sum_{k=j+1}^ic_k+(i-j-1)-L)^2)
$$


用原始的动态规划时间复杂度为$O(n^2)$，会超时。我们稍微简化一下公式，记$pre_i=\sum_{i=1}^nc_i$，$a_i=pre_i+i-L$，$b_i=pre_i+i+1$。代入上面式子中：


$$
f(j)+(\sum_{k=j+1}^ic_k+(i-j-1)-L)^2\\
=f(j)+(pre_i+i-L-(pre_j+j+1))\\
=f(j)+(a_i-b_j)^2\\
=f(j)+a_i^2+b_j^2-2a_ib_j
$$


我们可以改写递推公式：


$$
f(i)=a_i^2+\min_{j=0}^{i-1}(-2b_ja_i+f(j)+b_j^2)
$$


由于我们在计算$f(i)$的时候与j关联的变量都是已知的，因此可以视作常量，换一种表示，我们就会发现有min中的表达式对应一条直线，即$y=ax+b$，其中x需要我们用$a_i$代入。如果我们为这些直线维护一个上凸包，就可以利用凸包优化以$O(\log_2i)$的时间复杂度直接得到最优的j，而不需要以$O(i)$的时间复杂度遍历。这样时间复杂度就优化到$O(n\log_2n)$。

但是由于java没有long double类型，而数值的数据范围过大，所以精度不足会给出约莫的值，会WA。所以需要换种方法。

下面我们考虑使用斜率优化的方式。若存在$j>k$，且$-2b_ja_i+f(j)+b_j^2 \leq -2b_ka_i+f(k)+b_k^2$。继续推导：


$$
-2b_ja_i+f(j)+b_j^2 \leq -2b_ka_i+f(k)+b_k^2\\
\Rightarrow (f(j)+b_j^2)-(f(k)+b_k^2)\leq (2b_j-2b_k)a_i\\
\Rightarrow \frac{(f(j)+b_j^2)-(f(k)+b_k^2)}{2b_j-2b_k}\leq a_i
$$


记$Y(i)=f(i)+b_i^2$，记$X(i)=2b_i$，那么公式就转换为


$$
\frac{Y(j)-Y(k)}{X(j)-X(k)}\leq a_i
$$


而由于$a_i$是递增函数，因此可以利用斜率优化，时间复杂度为$O(n)$。

# BZOJ1222

**问题**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1222](https://www.lydsy.com/JudgeOnline/problem.php?id=1222)

**题解**

一开始以为是最大流，没想到解法。容易发现每个任务的费时都非常小，最多为5，因此需要在这里动手脚。

定义动态规划f(i,j,k)，表示是否有可能完成前i个任务，任务占用了机器A时间不超过j，任务占用了机器B时间不超过k，f(i,j,k)的返回值是布尔值。很显然当i和j固定时，f随着k的增大从false变为true，即$f_{ij}(k)=f(i,j,k)$使单调增函数。类似这类函数，我们只需要记录变为true的最小的k。因此我们将函数优化到了二维$g(i,j)=minarg_{k}f(i,j,k)=true$。这时候函数的整个状态只有$O(5n^2)$，是可以通过时限的。

我们将$g(i,j)$解读为当使用机器A时间少于等于j时，完成前i个任务至少需要占用机器B时间多少。这样就可以很容易推出递推公式。

# BZOJ1030

**问题**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1030](https://www.lydsy.com/JudgeOnline/problem.php?id=1030)

**题解**

要算有多少字符串合法，可以通过算多少字符串非法得到。首先对所有的子串通过AC自动机状态压缩，之后利用动态规划解决。$f(i,j)$表示有多少长度为i并处于状态j的字符串，之后递推就好了。

# BZOJ2326

**问题**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2326](https://www.lydsy.com/JudgeOnline/problem.php?id=2326)

**题解**

一开始想要使用数学公式推导。


$$
\sum_{i=1}^nix^i=x\sum_{i=1}^nix^{i-1}=x(\sum_{i=1}^nx^i)'\\
=x\cdot (\frac{x^{n+1}-x}{x-1})'=\frac{nx^{n+2}-(n+1)x^{n+1}+x}{(x-1)^2}
$$


但是模数m不一定是素数，因此除法不能实现。当然如果m是不同的素数的乘积，那么可以分解因子后对因子计算出结果，之后用中国余数定理恢复。但是这里也不能保证m一定是不同素数的乘积，捂脸。

但是实际上，公式是非常简单的，所以用动态规划试一下：


$$
f(i)=10^{D(i)+1}f(i-1)+i
$$


这里是一个线性方程。那么我们用矩阵乘法来表示：


$$
\left( \begin{array}{ccc}
10^{D(i)+1} & 1 & 0 \\
0 & 1 & 1 \\
0 & 0 & 1
\end{array} \right)
\left( \begin{array}{c}
f(i-1)\\
i\\
1
\end{array} \right)
=
\left( \begin{array}{c}
f(i)\\
i+1\\
1
\end{array} \right)
$$


用矩阵快速幂，分段处理就好了。

# HDU1693

**题意**

[http://acm.hdu.edu.cn/showproblem.php?pid=1693](http://acm.hdu.edu.cn/showproblem.php?pid=1693)

**题解**

 插头DP的入门题。类似于状态压缩动态规划，每个单元格可以填入六种图画，记$f(i,j,s)$表示为前i-1行放置好了，并放置好了第i行前j列，问从下往上看，能看到的m个单元格的状态为s，有多少种放置方案。

由于一个单元格只需要保存其是否与下侧单元格相连，如果相连，该列的状态为1，否则为0。这样就可以组成我们的状态。同时第i行j-1列单元格是否图画是否与右侧相连，相连记1，否则记0。这样我们需要维护的状态大小共m+1位，总状态数为$O(nm\cdot 2^{m+1})$。

# BZOJ1037

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1037](https://www.lydsy.com/JudgeOnline/problem.php?id=1037)

**题解**

这个问题有一个弱化的版本，不允许出现k个连续男孩或女孩的情况，问有多少种方案。这个问题比较简单，令$f(i,j,t)$表示排列i个男孩和j个女孩，使得不出现k个男孩或女孩连坐，且以t个男孩连坐作为结尾的情况下的方案数。同时令$g(i,j,t)$，表示排列i个男孩和j个女孩，使得不出现k个男孩或女孩连坐，且以t个女孩连坐作为结尾的情况下的方案数。计算所有结果，并最后加总就好了。

这个问题稍微有点绕。现在再简化成另外一个问题，给出一个排列，判断该排列是否出现某个连续段男孩与女孩数的差大于k。这可以通过动态规划实现。用同样的思路，我们记$f(i,j,a,b)$表示排列i个男孩和j个女孩，且该排列有效，且排列的所有的后缀中，男孩最多比女孩多a个，女孩最多比男孩多b个。之后统计即可。

# BZOJ1898

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1898](https://www.lydsy.com/JudgeOnline/problem.php?id=1898)

**题解**

题面比较复杂。记$f(i,j)$表示从起点出发，经过i秒后，落脚于j处的方案数。当鱼的位置都是固定的时候，可以发现存在一个复杂的动态规划关系，但好歹也是可以推导的。

再看看K特别的大，即动态规划需要迭代非常多轮，自然会想到用矩阵来做优化。

但是每个时刻食人鱼的位置也会变动该怎么办呢，题目给出了鱼的位置的周期仅为2，3，4，而对于三者的公倍数12来说，鱼一定会归位。因此容易想到分段DP的思路。

先将代表前面12秒的12个矩阵连乘，之后用快速幂进行迭代。最后会余下不超过12次的迭代，这时候暴力即可。

时间复杂度为$O(12\cdot n^3)$。

# BZOJ1260

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1260](https://www.lydsy.com/JudgeOnline/problem.php?id=1260)

**题解**

首先很容易发现连续的相同颜色可以合并。

之后定义$f(l,r,d)$表示绘制区间$[l,r]$所需要的最少步骤，且区间此时的默认色为$d$。很显然，在处理区间$[l,r]$时，点$l$可以第一个绘制。假设最优策略中我们将区间$[l,m]$绘制成点$l$所需的颜色，那么能够保证区间$[l+1,m]$上点的着色一定发生在该步骤之后（因为之前会浪费步骤）。

之后记忆化搜索就好了。好像别人的解法是$O(n^2)$的。。

# BZOJ1096

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1096](https://www.lydsy.com/JudgeOnline/problem.php?id=1096)

**题解**

很显然得用动态规划来解决。记$dp(i)$表示仅考虑前i个工厂，在第i个工厂建仓库的最小费用。可以得到递推公式：


$$
dp(i)=\min_{j<i}dp(j)+C(i)+\sum_{k=j+1}^{i-1}(X(i)-X(k))P(k)\\
=\min_{j<i}dp(j)+C(i)+X(i)\sum_{k=j+1}^{i-1}P(k)-\sum_{k=j+1}^{i-1}X(k)P(k)\\
=\min_{j<i}dp(j)+C(i)+X(i)(S(i-1)-S(j))-(F(i-1)-F(j))\\
=C(i)+X(i)S(i-1)-F(i-1)+\\
\min_{j<i}dp(j)-X(i)S(j)+F(j)
$$


很显然最后的min里面的内容可以用凸包技巧或斜率优化给优化掉。这里考虑斜率优化：


$$
dp(j)-X(i)S(j)+F(j)\leq dp(k)-X(i)S(k)+F(k)\\
\Rightarrow \frac{(dp(j)+F(j))-(dp(k)+F(k))}{S(j)-S(k)}\leq X(i)
$$



# BZOJ1057

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1057](https://www.lydsy.com/JudgeOnline/problem.php?id=1057)

**题解**

首先我们记R(i,j)表示网格(i,j)右侧最多可以扩展的长度，这个可以通过递推在O(nm)时间复杂度内计算完成。

记T(i,j)表示网格(i,j)上方可以扩展的长度，这里可以扩展还有一个条件，上方的网格的R必须大于等于当前网格的R。

同理定义B(i,j)表示网格(i,j)下方可以扩展的长度。

T(i,j)和B(i,j)都可以通过单调队列以$O(nm)$的时间复杂度完成。

记H(i,j)=T(i,j)+B(i,j)+1。

我们注意到一个最大的矩形，其左侧边缘网格中，记R最小的网格为(i,j)，那么我们可以保证矩形的长度为R(i,j)，且高度为H(i,j)，否则我们可以扩大矩形。

同理对于一个最大的正方形，其左侧边缘网格中，记R最小的网格为(i,j)，同时我们一定能得出H(i,j)是所有左侧边缘网格中最小的。而此时正方形的边长为min(R(i,j), H(i,j))，否则我们可以扩大正方形。

找最大的矩形和最大的正方形都可以通过遍历所有的网格得到。

总的时间复杂度为O(nm)。

# 乘积和问题

考虑下面问题，给定n，以及序列$\{x_i\},\{y_i\}$，其中$1\leq i \leq n$。问下面公式的值：


$$
\sum_{i}y_i\prod_{j\neq i}x_j
$$


很显然我们只要提前算好前缀积$f(i)=\prod_{j\leq i}x_i$和后缀积$g(i)=\prod_{j\geq i}x_i$，就可以将公式转换为：



$$
\sum_{i}y_if(i-1)g(i+1)
$$


这个式子就可以在线性时间内求解了。而前缀积和后缀积都可以在线性时间内求解，因此总的时间复杂度为$O(n)$。

上面的方式技巧性会比较强，但是一旦问题复杂度增加，我们就很难解决了。现在我们要求计算下面公式的值：


$$
\sum_{i\neq j}y_iy_j\prod_{k\neq i,j}x_k
$$


这里即使我们使用前缀积和后缀积的技术，也必须以$O(n^2)$的时间复杂度来计算。

但是我们可以用动态规划的方式进行考虑，记$dp(i,j)$表示对于前$i$个数，我们选择了$j$个以$y$的形式出现，而另外$i-j$个以$x$的形式出现，即：


$$
dp(i,j)=\sum_{t_1,t_2,\dots,t_j}^iy_{t_1}\ldots y_{t_j}\prod_{k\neq t_1,t_2,\dots,t_j}^ix_k
$$


我们可以得出：


$$
dp(i,j)=dp(i-1,j)x_i+dp(i-1,j-1)y_i
$$


而动态规划的时间复杂度为$O(nm)$，其中m是指选择m个数以y的形式出现在公式中。而这里m一般不会太大，我们可以认为m是一个常数，因此时间复杂度可以认为是$O(n)$，是线性的时间复杂度。

# BZOJ1063

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1063](https://www.lydsy.com/JudgeOnline/problem.php?id=1063)

**题解**

首先题目保证了无环，并且在不连通的情况下不需要处理。因此我们实际上要处理的是以首都为根的树形结构。

很容易能想到树上DP，利用树上DP我们可以以$O(n)$的时间复杂度，计算最少需要的不便利值。

但是方案数如何统计呢？？？

首先我们知道轻重链剖分，是一个合法的方案（重链代表铁路），因此不便利值最多为$O(\log_2n)$。

之后我们可以就可以用DP来处理了。记$f(i,j,k)$表示以i为根，i与不多于j个子结点之间修了铁路，此时子树的不便利值不超过k的方案数。记$g(i,j,k)$表示以i为根，i与正好j个子结点之间修了铁路，此时子树的不便利值不超过k的方案数。可以推出公式：


$$
g(i,0,j)=\sum_{c}^{children(i)}f(c,2,j-1)\\
g(i,1,j)=\sum_{x}^{children(i)}f(x,1,j)\sum_{c\neq x}^{children(i)}f(c,2,j-1)\\
g(i,2,j)=\sum_{x\neq y}^{children(i)}f(x,1,j)f(y,1,j)\sum_{c\neq x,y}^{children(i)}f(c,2,j-1)\\
f(i,k,j)=\sum_{t=0}^kg(i,t,j)
$$


每个等式都可以以线性的时间复杂度计算完成，因此，总的时间复杂度为$O(n\log_2n)$。

# BZOJ1095

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1095](https://www.lydsy.com/JudgeOnline/problem.php?id=1095)

**题解**

好题。

首先，假如不考虑修改，我们可以直接用树上DP算出结果。但是由于有修改的存在，因此我们需要利用特殊的技术实现可修改动态规划。

输入是一颗树，我们可以求出其括号序列。比如一个跟结点带两个子结点的括号序列为`(0(1)(2))`。

选择两个顶点u，v，并找到其lca(u,v)=x，记d(u)表示u的深度。那么u与v之间的距离为$d(u)+d(v)-2d(x)$。我们可以这样理解括号序列，每遇到一个左括号，我们深度加1，遇到一个右括号，深度减少1，这样我们就可以将括号序列的每个元素映射为一个深度。这样我们实际上要找的是两个左括号，其在括号序列中的下标为l,r，且$l\leq r$。我们记M(l,r)表示括号序列的第l个元素到第r个元素中深度的最小值。那么l、r对应的结点的距离为$d(l)+d(r)-2M(l,r)$。

对于一个括号序列，我们可以将其均分为两部分，并分治处理。这样最大的好处就是可以使用线段树结构进行维护，从而支持$O(\log_2n)$时间复杂度的修改和查询。

在分治的时候，假设括号序列分为两部分A和B，我们希望能求$d(l)+d(r)-2M(l,r)$，有三种可能：

- l, r均属于A
- l, r均属于B
- l, r分别属于A、B

下面仅讨论第三种情况，我们知道l、r之间拥有最小深度的元素或者落在A中，或者落在B中，枚举两种情况求解就好了。记dlr表示一个块中的最大元素，dlSub表示一个块能提供的最大d(l)-2M(l..)，drSub表示一个块能提供的最大的d(r)-2M(..r)。那么在第三种下答案应该为：


$$
\max(A.dlr+B.drSub,A.dlSub+B.dlr)
$$


我们可以在pushUp的时候维护这些属性，整体的时间复杂度为$O(m\log_2n)$。

# ABC138F

**题意**

[https://atcoder.jp/contests/abc138/tasks/abc138_f](https://atcoder.jp/contests/abc138/tasks/abc138_f)

**题解**

简单分析可知，对于所有满足条件的(x,y)对，y和x共享最高二进制位，且(x&y)=y。

我们可以用动态规划来求解，按照是否处理了首位二进制，是否严格上界，是否严格下界，共8种状态。

# LUOGU2839

**题意**

[https://www.luogu.org/problem/P2839](https://www.luogu.org/problem/P2839)

**题解**

题目的数据范围使用int就足够了，题目中序列的意思是连续的一段区间。

要给数x是区间[l,r]的中位数，当且仅当在区间[l,r]中大于等于x的数占了至少半成。

对于每个询问a,b,c,d，我们可以二分中位数x。当x确认时，我们希望判断中位数是否大于等于x，可以通过下面流程得到：我们将数组中所有大于等于x的数替换为1，其它数我们替换为0，这样如果我们找到了一个区间[l,r]，其中l落在[a,b]中，r落在[c,d]中，区间中数字的和大于等于0，那么我们可以断定中位数至少为x。

现在我们考虑如何快速判断这样的子区间[l,r]是否存在，由于[b+1,c-1]是无论如何都需要统计的，而[a,b]中只需要统计一个非空后缀，[c,d]则只需要统计一个非空前缀。容易想到这是个动态规划问题，但是由于询问无法预先处理，因此我们需要做的实际是要利用线段树上合并动态规划实现动态询问。

我们可以为每个值域中的数建立一个线段树，这里我们需要建立的是持久化线段树，否则空间会不足。每个数组中的元素，随着x的增大，会从1变为0，因此每个元素对应两次插入操作，建树的时空复杂度为$O(n\log_2n)$。

回答询问q次，由于使用二分，因此发生了$q\log_2m$次的询问（m是值域的大小），每次询问由线段树处理，总的实际复杂度为$O(q\log_2m\log_2n)$。

# LUOGU4463

**题意**

[https://www.luogu.org/problem/P4463](https://www.luogu.org/problem/P4463)

**题解**

很容易想到DP，定义$f(i,j)$表示从[1,i]中选择j个不同数的所有序列的累乘的和。从而推出：


$$
f(i,j)=f(i-1,j)+i\cdot f(i-1,j-1)
$$


但是由于a的范围过大，使得DP不可行。

神奇的是$f(i,j)=p(j)(i)$，其中p(j)是仅关联于j的多项式。当$j=0$时，$p(j)=1$。注意到对于一个n阶多项式g，能够保证$g(x)-g(x-1)$一定是$n-1$阶多项式。


$$
f(i,j)-f(i-1,j)=i\cdot f(i-1,j-1)\\
\Rightarrow p(j)(i)-p(j)(i-1)=i\cdot p(j-1)(i-1)\\
\Rightarrow |p(j)|-1=|p(j-1)|+1\\
\Rightarrow |p(j)| = 2j
$$


由于$p(n)$的阶数是$2n$，因此我们利用$2n+1$个点就可以确认$p(n)$。随便算出$2n+1$个点，用拉格朗日公式插值出最终结果就行了。时间复杂度为$O(n^2)$。