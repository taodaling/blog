---
categories: problems
layout: post
---

- Table
{:toc}


# 乘积和问题

考虑下面问题，给定n，以及序列$\{x_i\},\{y_i\}$，其中$1\leq i \leq n$。问下面公式的值：


$$
\sum_{i}y_i\prod_{j\neq i}x_j
$$


很显然我们只要提前算好前缀积$f(i)=\prod_{j\leq i}x_i$和后缀积$g(i)=\prod_{j\geq i}x_i$，就可以将公式转换为：



$$
\sum_{i}y_if(i-1)g(i+1)
$$


这个式子就可以在线性时间内求解了。而前缀积和后缀积都可以在线性时间内求解，因此总的时间复杂度为$O(n)$。

上面的方式技巧性会比较强，但是一旦问题复杂度增加，我们就很难解决了。现在我们要求计算下面公式的值：


$$
\sum_{i\neq j}y_iy_j\prod_{k\neq i,j}x_k
$$


这里即使我们使用前缀积和后缀积的技术，也必须以$O(n^2)$的时间复杂度来计算。

但是我们可以用动态规划的方式进行考虑，记$dp(i,j)$表示对于前$i$个数，我们选择了$j$个以$y$的形式出现，而另外$i-j$个以$x$的形式出现，即：


$$
dp(i,j)=\sum_{t_1,t_2,\dots,t_j}^iy_{t_1}\ldots y_{t_j}\prod_{k\neq t_1,t_2,\dots,t_j}^ix_k
$$


我们可以得出：


$$
dp(i,j)=dp(i-1,j)x_i+dp(i-1,j-1)y_i
$$


而动态规划的时间复杂度为$O(nm)$，其中m是指选择m个数以y的形式出现在公式中。而这里m一般不会太大，我们可以认为m是一个常数，因此时间复杂度可以认为是$O(n)$，是线性的时间复杂度。


# 动态规划求和问题

考虑有这样一个$n\times m$的矩阵$M$，$1\leq n,m \leq 3000$。矩阵$M$代表一个迷宫，$M_{ij}$为1表示该处不可通行，为0表示该处可通行。玩家只能每次向右或向下移动一格。

迷宫的出口和入口信息现在还不确定，每个为0的位置都有可能为入口和出口。

记$f(i,j,u,v)$表示入口为$(i,j)$，出口为$(u,v)$时，有多少可能的从入口到出口的轨迹，现在我们希望求：

$$
\sum_{M_{i,j}=0}\sum_{M_{u,v}=0}f(i,j,u,v)
$$

一般的动态规划每趟可以给出$O(nm)$的时间复杂度，但是由于总共要执行$O(nm)$次，因此总的时间复杂度将达到$O(n^2m^2)$。

我们考虑进行优化，实际上观察正常的动态规划递推公式：

$$
dp(i,j)=dp(i-1,j)+dp(i,j-1)
$$

我们可以发现，对于不管入口和出口怎么变换，递推关系都是不会改变的。并且还有最重要的一点，就是递推关系是线性的。

现在我们定义$dp_{i,j}$为当我们选择$(i,j)$作为入口的动态规划公式。这时候我们再定义一个新的函数:

$$
g=\sum_{M_{i,j}=0}dp_{i,j}
$$

那么我们实际上要求的是：

$$
\sum_{M_{i,j}=0}\sum_{M_{u,v}=0}f(i,j,u,v)\\
=\sum_{M_{i,j}=0}\sum_{M_{u,v}=0}dp_{i,j}(u,v)\\
=\sum_{M_{u,v}=0}\sum_{M_{i,j}=0}dp_{i,j}(u,v)\\
=\sum_{M_{u,v}=0}g(u,v)
$$

下面我们证明$g$也满足递推关系$g(i,j)=g(i-1,j)+g(i,j-1)$。

$$
g(i,j)=\sum_{M_{i,j}=0}dp_{i,j}(i,j)\\
=\sum_{M_{i,j}=0}[dp_{i,j}(i-1,j)+dp_{i,j}(i,j-1)]\\
=\sum_{M_{i,j}=0}dp_{i,j}(i-1,j)+\sum_{M_{i,j}=0}dp_{i,j}(i,j-1)\\
=g(i-1,j)+g(i,j-1)
$$

新的算法的时间复杂度为$O(nm)$。

所以以后遇到这种多个动态规划，但是每个动态规划除了初始状态不同外，递推关系一致，并且我们最终要对其进行求和的问题，我们都可以用这种方式进行加速。

# LIS问题

**动态规划解决LIS问题**

**给定一个序列$a_1,a_2,\ldots, a_n$，找出其中最长的一段子串$b_1,b_2,\ldots, b_k$，使得该子串严格递增。**

这个问题的解决方法非常多，比如说用动态规划，定义$dp(i)$表示以第$a_i$结尾的子串中最长的子串长度，那么很显然有递推公式：

$$
dp(i)=\max_{j<i\land a_j<a_i}dp(j)
$$

这个转移可以用线段树进行优化，优化后的时间复杂度为$O(n\log_2n)$。

讲另外一种二分的做法。定义$f_i(j)$表示仅考虑序列前$i$个元素，所有长度为$j$的递增子序列的最后一个元素的最小值。

很显然必定有$f_i(j)\geq f_i(j-1)$，$f_i(j)\geq f_{i-1}(j)$。因为存在长度为$j$的子序列，删除其中任意一个元素，一定可以得到另外一个长度为$j-1$的子序列。

因此，考虑第$i$个数$a_i$的时候，我们需要找到最大的$j$满足，$f_{i-1}(j)<a_i$，由于$f_{i-1}$是递增函数，因此二分是适用的。我们可以保证$f_i(j+1)=a_i$，而对于其余的值$t\neq j+1$，一定有$f_i(t)=f_{i-1}(t)$。因为假如$f_i(j+1)$小于$a_i$，那么一定有$f_{i-1}(j+1)=f_i(j+1)<a_i$，这与之前$j$最大相悖。

## 最长递增子序列和最小递减序列划分

如果我们可以将序列划分为若干个子序列，每个子序列都严格递减，那么称这是一个递减序列划分。所有递减序列划分中，划分的子序列最少的称为最小递减序列划分。

**定理：一个序列的最长递增子序列长度等于该序列的最小递减序列划分大小**

首先我们建立$dp\[i\]$，表示所有长度为i的序列的最小末端元素，很显然在用二分法优化DP的时候$dp\[i\]$是不断递减的，而有意义的$dp$仅为$dp\[1\],dp\[2\],\ldots,dp\[m\]$，其中m是LIS的长度。因此我们可以记录每个$dp\[i\]$，就可以得到一个递减子序列，这些$m$个子序列构成了原来序列的一个划分。

这样我们就证明了划分的存在，现在我们证明不可能存在更小的划分。实际上，考虑一个LIS对应的序列$b_1,b_2,\ldots, b_m$，容易发现任意两个元素不能处于同一个递减子序列中，因此递减子序列数至少为$m$。

**引理：一个序列的最长递减子序列长度等于该序列的最小递增序列划分**

## 置换的递增/递减子序列分解

对于$1,2,\ldots, n$的所有置换，我们希望将序列分解为最少的一些子序列，要求这些子序列满足递增或递减性质（分解的不同子串可以分别满足递增和递减）。考虑$1,2,\ldots,n$的所有置换，它们中最小分解的最大值$f(n)$是多少。

可以证明这个值是最小的正整数$k$，满足$\frac{k(k+1)}{2}\geq n$。

用归纳法证明，当$n=1$的时候，$k=1$，命题一定成立。

考虑任意$n$，假设其LIS长度大于等于$k$，那么我们就可以从中提取出LIS作为一个划分的一部分，于是最少划分数量为$f(n-k)+1$，此时有$\frac{k(k+1)}{2}\geq n\Rightarrow \frac{k(k-1)}{2}\geq n-k$。因此$f(n-k)=k-1$，故$f(n)=k$。

那么如果LIS长度小于等于$k$呢，由于最小递减子序列划分数等于最长递增子序列长度，因此我们可以正好将整个序列划分为$k$个递减子序列。


# 二维网格统计有效路径数问题

**给定一个n行m列二维网格，我们从左上角(1,1)出发，到右下角(n,m)去。每次移动我们只能往下或往右移动一格。有一些格子存在石头（无法通过）。问从起点到终点有多少种走法，其中$n,m\leq 1000$**

比较简单的动态规划问题，直接定义$dp(i,j)$表示从起点到(i,j)的不停走法数。很显然$dp(i,j)=dp(i-1,j)+dp(i,j-1)$。时间复杂度为$O(nm)$。

**给定一个n行m列二维网格，我们从左上角(1,1)出发，到右下角(n,m)去。每次移动我们只能往下或往右移动一格。问从起点到终点有多少种走法，其中$n,m\leq 100000$**

我们不能继续傻傻用动态规划了，但是很容易发现，每一次路径实际上对应的是一个长度为n+m-1的01序列（0表示右移，1表示下移），其中0的数目为m-1。因此可以直接用组合数表示${n+m-1\choose m-1}$。

**给定一个n行m列二维网格，我们从左上角(1,1)出发，到右下角(n,m)去。每次移动我们只能往下或往右移动一格。有k个格子存在石头（无法通过）。问从起点到终点有多少种走法，其中$n,m\leq 100000$，$k\leq 5000$**

事实上，这是一个atcoder的[问题](https://atcoder.jp/contests/dp/tasks/dp_y)。这个问题与前一个问题的不同之处在于有一些通过石头的路径是无效的（不应该被统计）。我们可以用容斥来排除。但是容斥的时间复杂度是$O(2^k)$啊。实则不然，我们会发现很多容斥选择都是无效的。同时容斥真正有价值的只有其选择石头数目的奇偶性。因此我们可以用DP来表示，我们记$dp(i,j)$表示选择第i个石头作为最靠近右下角的石头，同时总的选择石头数模2的结果为$j$，有多少路径满足这样的条件。这样我们就可以通过枚举前一个状态，递推出$dp(i,j)$的结果。总的时间复杂度为$O(\max(n,m)+k^2)$。

# 背包问题

## 01背包

一般的背包问题定义是这样的。给定$n$个正整数$A=a_1,\ldots,a_n$，以及另外一个正整数，判断是否存在一个$A$的子集$S$，子集中的所有数之和恰好等于某个给定的整数$m$。

我们可以定义一个简单的DP，记$f(i,j)$表示前$i$个数是否存在一个子集之和等于$j$。那么我们要求的就是$f(n,m)$。这个函数的转移非常简单$f(i,j)=f(i-1,j)\lor f(i-1,j-a_i)$。因此时间复杂度为$O(nm)$。

但是这里我们可以利用bitset技巧，将时间复杂度优化到$O(\frac{1}{32}nm)$。

## 完全背包

如果01背包中提到的每个数$a_i$都可以使用无穷次，问是否存在一个$A$的多重集合$S$，集合中的所有数之和恰好等于某个给定的整数$m$。

我们可以定义这样一个简单的DP，记$f(i,j)$表示前$i$个数中是否存在一个多重子集之和等于$j$。我们要求的就是$f(n,m)$，且我们可以推出递推公式：$f(i,j)=f(i-1,j)\lor f(i,j-a_i)$。这里我们$O(nm)$求解这个问题

## 多重背包

如果01背包中提到的每个数$a_i$可以使用最多$b_i$次，问是否存在一个$A$的多重集合$S$，集合中的所有数之和恰好等于某个给定的整数$m$。

很容易想到一个$O(nm^2)$的做法。但是我们会发现DP公式$f(i,j)$的值始终是布尔值，这实在有些浪费，我们可以为每个状态都额外携带一些信息（这实际上是非常重要的DP设计的技巧）。我们定义一个新的DP公式$g(i,j)$表示仅考虑前$i$个元素，至少需要在前$i$个元素的多重子集中出现多少次$a_i$，才能得到总和为$j$。这样我们就发现了一个转移，如果$g(i-1,j)\leq b_{i-1}$，那么$g(i,j)=0$，否则$g(i,j)=g(i,j-b_i)+1$。这样一来，我们的DP时间复杂度就优化到了$O(nm)$。

有了上面提到的技术，实际上我们可以优化一类01背包问题。记$C=\sum_{i}a_i$，我们可以发现$A$序列中最多只有$\sqrt{C}$个不同的值，因此我们可以将相同值合并得到一个多重背包问题，这样我们就可以在$O(m\sqrt{C})$时间复杂度内求解了。如果$C=O(n)$，那么时间复杂度可以优化为$O(m\sqrt{n})$。

其实上面提到的多重背包公式，泛用性并不是很强，因为DP公式的函数值被用来记录一个无用信息，这个信息只是帮助我们实现$O(nm)$时间复杂度的。比如说我们现在修改一下问题，要求求出所有多重集合中，和正好为$m$的包含最少元素的多重集合大小，就会发现上面提到的DP公式就失效了。下面介绍一种更加泛用的多重背包解决方案。

记录$h(i,j)$表示仅考虑前$i$个$A$中的数，总和为$j$至少需要选择多少元素。这样我们在考虑第$i$个元素的时候，可以根据对于模$a_i$余数不同的$j$分成不同的组进行计算，这样我们会发现，问题就变成了有两个数组$x$（对应$h(i-1,?)$）和$y$（对应$h(i,?)$），其中$y_i=i+\min_{i-b_i-1\leq j\leq i}(x_j-j)$。我们实际上可以维护一个单调队列来解决这个问题。

提供一道[题目](https://codeforces.com/contest/95/problem/E)。

## 超大背包

大家先看看这道[题目](https://codeforces.com/contest/1132/problem/E)。

这个题目很明显是一个背包，但是背包的容量超大，没法直接DP。

但是我们发现1到8这8个数的最大公倍数仅为840。这意味着对于最优结果，第i个数被选择了$c_i$个，那么$c_i=\frac{840}{i}\cdot a_i+b_i$，其中$b_i< \frac{840}{i}$。

我们发现取$840/i$个$i$的和都是$840$，我们可以把这些值做一致处理，简单称为单元。考虑不由单元组成的部分$\sum_{i=1}^8ic_i$，其一定不超过$840\cdot 8$，也就是说我们可以对这一部分进行DP，$dp(i)$表示取一些数总和为$i$的前提下，最多能保留多少单元。显然单元越多能组成的数范围越大。

最后暴力枚举结果中不能由单元提供的额外部分，同时判断最优解即可。

# WQS二分

考虑有$n$个物品，物品$i$的权重为$w_i$。我们需要从中正好选择$k$件物品，要求取出的物品总权重最大。

当然这个大家都知道可以用贪心算法解决。只要取权重最大的$k$件物品即可。但是这里要讲一下动态规划的求法。

我们可以定义$dp(i,j)$表示从前$i$件物品中取出$j$件，可以得到的最大权重。这样就可以得出递推公式：$dp(i,j)=\max(dp(i-1,j-1)+w_i, dp(i-1,j))$。

但是这样的写法是$O(n^2)$的，能不能更加快一些呢。我们会发现如果可以取任意件的时候，我们就可以将动态规划公式优化为$f(i)$，表示从前$i$件物品中最大能取出的权重，那么有$f(i)=\max(f(i-1),f(i-1)+w_i)$。这时候动态规划求法和贪心的速度是一样的。

这里要说一下WQS二分。记录$g(i)$表示从$n$件物品中仅能取$i$件物品时的最大总权，且满足$g(i)-g(i-1)\geq g(i+1)-g(i)$，即$g$的曲线是上凸的，那么我们就可以用一些斜线去切这个上凸包，从而得到凸包上每个顶点的信息。

做法就是我们为选择每个商品时都赋予一定的惩罚$c$（即用来切凸包的直线的斜率），很显然惩罚越大，我们最优解时进行的选择就会越少。因此我们可以二分惩罚，来得到恰好选择$k$次的结果$r$，我们可以将$r$加上$kc$就可以得到真正的结果了。（我们仅需二分斜率而不需要考虑直线在y轴上的截距，因为截距仅相当于在最终解上加上固定的常数，这不会影响不同解之间的比较关系）

这里需要注意的是不一定能正好二分到$k$次，比如所有物品的权重都相同，那么无论惩罚如何选择，要么一件不选，要么都选。但是这时候我们会发现多选带来的收益（在考虑惩罚的情况下）一定是0，因此我们可以不用在乎多选的情况，只要在最终结果仅加上$kc$（最后加上的数与最优解的时候实际选择的商品数无关，比如这里即使选择了$n$件商品，也仅加上$kc$而非$nc$）即可。

一道不错的[例题](https://www.luogu.com.cn/problem/P5308)。


# 真动态规划

## 序列带修改带区间查询动态规划

**题目1：给定一个序列$a_1,a_2,\ldots,a_n$。现在要求处理$q$次请求，每个请求分为两种操作：**

- **给定$l,r$，要求从$a_l,a_{l+1},\ldots,a_r$中选取若干个不相邻的元素，使得总和最大**
- **给定$i,y$，将$a_i$修改成$y$。**

首先如果没有修改且查询区间总是整个的序列的话，我们而已用动态规划来解决这个问题。但是现在又有修改又有区间查询，怎么搞。

先来考虑分治思想，我们将整个序列一分为二，分为左序列和右序列。之后我们独立计算左序列和右序列，之后我们将左右序列合并起来。合并的方式非常简单，左右子序列都维护一个大小为$2\times 2$的矩阵$m$，我们只需要利用修改后的矩阵乘法将两个矩阵乘起来即可。。

可以看出上面的方式只是解决了$l=1,r=n$的查询，那么对于多个任意查询如果回答。我们可以将分治过程理解成一棵树，这棵树中满足父顶点所处理的区间不完全落于$\[l,r\]$中，但是该顶点落在$\[l,r\]$中的顶点数上限是$2\log_2n$个，因此我们统计这$2\log_2n$个顶点上的处理结果就可以回答请求。这样回答所有请求的时间复杂度

上面提到的技术叫做离线二分。

好了，现在我们知道怎么解决查询了，但是如果处理修改呢，离线二分就解决不了这个问题了。但是细细的想，你会发现离线二分得到的二叉树实际上与线段树非常雷同。实际上，我们可以直接用线段树来替代离线二分得到的树。这样的好处是什么，线段树每次上传下传标记都是在线的，换句话说，我们只需要为线段树设计一套快速的合并算法，利用线段树天然支持修改的特性，我们就可以支持修改操作了。

这里用的合并算法实际上还是维护$2\times 2$矩阵，通过修改后的矩阵乘法来合并。

利用线段树我们就可以实现$O(\log_2n)$处理每个请求。

提供一道[题目](https://codeforces.com/contest/1004/problem/F)。

## 树上带修改带路径查询动态规划

**题目2：给定一个拥有$n$个顶点的树，第$i$个顶点上标着一个数字$a_i$。现在要处理$q$次请求，每个请求分为两种操作：**

- **查询树上的最大权独立集**
- **给定$i,y$，将$a_i$修改成$y$。**

这个问题实际上是问题1的树上加强版本。

如果没有修改操作，我们只需要在树上跑一次DP即可。现在多了修改操作，我们来看看怎么解决。

现在的问题是修改了后标记没法上传，我们可以对整棵树进行轻重链剖分，之后我们发现一条重链上的顶点恰好对应线段树的一个区间。我们可以在这个区间上跑真动态规划，这样我们可以立刻得到以重链顶部顶点为根的子树下的结果。这还不够，我们还需要将结果上传到父亲顶点上去，这里是直接暴力上传。可以发现由于沿着重链不断上升，总的上传次数被约束在$O(\log_2n)$，而每次的时间复杂度为$O(\log_2n)$，因此一次修改的时间复杂度为$O((\log_2n)^2)$。

这里提供一道[题目](https://www.luogu.com.cn/problem/P4719)。

# 一些合成问题

**题目1：给定$n$块宝石，第$i$块宝石的等级为$l_i$（$l_i\leq n$），价格为$c_i$。等级为$i$的宝石的出售价格为$p_i$。任意两块$i$级宝石可以合成为一块$i+1$级宝石。问最大收益是多少，这里的收益是出售宝石的收入减去购买宝石的支出。$n\leq 2000$**

首先我们按照宝石等级进行排序。之后建立动态规划$dp(i,j)$表示前$i$块宝石，手上等级$l_i$的石头还剩下$j$块，此时的最大收益。

动态规划的转移非常简单，这里不细说。总的时间复杂度是$O(n^2)$。

**题目2：给定$n$块宝石，第$i$块宝石的等级为$l_i$（$l_i\leq n$），价格为$c_i$。等级为$i$的宝石的出售价格为$p_i$。任意两块$i$级宝石可以合成为一块$i+1$级宝石。问最大收益是多少，这里的收益是出售宝石的收入减去购买宝石的支出。特殊要求如果购入的宝石是$i_1,i_2,\ldots,i_k$，那么要求$l_{i_1}\leq \ldots \leq l_{i_k}$。$n\leq 2000$**

现在我们不能对宝石进行排序。建立动态规划$dp(t,i,j)$表示仅考虑等级不超过$t$的宝石，第$i$块宝石是最后收购的宝石，且手头还剩下$j$块$t$级别宝石的最大收益。

可以发现总共有$O(n^3)$个状态，但是会发现在处理出$dp(t,i,n)$后，之后的有效状态随着$t$的增大1会减少一半。因此真实的时间复杂度还是$O(n^2)$。

# 动态规划去后效性

动态规划有时候转移需要考虑当前状态的信息，考虑的信息越多，所需要记录的也越多，时间复杂度和空间复杂度也会对应提高。在最严重的时候应该就是需要做状压的时候了。下面介绍一种技术，在一些情况下可以让你摆脱状压带来的时空复杂度飙升问题。

考虑这样一个题目，给定一个$n\times n$的矩形，我们希望在上面放入一些棋子，每个棋子都可以攻击对角线上的其他棋子，现在希望你回答，正好放$k$个棋子，有多少种方案数。

首先我们可以将这道题旋转45度，之后原本对角线攻击现在就对应变成了沿着垂线或水平线攻击。但是由于得到是一个棱形，因此没法直接用组合数学的方式直接跑。一种简单的方式就是状压DP，之后逐行处理，这里有一个技巧，就是偶数行和奇数行可以独立处理，且它们的有效列集合没有并集。这样做的时间为$O(n^22^n)$。

上面的这个算法由于使用了状压，可以看到时间复杂度中出现了一个指数函数$2^n$。当$n$达到$20$或更大的时候，上面的算法就过不了了。

下面说一下如果去除状压。我们重新排列行顺序，注意到这不会影响答案的有效性。我们按照行的长度从小到大进行排序。之后我们会发现一个非常有趣的事情，由于第$i$行始终比前面$i-1$行都长，因此如果前面$i-1$行共放置了$j$个棋子，那么第$i$行中仅有$j$个单元格不能被放置，而其余的单元格都可以放置。因此我们可以定义一个函数$f(i,j)$，其表示前$i$列放置$j$个棋子的方案数，那么可以直接得出一个简单的转移关系$f(i,j)=f(i-1,j)+f(i-1,j-1)\cdot (L_i-j+1)$。这样我们就可以摆脱了可怕的状压，时间复杂度降低为$O(n^2)$。

# 决策单调性

考虑这样一个DP公式

$$
dp(i,j)=\min_{k\leq j}dp(i-1,k)+cost(k,j)
$$

这是一个非常常见的递推公式，其中$0\leq i< n$，而$0\leq j<m$。这类公式的空间复杂度为$O(nm)$，时间复杂度为$O(nm^2)$。

如果$m\geq 10^5$，那么这个时间复杂度就太大了。可以尝试判断是否满足决策单调性，即$j\geq k\Rightarrow p(j)\geq p(k)$，其中$p(j)$表示$dp(i,j)$从$dp(i-1,p(j))$转移而来。如果满足，那么我们还可以用分治的方法来完成。设区间$\[l,r\]$在函数$p$的作用下，值域为$\[L,R\]$。那么我们可以选择$l$与$r$的中点$m$，并暴力枚举值域，找到最优点$p(m)$，之后递归处理$\[l,m)$（它的值域为$\[L,p(m)\]$）和$(m,r\]$（它的值域为$\[p(m),R\]$）。可以证明每一层的时间复杂度均为$O(m\log_2m)$，因此总的时间复杂度为$O(nm\log_2m)$。

**题目1：给定一个序列$a_1,\ldots,a_n$，其中$1\leq a_i\leq n$。记子序列$a_l,\ldots,a_r$的费用为$cost(l,r)=\sum_{i=l}^r\sum_{j=i+1}^n \[a_i=a_j\]$，即子序列中有多少相同的元素对。现在我们希望将整个序列切分为$m$个非空子序列，要求所有切分的子序列费用总和最小。输出最小费用。其中$n\leq 10^5, m\leq 100$**

可以直接使用DP：

$$
dp(i,j)=\min_{k< j}dp(i-1,k)+cost(k,j)
$$

这个公式的时间复杂度为$O(nm^2)$。

注意观察可以发现这个公式满足决策单调性。下面是证明：

假设$t<j$，且$p(t)>p(j)$。那么有$dp(i-1,p(t))+cost(p(t),t)<dp(i-1,p(j))+cost(p(j),t)$。

由于费用函数的特殊性，可以发现$cost(p(j),j)-cost(p(j),t)\geq cost(p(t),j)-cost(p(t),t)$，因此代入原来公式可以得出：

$$
dp(i-1,p(t))+cost(p(t),t)+cost(p(t),j)-cost(p(t),t)\\<dp(i-1,p(j))+cost(p(j),t)+cost(p(j),j)-cost(p(j),t)\\
\Rightarrow 
dp(i-1,p(t))+cost(p(t),j)<dp(i-1,p(j))+cost(p(j),j)
$$

这与$p(j)$的定义不符。因此可以证明公式满足决策单调性。

有了决策单调性，就可以利用分治将时间复杂度优化到$O(nm\log_2m)$。注意这里计算cost函数的时候，我们可以类似于莫队一样调整区间两端即可，这样我们发现每次分治共分了$O(\log_2m)$，每层左右两端最多切换$O(m)$次，因此总的时间复杂度为$O(m\log_2m)$。

提供一道[题目](https://codeforces.com/contest/868/problem/F)。

**题目2：给定一个序列$a_1,\ldots,a_n$，其中$1\leq a_i\leq n$。记子序列$a_l,\ldots,a_r$的费用为$cost(l,r)=\max_{l\leq i\leq r}a_i-\min_{1\leq i\leq r}a_i$。现在我们希望将整个序列切分为$m$个非空子序列，要求所有切分的子序列费用总和最小。输出最小费用。其中$n\leq 10^5, m\leq 100$**

这个问题和问题1的做法雷同，但是注意的是这里的单调性是反向的，即$j\geq k\Rightarrow p(j)\leq p(k)$。