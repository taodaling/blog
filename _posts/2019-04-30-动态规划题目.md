---
categories: problems
layout: post
---

- Table
{:toc}
# Codeforces 1146G

**问题:**

见链接[https://codeforces.com/contest/1146/problem/G](https://codeforces.com/contest/1146/problem/G)

**题解:**

令$dp(i,j,k)$表示仅考虑地点i..j，建立最高的屋子的高度不超过k时能获得的最大收益，其中惩罚条款仅考虑那些完全限于i..j内部的条款。要计算$dp(i,j,k)$，我们可以记m为房屋i..j中最高的那座，m可以通过枚举得到。之后如果$m<k$，那么很显然$dp(i,j,k)=dp(i,j,k-1)$。现在仅考虑$m=k$的情况。可以推出公式为：


$$
dp(i,j,k)=\min_m(dp(i,j,k-1),dp(i,m-1,k)+dp(m+1,j,k)+k^2-penalty)
$$



# Codeforces 1146H

**问题:**

见链接[https://codeforces.com/contest/1146/problem/H](https://codeforces.com/contest/1146/problem/H)

**题解:**

记$dp(i,j,k)$表示以顶点i开始结束，长度为k的凸包的数量。为了组成凸包，我们可以将一开始的所有线段按照斜率进行排序。之后我们可以遍历每条线段，并用线段对动态规划公式做补充，这样可以保证得到的折线的联结一定是凸包。

最后统计$\sum_idp(i,i,5)$即可。



# CF1168C

**问题:**

见链接[https://codeforces.com/contest/1168/problem/C](https://codeforces.com/contest/1168/problem/C)

**题解:**

定义dp(i,j)表示所有带j比特中能被i访问到的，且下标最小的数的下标。则可以认为数a[dp(i,j)]或者可以被a[i]直接访问或者被a[i]间接访问，可以被a[i]直接访问的数最多有20个。可以通过动态规划公式得到结果。



# CF1168D

**问题:**

见链接[https://codeforces.com/contest/1168/problem/C](https://codeforces.com/contest/1168/problem/C)

**题解:**

题解说可以通过树链剖分解决，不知道怎么做。按照题解里的来吧。

首先要满足条件，叶结点的深度一定相同。我们记$h_i$表示深度为i的结点的数目，那么不等式一定成立：$h_1\leq h_2 \leq \ldots$，如果我们发现两个相连的深度有等量结点，那么我们可以将两层压缩为一层。由于压缩后的数满足$h_1< h_2 < \ldots$，因此压缩后的树最高为$O(\sqrt(n))$

 # BZOJ1040

**问题**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1040](https://www.lydsy.com/JudgeOnline/problem.php?id=1040)

**题解**

首先把骑士作为结点，将讨厌关系作为边建立。容易发现两个连通分量之间的选择是独立的，因此我们只要为每一个连通分量选择最大的总权，之后加总就好了。

一个连通分量有k个骑士，则必定有k条边。我们知道这样的图本质是一个树加上一条边，即树中最多只有一个环。记X，Y为环的两个顶点，且X讨厌Y。那么我们知道X与Y不能同时出现，那么最优结果要么X不出现，要么Y不出现。我们分别尝试删除X以及删除Y两种策略，计算树形DP，就可以得到最优质值。



# BZOJ1079

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1079](https://www.lydsy.com/JudgeOnline/problem.php?id=1079)

**题解**

一开始以为是容斥，捂脸。

一种很简单的思路就是定义函数$f(i_1, i_2, \ldots, i_k, c)$表示用$i_j$种颜色j，有多少种有效排列，排列以颜色c作为结尾。但是函数的状态有$5^15\cdot k$种，这样的动态规划会超时。

实际上颜色具体是什么并不重要，重要的是数量为1的颜色有多少种，数量为2的颜色有多少种...因此我们定义的动态规划公式为$f(i_1,i_2,i_3,i_4,i_5, c)$，表示数量为j的颜色有$i_j$种，其中以数量为c的某种颜色作为开头的有效排列数目。这样总共状态为$15^5\cdot 5$，是可以求解的。



# BZOJ1010

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1010](https://www.lydsy.com/JudgeOnline/problem.php?id=1010)

**题解**

利用动态规划，定义$f(i)$表示要打包前i个物品的最小费用。容易推出：


$$
f(i)=\min_{j=0}^{i-1}(f(j)+(\sum_{k=j+1}^ic_k+(i-j-1)-L)^2)
$$


用原始的动态规划时间复杂度为$O(n^2)$，会超时。我们稍微简化一下公式，记$pre_i=\sum_{i=1}^nc_i$，$a_i=pre_i+i-L$，$b_i=pre_i+i+1$。代入上面式子中：


$$
f(j)+(\sum_{k=j+1}^ic_k+(i-j-1)-L)^2\\
=f(j)+(pre_i+i-L-(pre_j+j+1))\\
=f(j)+(a_i-b_j)^2\\
=f(j)+a_i^2+b_j^2-2a_ib_j
$$


我们可以改写递推公式：


$$
f(i)=a_i^2+\min_{j=0}^{i-1}(-2b_ja_i+f(j)+b_j^2)
$$


由于我们在计算$f(i)$的时候与j关联的变量都是已知的，因此可以视作常量，换一种表示，我们就会发现有min中的表达式对应一条直线，即$y=ax+b$，其中x需要我们用$a_i$代入。如果我们为这些直线维护一个上凸包，就可以利用凸包优化以$O(\log_2i)$的时间复杂度直接得到最优的j，而不需要以$O(i)$的时间复杂度遍历。这样时间复杂度就优化到$O(n\log_2n)$。

但是由于java没有long double类型，而数值的数据范围过大，所以精度不足会给出约莫的值，会WA。所以需要换种方法。

下面我们考虑使用斜率优化的方式。若存在$j>k$，且$-2b_ja_i+f(j)+b_j^2 \leq -2b_ka_i+f(k)+b_k^2$。继续推导：


$$
-2b_ja_i+f(j)+b_j^2 \leq -2b_ka_i+f(k)+b_k^2\\
\Rightarrow (f(j)+b_j^2)-(f(k)+b_k^2)\leq (2b_j-2b_k)a_i\\
\Rightarrow \frac{(f(j)+b_j^2)-(f(k)+b_k^2)}{2b_j-2b_k}\leq a_i
$$


记$Y(i)=f(i)+b_i^2$，记$X(i)=2b_i$，那么公式就转换为


$$
\frac{Y(j)-Y(k)}{X(j)-X(k)}\leq a_i
$$


而由于$a_i$是递增函数，因此可以利用斜率优化，时间复杂度为$O(n)$。

# BZOJ1222

**问题**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1222](https://www.lydsy.com/JudgeOnline/problem.php?id=1222)

**题解**

一开始以为是最大流，没想到解法。容易发现每个任务的费时都非常小，最多为5，因此需要在这里动手脚。

定义动态规划f(i,j,k)，表示是否有可能完成前i个任务，任务占用了机器A时间不超过j，任务占用了机器B时间不超过k，f(i,j,k)的返回值是布尔值。很显然当i和j固定时，f随着k的增大从false变为true，即$f_{ij}(k)=f(i,j,k)$使单调增函数。类似这类函数，我们只需要记录变为true的最小的k。因此我们将函数优化到了二维$g(i,j)=minarg_{k}f(i,j,k)=true$。这时候函数的整个状态只有$O(5n^2)$，是可以通过时限的。

我们将$g(i,j)$解读为当使用机器A时间少于等于j时，完成前i个任务至少需要占用机器B时间多少。这样就可以很容易推出递推公式。

# BZOJ1030

**问题**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1030](https://www.lydsy.com/JudgeOnline/problem.php?id=1030)

**题解**

要算有多少字符串合法，可以通过算多少字符串非法得到。首先对所有的子串通过AC自动机状态压缩，之后利用动态规划解决。$f(i,j)$表示有多少长度为i并处于状态j的字符串，之后递推就好了。

# BZOJ2326

**问题**

[https://www.lydsy.com/JudgeOnline/problem.php?id=2326](https://www.lydsy.com/JudgeOnline/problem.php?id=2326)

**题解**

一开始想要使用数学公式推导。


$$
\sum_{i=1}^nix^i=x\sum_{i=1}^nix^{i-1}=x(\sum_{i=1}^nx^i)'\\
=x\cdot (\frac{x^{n+1}-x}{x-1})'=\frac{nx^{n+2}-(n+1)x^{n+1}+x}{(x-1)^2}
$$


但是模数m不一定是素数，因此除法不能实现。当然如果m是不同的素数的乘积，那么可以分解因子后对因子计算出结果，之后用中国余数定理恢复。但是这里也不能保证m一定是不同素数的乘积，捂脸。

但是实际上，公式是非常简单的，所以用动态规划试一下：


$$
f(i)=10^{D(i)+1}f(i-1)+i
$$


这里是一个线性方程。那么我们用矩阵乘法来表示：


$$
\left( \begin{array}{ccc}
10^{D(i)+1} & 1 & 0 \\
0 & 1 & 1 \\
0 & 0 & 1
\end{array} \right)
\left( \begin{array}{c}
f(i-1)\\
i\\
1
\end{array} \right)
=
\left( \begin{array}{c}
f(i)\\
i+1\\
1
\end{array} \right)
$$


用矩阵快速幂，分段处理就好了。

# HDU1693

**题意**

[http://acm.hdu.edu.cn/showproblem.php?pid=1693](http://acm.hdu.edu.cn/showproblem.php?pid=1693)

**题解**

 插头DP的入门题。类似于状态压缩动态规划，每个单元格可以填入六种图画，记$f(i,j,s)$表示为前i-1行放置好了，并放置好了第i行前j列，问从下往上看，能看到的m个单元格的状态为s，有多少种放置方案。

由于一个单元格只需要保存其是否与下侧单元格相连，如果相连，该列的状态为1，否则为0。这样就可以组成我们的状态。同时第i行j-1列单元格是否图画是否与右侧相连，相连记1，否则记0。这样我们需要维护的状态大小共m+1位，总状态数为$O(nm\cdot 2^{m+1})$。

# BZOJ1037

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1037](https://www.lydsy.com/JudgeOnline/problem.php?id=1037)

**题解**

这个问题有一个弱化的版本，不允许出现k个连续男孩或女孩的情况，问有多少种方案。这个问题比较简单，令$f(i,j,t)$表示排列i个男孩和j个女孩，使得不出现k个男孩或女孩连坐，且以t个男孩连坐作为结尾的情况下的方案数。同时令$g(i,j,t)$，表示排列i个男孩和j个女孩，使得不出现k个男孩或女孩连坐，且以t个女孩连坐作为结尾的情况下的方案数。计算所有结果，并最后加总就好了。

这个问题稍微有点绕。现在再简化成另外一个问题，给出一个排列，判断该排列是否出现某个连续段男孩与女孩数的差大于k。这可以通过动态规划实现。用同样的思路，我们记$f(i,j,a,b)$表示排列i个男孩和j个女孩，且该排列有效，且排列的所有的后缀中，男孩最多比女孩多a个，女孩最多比男孩多b个。之后统计即可。

# BZOJ1898

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1898](https://www.lydsy.com/JudgeOnline/problem.php?id=1898)

**题解**

题面比较复杂。记$f(i,j)$表示从起点出发，经过i秒后，落脚于j处的方案数。当鱼的位置都是固定的时候，可以发现存在一个复杂的动态规划关系，但好歹也是可以推导的。

再看看K特别的大，即动态规划需要迭代非常多轮，自然会想到用矩阵来做优化。

但是每个时刻食人鱼的位置也会变动该怎么办呢，题目给出了鱼的位置的周期仅为2，3，4，而对于三者的公倍数12来说，鱼一定会归位。因此容易想到分段DP的思路。

先将代表前面12秒的12个矩阵连乘，之后用快速幂进行迭代。最后会余下不超过12次的迭代，这时候暴力即可。

时间复杂度为$O(12\cdot n^3)$。

# BZOJ1260

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1260](https://www.lydsy.com/JudgeOnline/problem.php?id=1260)

**题解**

首先很容易发现连续的相同颜色可以合并。

之后定义$f(l,r,d)$表示绘制区间$[l,r]$所需要的最少步骤，且区间此时的默认色为$d$。很显然，在处理区间$[l,r]$时，点$l$可以第一个绘制。假设最优策略中我们将区间$[l,m]$绘制成点$l$所需的颜色，那么能够保证区间$[l+1,m]$上点的着色一定发生在该步骤之后（因为之前会浪费步骤）。

之后记忆化搜索就好了。好像别人的解法是$O(n^2)$的。。

# BZOJ1096

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1096](https://www.lydsy.com/JudgeOnline/problem.php?id=1096)

**题解**

很显然得用动态规划来解决。记$dp(i)$表示仅考虑前i个工厂，在第i个工厂建仓库的最小费用。可以得到递推公式：


$$
dp(i)=\min_{j<i}dp(j)+C(i)+\sum_{k=j+1}^{i-1}(X(i)-X(k))P(k)\\
=\min_{j<i}dp(j)+C(i)+X(i)\sum_{k=j+1}^{i-1}P(k)-\sum_{k=j+1}^{i-1}X(k)P(k)\\
=\min_{j<i}dp(j)+C(i)+X(i)(S(i-1)-S(j))-(F(i-1)-F(j))\\
=C(i)+X(i)S(i-1)-F(i-1)+\\
\min_{j<i}dp(j)-X(i)S(j)+F(j)
$$


很显然最后的min里面的内容可以用凸包技巧或斜率优化给优化掉。这里考虑斜率优化：


$$
dp(j)-X(i)S(j)+F(j)\leq dp(k)-X(i)S(k)+F(k)\\
\Rightarrow \frac{(dp(j)+F(j))-(dp(k)+F(k))}{S(j)-S(k)}\leq X(i)
$$



# BZOJ1057

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1057](https://www.lydsy.com/JudgeOnline/problem.php?id=1057)

**题解**

首先我们记R(i,j)表示网格(i,j)右侧最多可以扩展的长度，这个可以通过递推在O(nm)时间复杂度内计算完成。

记T(i,j)表示网格(i,j)上方可以扩展的长度，这里可以扩展还有一个条件，上方的网格的R必须大于等于当前网格的R。

同理定义B(i,j)表示网格(i,j)下方可以扩展的长度。

T(i,j)和B(i,j)都可以通过单调队列以$O(nm)$的时间复杂度完成。

记H(i,j)=T(i,j)+B(i,j)+1。

我们注意到一个最大的矩形，其左侧边缘网格中，记R最小的网格为(i,j)，那么我们可以保证矩形的长度为R(i,j)，且高度为H(i,j)，否则我们可以扩大矩形。

同理对于一个最大的正方形，其左侧边缘网格中，记R最小的网格为(i,j)，同时我们一定能得出H(i,j)是所有左侧边缘网格中最小的。而此时正方形的边长为min(R(i,j), H(i,j))，否则我们可以扩大正方形。

找最大的矩形和最大的正方形都可以通过遍历所有的网格得到。

总的时间复杂度为O(nm)。

# 乘积和问题

考虑下面问题，给定n，以及序列$\{x_i\},\{y_i\}$，其中$1\leq i \leq n$。问下面公式的值：


$$
\sum_{i}y_i\prod_{j\neq i}x_j
$$


很显然我们只要提前算好前缀积$f(i)=\prod_{j\leq i}x_i$和后缀积$g(i)=\prod_{j\geq i}x_i$，就可以将公式转换为：



$$
\sum_{i}y_if(i-1)g(i+1)
$$


这个式子就可以在线性时间内求解了。而前缀积和后缀积都可以在线性时间内求解，因此总的时间复杂度为$O(n)$。

上面的方式技巧性会比较强，但是一旦问题复杂度增加，我们就很难解决了。现在我们要求计算下面公式的值：


$$
\sum_{i\neq j}y_iy_j\prod_{k\neq i,j}x_k
$$


这里即使我们使用前缀积和后缀积的技术，也必须以$O(n^2)$的时间复杂度来计算。

但是我们可以用动态规划的方式进行考虑，记$dp(i,j)$表示对于前$i$个数，我们选择了$j$个以$y$的形式出现，而另外$i-j$个以$x$的形式出现，即：


$$
dp(i,j)=\sum_{t_1,t_2,\dots,t_j}^iy_{t_1}\ldots y_{t_j}\prod_{k\neq t_1,t_2,\dots,t_j}^ix_k
$$


我们可以得出：


$$
dp(i,j)=dp(i-1,j)x_i+dp(i-1,j-1)y_i
$$


而动态规划的时间复杂度为$O(nm)$，其中m是指选择m个数以y的形式出现在公式中。而这里m一般不会太大，我们可以认为m是一个常数，因此时间复杂度可以认为是$O(n)$，是线性的时间复杂度。

# BZOJ1063

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1063](https://www.lydsy.com/JudgeOnline/problem.php?id=1063)

**题解**

首先题目保证了无环，并且在不连通的情况下不需要处理。因此我们实际上要处理的是以首都为根的树形结构。

很容易能想到树上DP，利用树上DP我们可以以$O(n)$的时间复杂度，计算最少需要的不便利值。

但是方案数如何统计呢？？？

首先我们知道轻重链剖分，是一个合法的方案（重链代表铁路），因此不便利值最多为$O(\log_2n)$。

之后我们可以就可以用DP来处理了。记$f(i,j,k)$表示以i为根，i与不多于j个子结点之间修了铁路，此时子树的不便利值不超过k的方案数。记$g(i,j,k)$表示以i为根，i与正好j个子结点之间修了铁路，此时子树的不便利值不超过k的方案数。可以推出公式：


$$
g(i,0,j)=\sum_{c}^{children(i)}f(c,2,j-1)\\
g(i,1,j)=\sum_{x}^{children(i)}f(x,1,j)\sum_{c\neq x}^{children(i)}f(c,2,j-1)\\
g(i,2,j)=\sum_{x\neq y}^{children(i)}f(x,1,j)f(y,1,j)\sum_{c\neq x,y}^{children(i)}f(c,2,j-1)\\
f(i,k,j)=\sum_{t=0}^kg(i,t,j)
$$


每个等式都可以以线性的时间复杂度计算完成，因此，总的时间复杂度为$O(n\log_2n)$。

# BZOJ1095

**题目**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1095](https://www.lydsy.com/JudgeOnline/problem.php?id=1095)

**题解**

好题。

首先，假如不考虑修改，我们可以直接用树上DP算出结果。但是由于有修改的存在，因此我们需要利用特殊的技术实现可修改动态规划。

输入是一颗树，我们可以求出其括号序列。比如一个跟结点带两个子结点的括号序列为`(0(1)(2))`。

选择两个顶点u，v，并找到其lca(u,v)=x，记d(u)表示u的深度。那么u与v之间的距离为$d(u)+d(v)-2d(x)$。我们可以这样理解括号序列，每遇到一个左括号，我们深度加1，遇到一个右括号，深度减少1，这样我们就可以将括号序列的每个元素映射为一个深度。这样我们实际上要找的是两个左括号，其在括号序列中的下标为l,r，且$l\leq r$。我们记M(l,r)表示括号序列的第l个元素到第r个元素中深度的最小值。那么l、r对应的结点的距离为$d(l)+d(r)-2M(l,r)$。

对于一个括号序列，我们可以将其均分为两部分，并分治处理。这样最大的好处就是可以使用线段树结构进行维护，从而支持$O(\log_2n)$时间复杂度的修改和查询。

在分治的时候，假设括号序列分为两部分A和B，我们希望能求$d(l)+d(r)-2M(l,r)$，有三种可能：

- l, r均属于A
- l, r均属于B
- l, r分别属于A、B

下面仅讨论第三种情况，我们知道l、r之间拥有最小深度的元素或者落在A中，或者落在B中，枚举两种情况求解就好了。记dlr表示一个块中的最大元素，dlSub表示一个块能提供的最大d(l)-2M(l..)，drSub表示一个块能提供的最大的d(r)-2M(..r)。那么在第三种下答案应该为：


$$
\max(A.dlr+B.drSub,A.dlSub+B.dlr)
$$


我们可以在pushUp的时候维护这些属性，整体的时间复杂度为$O(m\log_2n)$。

# ABC138F

**题意**

[https://atcoder.jp/contests/abc138/tasks/abc138_f](https://atcoder.jp/contests/abc138/tasks/abc138_f)

**题解**

简单分析可知，对于所有满足条件的(x,y)对，y和x共享最高二进制位，且(x&y)=y。

我们可以用动态规划来求解，按照是否处理了首位二进制，是否严格上界，是否严格下界，共8种状态。

# LUOGU2839

**题意**

[https://www.luogu.org/problem/P2839](https://www.luogu.org/problem/P2839)

**题解**

题目的数据范围使用int就足够了，题目中序列的意思是连续的一段区间。

要给数x是区间[l,r]的中位数，当且仅当在区间[l,r]中大于等于x的数占了至少半成。

对于每个询问a,b,c,d，我们可以二分中位数x。当x确认时，我们希望判断中位数是否大于等于x，可以通过下面流程得到：我们将数组中所有大于等于x的数替换为1，其它数我们替换为0，这样如果我们找到了一个区间[l,r]，其中l落在[a,b]中，r落在[c,d]中，区间中数字的和大于等于0，那么我们可以断定中位数至少为x。

现在我们考虑如何快速判断这样的子区间[l,r]是否存在，由于[b+1,c-1]是无论如何都需要统计的，而[a,b]中只需要统计一个非空后缀，[c,d]则只需要统计一个非空前缀。容易想到这是个动态规划问题，但是由于询问无法预先处理，因此我们需要做的实际是要利用线段树上合并动态规划实现动态询问。

我们可以为每个值域中的数建立一个线段树，这里我们需要建立的是持久化线段树，否则空间会不足。每个数组中的元素，随着x的增大，会从1变为0，因此每个元素对应两次插入操作，建树的时空复杂度为$O(n\log_2n)$。

回答询问q次，由于使用二分，因此发生了$q\log_2m$次的询问（m是值域的大小），每次询问由线段树处理，总的实际复杂度为$O(q\log_2m\log_2n)$。

# LUOGU4463

**题意**

[https://www.luogu.org/problem/P4463](https://www.luogu.org/problem/P4463)

**题解**

很容易想到DP，定义$f(i,j)$表示从[1,i]中选择j个不同数的所有序列的累乘的和。从而推出：


$$
f(i,j)=f(i-1,j)+i\cdot f(i-1,j-1)
$$


但是由于a的范围过大，使得DP不可行。

神奇的是$f(i,j)=p(j)(i)$，其中p(j)是仅关联于j的多项式。当$j=0$时，$p(j)=1$。注意到对于一个n阶多项式g，能够保证$g(x)-g(x-1)$一定是$n-1$阶多项式。


$$
f(i,j)-f(i-1,j)=i\cdot f(i-1,j-1)\\
\Rightarrow p(j)(i)-p(j)(i-1)=i\cdot p(j-1)(i-1)\\
\Rightarrow |p(j)|-1=|p(j-1)|+1\\
\Rightarrow |p(j)| = 2j
$$

由于$p(n)$的阶数是$2n$，因此我们利用$2n+1$个点就可以确认$p(n)$。随便算出$2n+1$个点，用拉格朗日公式插值出最终结果就行了。时间复杂度为$O(n^2)$。

# Codeforces1209E2

**题意**

[https://codeforces.com/contest/1209/problem/E2](https://codeforces.com/contest/1209/problem/E2)

**题解**

一开始以为是贪心或匹配问题，算算时间复杂度怎么都超。但是最后看题解发现是DP。

很显然m列我们最多只需要n列，这n列的最大值一定是最大的。因此提前排序后筛选，就只剩下n行n列。

我们用二进制表示某一行是否已经被选定，1为被选定，0为未选择。定义函数$g(i,s)$，表示第i列的选定状态为s，问最大总和是多少。首先每一列最多有n种形态（旋转的周期为n），之后对每种形态枚举即可。这里的时间复杂度为$O(n^32^n)$，可以稍加优化（在计算子集的同时计算总和），可以优化到$O(n^22^n)$。

之后记函数$f(i,s)$，表示只考虑前i列，选定状态为s的最大和。只需要简单枚举第i列的选定状态，就可以得出前i-1列的选定状态，这是一个子集问题，时间复杂度为$O(n3^n)$。

最后总的时间复杂度为$O(40(nm+m\log_2m+n3^n+n^22^n))$，计算量大概几亿，是可以过的。

# Atcoder AGC036D

**题意**

[https://atcoder.jp/contests/agc036/tasks/agc036_d](https://atcoder.jp/contests/agc036/tasks/agc036_d)

**题解**

想肯定是想不到的，看的题解。

我们从第0个点开始找单源最短路径，在无负环的情况下，最短路径是存在的。我们定义$p_i$为到顶点i的最远路径。由于存在权重为0的i到i+1的路径，因此可以断定$p_i$是单调递减的，即
$$
p_0\geq p_1 \geq\ldots \geq p_{n-1}
$$
，从而我们可以定义一组非负整数$q_i$，使得$q_i=p_i-p_{i-1}$。

考虑一条权重为-1的边，假设起点为i，终点为j。那么这条边在最短路中的含义是


$$
p_j\leq p_i-1\Rightarrow p_i-p_j\geq1\Rightarrow q_i+q_{i+1}+\ldots + q_{j-1}\geq 1
$$


考虑一条权重为1的边，假设启动为j，终点为1，那么这条边在最短路中的含义是


$$
p_i\leq p_j+1\Rightarrow p_i-p_j\leq 1\Rightarrow q_i+q_{i+1}+\ldots + q_{j-1}\leq 1
$$


我们的目标实际上是为非负整数$q_i$赋值，使得违背的约束的总费用最小。可以容易得出，当我们为$q_i$赋值大于1的整数时，我们将其改成1，不会有新的约束被违背，因此我们可以断言在最终结果中$q_i$只能为0或1。

之后就是动态规划了，记$f(i,j)$表示为$0,1,\ldots,j-1$，并处理完所有右边界小于j的约束后所需要支付的最少费用。

对于转移$f(i,j)$到$f(j,x)$，我们需要支付所有新违背的约束的费用，我们会违背以下符合条件的约束：


$$
\sum_{a=i+1}^{x-1}\sum_{b=i+1}^{x-1}[a\leq b]cost(a,b)
$$


以及


$$
\sum_{a=0}^j\sum_{b=i}^{x-1}[a\leq b]cost(b,a)
$$


其中
$$
[a\leq b]cost(a,b)
$$
表示的是形如
$$
p_a+_\ldots+p_b\geq1
$$
的约束，而
$$
[a\leq b]cost(b,a)
$$
是形如
$$
p_a+_\ldots+p_b\geq1
$$
的约束。而这两部分内容实际上是子矩阵和问题，我们可以预先处理前缀之后利用差分得到。总的时间复杂度为$O(n^3)$，考虑到$n\leq 500$，这个方法是可行的。

# BZOJ1109

**题意**

[https://www.lydsy.com/JudgeOnline/problem.php?id=1109](https://www.lydsy.com/JudgeOnline/problem.php?id=1109)

**题解**

用动态规划，dp(i)表示仅考虑前i个数，并保留第i个数最多有多少满足的块。简单推推可以转移公式：


$$
dp(i)=\max_{j<i}([a[j]<a[i]\land i-j\geq a[i]-a[j]]dp(i))+1
$$


后面部分我们可以做个转换得到：


$$
i-j\geq a[i]-a[j]\Rightarrow i-a[i]\geq j-a[j]
$$


我们可以定义$x_i=a[i]$，$y_i=i-a[i]$，$z_i=i$，那么问题就转换了三维最长递增子序列问题。

注意到由前两个条件可以保证第三个条件的成立，因此可以忽略第三个条件，问题转换为二维最长递增子序列问题。

随便写吧。一开始没有想这么多，就直接DP+树套树，结果TLE了。

# LUOGU1728

**题意**

[https://www.luogu.org/problem/P1728](https://www.luogu.org/problem/P1728)

**题解**

假如这个问题没有限制可以选择的技能数，那么实际上问题就可以转换成最大权闭合子图问题。但是很可惜并不是。

```
4 5
1 1 1 1
1 2 1
1 1
1
```

注意到每个数可以选择仅要求其上方和右上方的两个数被选择过即可。

假如我们从右往左处理（即先处理第n列，最后处理第1列），那么就非常简单了。

记$f(i,j,k)$表示第$i$列所有行号小于等于$j$行的数字都被选中，并且总共选择了$k$个数的最大选择值总和。

这样得出的递推关系为：
$$
f(i,j,k)=\max(f(i+1,j-1,k-j)+\sum_{t=1}^jgrid[t][i],f(i,j+1,k))
$$


最终结果为$f(1,0,m)$。

# LUOGU1285

**题意**

[https://www.luogu.org/problem/P1285](https://www.luogu.org/problem/P1285)

**题解**

看上去问题是要将图划分为两个团，使得团的差距尽可能小。看上去是个2-SAT问题，但是由于需要求尽可能平均，2-SAT是做不到的。

容易发现，找团是不容易的，但是如果a不认识b，那么我们会得到一个重要的性质，a、b必定处于不同的组。因此我们在不彼此认识的人之间加上一条边。

对于一个连通分量，其黑白染色要么不存在，要么只有两种可能性。对每个图上的连通分量染色后，计算每个连通分量的黑色顶点数和白色顶点数。

之后我们需要才从每个连通分量，要么选择全部黑色顶点加入组1，要么选择全部白色顶点加入组2。这实际上就是一个普通的DP问题了。

记
$$
DP(i,j)
$$
表示考虑前i个连通分量，是否可能正好选择j个人加入到组1中。之后就是DP了。

总的时间复杂度为$O(n^2)$。


# Atcoder ARC058C

**题意**

[https://atcoder.jp/contests/arc058/tasks/arc058_c](https://atcoder.jp/contests/arc058/tasks/arc058_c)

**题解**

简单的数论貌似很难处理，首先将包含问题变成不包含问题。但是可以用一些特殊的方式解决。

我们可以将数值序列看作一个字符串序列，这样问题就变成了统计包含某个特定连续子序列的字符串。

由于X、Y、Z都很小，我们可以暴力枚举所有可能的子序列（可以切分为三部分，第一部分的总和为X、第二部分为Y、第三部分为Z）。这样的序列总数不会超过一万个。

之后我们建立一个AC自动机，将可能的子序列全部插入到里面，之后AC自动机种的每个状态都对应一个动态规划状态，最终的状态最多只有3万多个。

之后我们建立递推公式，记$f(i,s)$表示考虑设置完前i个数值后，处于状态s的方案数，之后利用AC自动机递推就可以了。

大概的时间复杂度为$O(10^5n)$。

统计包含某个子序列的所有序列数问题的一般做法如下：

1. 由于包含问题容易重复统计，因此需要先转换为不包含问题。
2. 之后将禁止出现的子序列插入到AC自动机种。
3. 将AC自动机中的每个顶点作为DP状态，之后进行递推即可。





# Atcoder AGC002F

**题意**

[https://atcoder.jp/contests/agc002/tasks/agc002_f](https://atcoder.jp/contests/agc002/tasks/agc002_f)

**题解**

当k=1时，答案很显然时1，考虑非1的情况。

放球问题，一般都可以通过下面的动态规划解决。

我们定义dp(i,j)表示放置i种颜色的球（每种颜色k-1个），以及j个0颜色球，有多少种方案。可以推出：


$$
dp(i,j)=dp(i,j-1)+dp(i-1,j)\cdot j \cdot {i(k-1)+j-1\choose k-2}
$$


这里的解释是，放置的第一个球或许是0颜色球，或许是其他i种颜色里的一种。如果是i种颜色种的一种，那么剩下的同颜色的$k-2$个球可以通过组合数学与后面的i-1种颜色及j个0颜色球合并。

大抵上，一般如果球之间有依赖关系。即球之间的关系存在拓扑关系，那么就可以用类似的动态规划得到。$dp(i_1, i_2, \ldots)$表示第$j$类球有$i_j$个。

# Atcoder AGC004E

**题意**

[https://atcoder.jp/contests/agc004/tasks/agc004_e](https://atcoder.jp/contests/agc004/tasks/agc004_e)

**题解**

用动态规划解决，定义$f(l,r,u,d)$表示我们抵达的最靠左的位置的列号与出口的列号差值为l，最靠右的位置的列号与出口的列号的差值为r，最靠上的位置的行号与出口的行号差值为u，最靠下的位置的行号与出口的行号差值为d。

# ARC066C

**题意**

[https://atcoder.jp/contests/arc066/tasks/arc066_c](https://atcoder.jp/contests/arc066/tasks/arc066_c)

**题解**

很容易想到$O(n^2)$的区间DP解法。下面我们来证明最优解可以通过最多嵌套两层括号得到。

首先很容易发现下面几个性质：

- 左括号一定出现在负号后才有意义
- 左括号不会连续出现（即不存在`((`的情况）
- 对于嵌套奇数层的情况下，右括号出现的位置的前一个运算符一定是负号。
- 对于嵌套偶数层的情况下，右括号出现的位置的前一个运算符一定是正号。

下面考虑6个整数：
$$
a<b<c<d<e<f
$$
，假设a、b、c表示左括号出现的位置，d、e、f表示右括号出现的位置。这是典型的三层括号嵌套的情况。

我们可以将括号转换为：a、b、d为左括号，c、e、f为右括号，此时只嵌套两层，且运算结果不变。

因此我们怎么了括号最多嵌套两层。这时候我们定义
$$
dp(i,j)
$$
表示在处理完前i个数后，还有j个左括号未匹配的情况下可以可以得到的最大值。其中j仅可能为0、1、2。

总的时间复杂度为$O(n)$。


# 单调增斜率优化

首先让我们来考虑下面问题：

要求求解$f(n)$，其中$f$定义如下：


$$
f(i)=\Bigg\{
\begin{array}{ccc}
0&,i=0\\
\min\{h(j)-s(i)s(j)|0\leq j <i\}&,i\ge 1
\end{array}
$$


其中h是一个已知函数，而s是一个严格递增函数。这里我们简单记$r(j,i)=f(j)+h(j)-s(i)s(j)$。

可以很轻松地给出一个$O(n^2)$时间复杂度的算法，但是假如你学会了斜率优化，那就能将时间复杂度降低为$O(n)$。

假设存在$k<j<i$，且$r(j,i)\leq r(k,i)$，那么我们可以推得：

$$
r(j,i)
\leq
r(k,i)\\
\Rightarrow
h(j)-s(i)s(j)
\leq
h(k)-s(i)s(k)\\
\Rightarrow
h(j)-h(k)
\leq
s(i)(s(j)-s(k))\\
\Rightarrow
\frac{h(j)-h(k)}{s(j)-s(k)}\leq s(i)
$$

看着上面公式是不是有点眼熟？让我们记Y(i)=h(i)，记X(i)=s(i)，那么带入上面公式得到：


$$
r(j,i)
\leq
r(k,i)\\
\Rightarrow
\frac{Y(j)-Y(k)}{X(j)-X(k)}
\leq
s(i)
$$

这时候应该认出来了吧，这就是我们的斜率公式，即不等式的左边表示的是从$(X(k),Y(k))$出发到点$(X(j),Y(j))$的直线斜率。这里我们简单记$g(k,j)=\frac{Y(j)-Y(k)}{X(j)-X(k)}$。

注意我们两个公式是以等价的方式推导出来的，即$r(j,i)\leq r(k,i)$当且仅当$g(k,j)\leq s(i)$成立。

假设存在三个点$t<k<j<i$，且$g(t,k)\geq g(k,j)$，那么我们可以发现，如果$r(k,i)\leq r(t,i)$，这意味着$g(t,k)\leq s(i)$，但是考虑到$g(k,j) \leq g(t,k)$，因此可知$g(k,j)\leq s(i)$，从而推出$r(j,i) \leq r(k,i)$。换言之，$f(i)$永远拥有比$r(k,i)$更好的选择，因此我们可以在计算$f(i)$时不考虑$f(k)$。

由于之前推出的结论，我们发现真正需要被考虑的点$(X(i_1),Y(i_1)),(X(i_2),Y(i_2)),\ldots$，其必然有斜率递增的特性，即$g(i_{m-1},i_{m})\leq g(i_{m},i_{m+1})$。因此我们只需要利用一个双端队列维护一个斜率递增的点集，考虑到$s(i)$严格增的性质，我们就可以在$O(n)$的时间复杂度内计算$f(1),\ldots ,f(n)$。

# ARC078D

**题意**

[https://arc078.contest.atcoder.jp/tasks/arc078_d](https://arc078.contest.atcoder.jp/tasks/arc078_d)

**题解**

定义cost(S,T)表示V的子集S和T，所有两端点分别处于S和T的边的权重之和。

定义dp(S,t)表示，包含顶点1的子集S，仅考虑S和{t}中的并集中的顶点，从顶点1到t存在唯一路径的最小成本。

之后考虑到最终结果中仅存在唯一的从1到n的路径，因此我们可以不断枚举路径上最后一个顶点，倒数第二个顶点，从而获得最小费用。

我的做法的时间复杂度是$O(3^nn^2)$，不太明白官方的$O(3^nn)$是怎么做大的。

# 动态规划求和问题

考虑有这样一个$n\times m$的矩阵$M$，$1\leq n,m \leq 3000$。矩阵$M$代表一个迷宫，$M_{ij}$为1表示该处不可通行，为0表示该处可通行。玩家只能每次向右或向下移动一格。

迷宫的出口和入口信息现在还不确定，每个为0的位置都有可能为入口和出口。

记$f(i,j,u,v)$表示入口为$(i,j)$，出口为$(u,v)$时，有多少可能的从入口到出口的轨迹，现在我们希望求：

$$
\sum_{M_{i,j}=0}\sum_{M_{u,v}=0}f(i,j,u,v)
$$

一般的动态规划每趟可以给出$O(nm)$的时间复杂度，但是由于总共要执行$O(nm)$次，因此总的时间复杂度将达到$O(n^2m^2)$。

我们考虑进行优化，实际上观察正常的动态规划递推公式：

$$
dp(i,j)=dp(i-1,j)+dp(i,j-1)
$$

我们可以发现，对于不管入口和出口怎么变换，递推关系都是不会改变的。并且还有最重要的一点，就是递推关系是线性的。

现在我们定义$dp_{i,j}$为当我们选择$(i,j)$作为入口的动态规划公式。这时候我们再定义一个新的函数:

$$
g=\sum_{M_{i,j}=0}dp_{i,j}
$$

那么我们实际上要求的是：

$$
\sum_{M_{i,j}=0}\sum_{M_{u,v}=0}f(i,j,u,v)\\
=\sum_{M_{i,j}=0}\sum_{M_{u,v}=0}dp_{i,j}(u,v)\\
=\sum_{M_{u,v}=0}\sum_{M_{i,j}=0}dp_{i,j}(u,v)\\
=\sum_{M_{u,v}=0}g(u,v)
$$

下面我们证明$g$也满足递推关系$g(i,j)=g(i-1,j)+g(i,j-1)$。

$$
g(i,j)=\sum_{M_{i,j}=0}dp_{i,j}(i,j)\\
=\sum_{M_{i,j}=0}[dp_{i,j}(i-1,j)+dp_{i,j}(i,j-1)]\\
=\sum_{M_{i,j}=0}dp_{i,j}(i-1,j)+\sum_{M_{i,j}=0}dp_{i,j}(i,j-1)\\
=g(i-1,j)+g(i,j-1)
$$

新的算法的时间复杂度为$O(nm)$。

所以以后遇到这种多个动态规划，但是每个动态规划除了初始状态不同外，递推关系一致，并且我们最终要对其进行求和的问题，我们都可以用这种方式进行加速。

# AGC032D Rotation Sort

**题意**

[https://atcoder.jp/contests/agc032/tasks/agc032_d](https://atcoder.jp/contests/agc032/tasks/agc032_d)

**题解**

首先左旋和右旋可以理解为将一个数值前移和后移。

之后我们可以建立一个DP公式，记$f(i,j)$表示将前i个数按大小排序，且最大的k个数经历了后移过程。

那么考虑一个状态$f(i,j)$以及它的转移。考虑数$a_{i+1}$，假设$a_1,a_2,\ldots,a_i$中有$r$个数比它大，那么要将前$i+1$个数安排成有序，我们需要要么将$a_{i+1}$进行一次左移，此时对应的转移目标为$f(i+1,min(r,j))$；或者$a_{i+1}$不动，而比它大的$r$个数右移，这种情况的转移目标$f(i+1,r)$，前提条件是$j\geq r$；或者让$a_{i+1}$也右移，这时候的转移目标为$f(i+1,j+1)$，前提条件是$j\geq r$。

这样我们只需要$O(n^2)$的时间和空间复杂度就可以解决整个问题了。

# LIS问题

**动态规划解决LIS问题**

**给定一个序列$a_1,a_2,\ldots, a_n$，找出其中最长的一段子串$b_1,b_2,\ldots, b_k$，使得该子串严格递增。**

这个问题的解决方法非常多，比如说用动态规划，定义$dp(i)$表示以第$a_i$结尾的子串中最长的子串长度，那么很显然有递推公式：

$$
dp(i)=\max_{j<i\land a_j<a_i}dp(j)
$$

这个转移可以用线段树进行优化，优化后的时间复杂度为$O(n\log_2n)$。

讲另外一种二分的做法。定义$f_i(j)$表示仅考虑序列前$i$个元素，所有长度为$j$的递增子序列的最后一个元素的最小值。

很显然必定有$f_i(j)\geq f_i(j-1)$，$f_i(j)\geq f_{i-1}(j)$。因为存在长度为$j$的子序列，删除其中任意一个元素，一定可以得到另外一个长度为$j-1$的子序列。

因此，考虑第$i$个数$a_i$的时候，我们需要找到最大的$j$满足，$f_{i-1}(j)<a_i$，由于$f_{i-1}$是递增函数，因此二分是适用的。我们可以保证$f_i(j+1)=a_i$，而对于其余的值$t\neq j+1$，一定有$f_i(t)=f_{i-1}(t)$。因为假如$f_i(j+1)$小于$a_i$，那么一定有$f_{i-1}(j+1)=f_i(j+1)<a_i$，这与之前$j$最大相悖。

## 最长递增子序列和最小递减序列划分

如果我们可以将序列划分为若干个子序列，每个子序列都严格递减，那么称这是一个递减序列划分。所有递减序列划分中，划分的子序列最少的称为最小递减序列划分。

**定理：一个序列的最长递增子序列长度等于该序列的最小递减序列划分大小**

首先我们建立$dp\[i\]$，表示所有长度为i的序列的最小末端元素，很显然在用二分法优化DP的时候$dp\[i\]$是不断递减的，而有意义的$dp$仅为$dp\[1\],dp\[2\],\ldots,dp\[m\]$，其中m是LIS的长度。因此我们可以记录每个$dp\[i\]$，就可以得到一个递减子序列，这些$m$个子序列构成了原来序列的一个划分。

这样我们就证明了划分的存在，现在我们证明不可能存在更小的划分。实际上，考虑一个LIS对应的序列$b_1,b_2,\ldots, b_m$，容易发现任意两个元素不能处于同一个递减子序列中，因此递减子序列数至少为$m$。

**引理：一个序列的最长递减子序列长度等于该序列的最小递增序列划分**

## 置换的递增/递减子序列分解

对于$1,2,\ldots, n$的所有置换，我们希望将序列分解为最少的一些子序列，要求这些子序列满足递增或递减性质（分解的不同子串可以分别满足递增和递减）。考虑$1,2,\ldots,n$的所有置换，它们中最小分解的最大值$f(n)$是多少。

可以证明这个值是最小的正整数$k$，满足$\frac{k(k+1)}{2}\geq n$。

用归纳法证明，当$n=1$的时候，$k=1$，命题一定成立。

考虑任意$n$，假设其LIS长度大于等于$k$，那么我们就可以从中提取出LIS作为一个划分的一部分，于是最少划分数量为$f(n-k)+1$，此时有$\frac{k(k+1)}{2}\geq n\Rightarrow \frac{k(k-1)}{2}\geq n-k$。因此$f(n-k)=k-1$，故$f(n)=k$。

那么如果LIS长度小于等于$k$呢，由于最小递减子序列划分数等于最长递增子序列长度，因此我们可以正好将整个序列划分为$k$个递减子序列。

# ARC073D

**题意**

[https://atcoder.jp/contests/arc073/tasks/arc073_d](https://atcoder.jp/contests/arc073/tasks/arc073_d)

**题解**

可以很简单地建立动态规划公式：`dp[k][i][j]`表示处理完k个请求后两个指针的位置分别为i、j的最小移动次数。

我们发现处理完第k个请求后其中一个指针一定是$x_k$，因此可以压缩一下动态规划`dp[k][i]`表示处理完k个请求后，一个指针为$x_k$，另外一个指针为i的最小移动次数。

处理第k个请求的时候，有两种行为：

第一种，位置为$x_{k-1}$的指针移动到$x_k$处，此时，`dp[k][i]=dp[k-1][i]+abs(x[k]-x[k-1])`。

第二种，从位置不为$x_{k-1}$的指针移动到$x_k$处，此时，我们只需要特殊处理`dp[k][x[k-1]]`即可。

我们可以维护一株线段树，在线段树上做转移即可。时间复杂度为$O(q\log_2n)$。

# 二维网格统计有效路径数问题

**给定一个n行m列二维网格，我们从左上角(1,1)出发，到右下角(n,m)去。每次移动我们只能往下或往右移动一格。有一些格子存在石头（无法通过）。问从起点到终点有多少种走法，其中$n,m\leq 1000$**

比较简单的动态规划问题，直接定义$dp(i,j)$表示从起点到(i,j)的不停走法数。很显然$dp(i,j)=dp(i-1,j)+dp(i,j-1)$。时间复杂度为$O(nm)$。

**给定一个n行m列二维网格，我们从左上角(1,1)出发，到右下角(n,m)去。每次移动我们只能往下或往右移动一格。问从起点到终点有多少种走法，其中$n,m\leq 100000$**

我们不能继续傻傻用动态规划了，但是很容易发现，每一次路径实际上对应的是一个长度为n+m-1的01序列（0表示右移，1表示下移），其中0的数目为m-1。因此可以直接用组合数表示${n+m-1\choose m-1}$。

**给定一个n行m列二维网格，我们从左上角(1,1)出发，到右下角(n,m)去。每次移动我们只能往下或往右移动一格。有k个格子存在石头（无法通过）。问从起点到终点有多少种走法，其中$n,m\leq 100000$，$k\leq 5000$**

事实上，这是一个atcoder的[问题](https://atcoder.jp/contests/dp/tasks/dp_y)。这个问题与前一个问题的不同之处在于有一些通过石头的路径是无效的（不应该被统计）。我们可以用容斥来排除。但是容斥的时间复杂度是$O(2^k)$啊。实则不然，我们会发现很多容斥选择都是无效的。同时容斥真正有价值的只有其选择石头数目的奇偶性。因此我们可以用DP来表示，我们记$dp(i,j)$表示选择第i个石头作为最靠近右下角的石头，同时总的选择石头数模2的结果为$j$，有多少路径满足这样的条件。这样我们就可以通过枚举前一个状态，递推出$dp(i,j)$的结果。总的时间复杂度为$O(\max(n,m)+k^2)$。

# 超大背包DP

大家先看看这道[题目](https://codeforces.com/contest/1132/problem/E)。

这个题目很明显是一个背包，但是背包的容量超大，没法直接DP。

但是我们发现1到8这8个数的最大公倍数仅为840。这意味着对于最优结果，第i个数被选择了$c_i$个，那么$c_i=\frac{840}{i}\cdot a_i+b_i$，其中$b_i< \frac{840}{i}$。

我们发现取$840/i$个$i$的和都是$840$，我们可以把这些值做一致处理，简单称为单元。考虑不由单元组成的部分$\sum_{i=1}^8ic_i$，其一定不超过$840\cdot 8$，也就是说我们可以对这一部分进行DP，$dp(i)$表示取一些数总和为$i$的前提下，最多能保留多少单元。显然单元越多能组成的数范围越大。

最后暴力枚举结果中不能由单元提供的额外部分，同时判断最优解即可。

# Codeforces1117F

**题意**

[https://codeforces.com/problemset/problem/1117/F](https://codeforces.com/problemset/problem/1117/F)

**题解**

很容易想到这是一个位压DP，但是如何判断一个删除策略是否合法呢，这是需要解决的问题。

我们为每个序列中的字符，维护两个列表prev、next。`prev[i]`存储第i个字符之前最近的k种字符的出现顺序，而`next[i]`存储第i个字符之后最近的k种字符的出现顺序。

接着我们考虑所有的字符。假设处理到的字符为u，且u之前存在某个字符v与其不能相邻，那么记s为u与v之间的字符对应的二进制位的或。那么我们需要对s以及所有父集打一个+1标记，同时由于如果u、v中有一个已经被删除了，那么就不会冲突，我们对`s|(1<<u)`和`s|(1<<v)`分别打一个-1标记。而由于`s|(1<<u)|(1<<v)`以及所有父集被多打了一次-1标记，因此我们在上面打一个`+1`标记。如果一个删除状态被打的+1标记多于-1标记，那么这个状态是非法的。

最后问题来了，如何上推标记，很简单用FWT即可。

总的时间复杂度为$O(pn+p2^p)$。

# Codeforces1107F

**题意**

[https://codeforces.com/contest/1107/problem/F](https://codeforces.com/contest/1107/problem/F)

**题解**

首先容易想到最小费用最大流的做法，但是它是$O(n^3)$的。

我们可以将接受的offer分成两类，第一类是我们在买车之前不能还完的，第二类是我们在买车之前能还完的。

仅考虑第一类，我们会发现按照$b_i$从小到大排序后，我们依次进行贷款所需费用最小，而选择的顺序对于第二类是不重要的。因此我们可以进行DP，记$dp(i,j)$表示仅考虑$b_i$从大到小排序前面$i$个offer，总共有$j$个是属于第一类的，问最多能赚多少钱。之后动态规划即可，总的时间复杂度为$O(n^2)$。

# Codeforces1093F

**题意**

[https://codeforces.com/contest/1093/problem/F](https://codeforces.com/contest/1093/problem/F)

**题解**

初看比较奇怪的问题。很显然得用DP。

记录`dp[i][j][k]`表示处理前$i$个字符后，最后一个字符为$j$，最后一个字符已经连续出现了$k$次了。

那么很容易推出转移公式，但是状态有$n^2k$种，很显然过不了。但是仔细观察递推项，会发现`dp[i][j][k]`和`dp[i-1][j][k-1]`完全相同。因此如果我们把状态数组搞成可旋转的，就可以以$O(k)$的时间复杂度从`dp[i-1]`直接得出`dp[i]`。这样总的时间复杂度和空间复杂度都为$O(nk)$。

这种做法比较取巧。个人认为官方的做法比较好，官方的做法定义`dp[i][j]`表示处理完了前$i$个字符后，最后一个字符为`j`的所有有效方案数。

于是可以直接得出$dp\[i\]\[j\]=\sum_{t=1}^k dp\[i-1\]\[t\]$。但是这个公式有一个问题，没有考虑子段不能连续出现$len$个相同字符。这里唯一的一种情况是最后一个字符与前面$len-1$个字符完全相同。我们要减去这些非法状态，非法状态的数目为$\sum_{t=1}^k\[t\neq j\]dp\[i-len\]\[t\]$。

# WQS二分

考虑有$n$个物品，物品$i$的权重为$w_i$。我们需要从中正好选择$k$件物品，要求取出的物品总权重最大。

当然这个大家都知道可以用贪心算法解决。只要取权重最大的$k$件物品即可。但是这里要讲一下动态规划的求法。

我们可以定义$dp(i,j)$表示从前$i$件物品中取出$j$件，可以得到的最大权重。这样就可以得出递推公式：$dp(i,j)=\max(dp(i-1,j-1)+w_i, dp(i-1,j))$。

但是这样的写法是$O(n^2)$的，能不能更加快一些呢。我们会发现如果可以取任意件的时候，我们就可以将动态规划公式优化为$f(i)$，表示从前$i$件物品中最大能取出的权重，那么有$f(i)=\max(f(i-1),f(i-1)+w_i)$。这时候动态规划求法和贪心的速度是一样的。

这里要说一下WQS二分。记录$g(i)$表示从$n$件物品中仅能取$i$件物品时的最大总权，且满足$g(i)-g(i-1)\geq g(i+1)-g(i)$，即$g$的曲线是上凸的，那么我们就可以用一些斜线去切这个上凸包，从而得到凸包上每个顶点的信息。

做法就是我们为选择每个商品时都赋予一定的惩罚$c$（即用来切凸包的直线的斜率），很显然惩罚越大，我们最优解时进行的选择就会越少。因此我们可以二分惩罚，来得到恰好选择$k$次的结果$r$，我们可以将$r$加上$kc$就可以得到真正的结果了。（我们仅需二分斜率而不需要考虑直线在y轴上的截距，因为截距仅相当于在最终解上加上固定的常数，这不会影响不同解之间的比较关系）

这里需要注意的是不一定能正好二分到$k$次，比如所有物品的权重都相同，那么无论惩罚如何选择，要么一件不选，要么都选。但是这时候我们会发现多选带来的收益（在考虑惩罚的情况下）一定是0，因此我们可以不用在乎多选的情况，只要在最终结果仅加上$kc$（最后加上的数与最优解的时候实际选择的商品数无关，比如这里即使选择了$n$件商品，也仅加上$kc$而非$nc$）即可。

一道不错的[例题](https://www.luogu.com.cn/problem/P5308)。