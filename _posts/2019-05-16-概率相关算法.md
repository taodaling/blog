---
categories: algorithm
layout: post
---

- Table
{:toc}

# 期望的状态转移

考虑一个期望问题，我们从0向n出发，每一秒都向前等概率移动距离1，2（如果当前位置与n距离为1，则只能移动距离1）。问从0到n所需时间的期望值。

我们可以用f(i)表示从i到n所需步数的期望，利用期望的状态转移，可以得出：


$$
f(i)=\frac{1}{2}(f(i+1)+f(i+2))+1。
$$


之后我们可以以$O(n)$的时间复杂度计算结果。

# 带原地踏步的状态转移

之前讨论的期望的状态转移是带拓扑序的，因此我们可以很容易计算。现在稍微改变一下，我们现在每秒等概率移动0，1，2距离。这时候我们的函数就出现了自依赖。


$$
f(i)=\frac{1}{3}(f(i)+f(i+1)+f(i+2))+1
$$


我们可以将右边的\frac{1}{3}f(i)移动到左边进行计算。


$$
\frac{2}{3}f(i)=\frac{1}{3}(f(i+1)+f(i+2))+1\\
\Rightarrow f(i)=\frac{1}{2}(f(i+1)+f(i+2))+\frac{3}{2}
$$


之后就是简单的动态规划了。

# 带环的状态转移

修改问题，现在我们每秒有60%的几率向前走一步，40%的几率向后走一步，不允许离开$\[0,n\]$。问移动到n的期望步数。

这时候我们的公式为：



$$
f(i)=0.4f(i-1)+0.6f(i+1)+1
$$



要计算$f(i)$，我们必须先得知$f(i-1)$和$f(i+1)$，而要计算$f(i-1)$和$f(i+1)$，我们必须先得知$f(i)$，这就是先有鸡还是先有蛋的问题，陷入了死循环。

那么是否就无法计算期望呢。我们首先需要相信，期望一定是存在并且是不变的（即期望是唯一的）。之后我们可以推出一组公式：



$$
\left\{ 
\begin{array}{rcl}
f(0) & = & f(1)+1\\
f(1) & = & 0.4f(0)+0.6f(2)+1\\
...\\
f(n-1)&=&0.4f(n-2)+0.6f(n)+1\\
f(n)&=&0
\end{array} 
\right.
$$



对其稍作转换可以得到：

$$
\left\{ 
\begin{array}{lcr}
f(0) - f(1) & = &1\\
f(1) -0.4f(0)-0.6f(2) & = & 1\\
...\\
f(n-1)-0.4f(n-2)-0.6f(n)&=&1\\
f(n)&=&0
\end{array} 
\right.
$$

我们可以把其表示为矩阵和向量的乘积：



$$
\left(
\begin{array}{ccc}
1&-1 &0 & \dots&0 &0&0\\
-0.4&1&-0.6&\ldots&0&0&0\\
\ldots&\ldots&\ldots&\ldots&\ldots&\ldots&\ldots\\
0&0&0&\ldots&-0.4&1&-0.6\\
0&0&0&\ldots&0&0&1\\
\end{array}
\right)
\left(
\begin{array}{ccc}
f(0)\\
f(1)\\
\ldots\\
f(n-1)\\
f(n)
\end{array}
\right)
=
\left(
\begin{array}{ccc}
1\\
1\\
\ldots\\
1\\
0
\end{array}
\right)
$$



我们可以简单记为$Ax=y$。由于之前已经说过期望是唯一不变的，因此矩阵的秩一定为$n+1$，否则就会有多个解。我们可以对矩阵$A$取逆后将式子转换为$x=A^{-1}y$。这样就可以计算出期望序列$x$。



这样我们就能在时间复杂度$O(n^3)$内求解。



# 概率转期望

之前考虑的问题中，讨论概率是没有意义的，因为在足够多的时间过去后，我们一定会达到n，即概率为1。下面我们要讨论既有存在失败情况下游戏的胜利概率。

考虑这样一个问题，我们从1出发，如果到达n我们就获得胜利，游戏结束，如果到达0，我们就失败，游戏结束。问胜利的概率为多少。

如果我们对概率进行转移，我们会发现完全无法解决，比如抵达n的概率，显然与抵达n-1的概率相关，从而可以推出和抵达1的概率有关。那么我们抵达1的概率是多少？100%，还是其它。如果我们认为是100%，就会发现如果我们从2回到1，抵达1的概率就会超出100%，这显然是有问题的。

我们可以定义一个随机变量X，X取的是实验中我们处于位置n的次数。由于X只有两种取值0，1，那么我们可以推出


$$
E(X)=1\cdot p(X=1)+0\cdot p(X=0)=p(X=1)
$$



而$p(X=1)$实际上就是游戏胜利的概率，因此我们可以通过计算$E(X)$得到$p(X=1)$。

而期望的公式怎么建立我们之前就讨论过了，需要注意的是，不可能从$f(0)$和$f(n)$再次进行转移，以及初始时我们处于位置1，因此$f(1)=0.4f(2)+1$。而对于其余值，应该为



$$
f(i)=0.4f(i+1)-0.6f(i-1)
$$

# 随机递增序列

假设有n个未知整数，我们需要$O(C)$的时间复杂度比较一个未知整数和一个已知整数的大小关系，但是要知道某个整数的真实值需要$O(H)$的时间复杂度，而$H$远远大于$C$，可以认为
$$
H\geq C\log_2n
$$
。现在我们想找到这n个整数中最大整数的值。

当然，我们可以直接查询所有未知整数的值，得到最终结果，时间复杂度为$O(nH)$。

我们现在希望能减少时间复杂度。

有一种显然正确的策略，先取第一个数，查出其真实值，作为持有数。之后遍历后面的数，如果这个数比持有数大，将持有数替换为该数。重复这个过程，自然就能找到最大值了，其最坏时间复杂度为$O(n(C+H))=O(nH)$

注意到时间上界是来自于替换的发生，但是事实上，替换不会真的发生n次。如我们对原始的数组进行打乱，我们可以证明一个非常优秀的时间复杂度。

记
$$
f(i)
$$
表示已经检查过$i$个数，后面检查$n-i$个数会发生替换操作次数的期望。那么考虑一个新的数$x$，只有当$x$比我们之前检查过的$i$个数都大的情况下，才会发生替换。因此可以推出期望公式：



$$
f(i)=\frac{1}{i+1}(f(i+1)+1)+\frac{i}{i+1}f(i+1)\\
=f(i+1)+\frac{1}{i+1}
$$



我们要求的是$f(0)$，即检查$n$个数发生的替换总次数的期望，可以推出：


$$
f(0)=f(1)+\frac{1}{1}\\
=f(2)+\frac{1}{1}+\frac{1}{2}\\
\ldots\\
=f(n)+\sum_{i=1}^n\frac{1}{i}\\
=\sum_{i=1}^n\frac{1}{i}\\
\approx \ln n
$$


因此期望的时间复杂度为
$$
O(nC+H\ln n)
$$
。

这是非常优秀的时间复杂度。

## 例子1

可以考虑这样一个问题，我们现在有1000份简历，我们需要面试1000个人，并从中找出能力最优秀的候选人。

面试能帮助我们了解应聘人是否比我们已经招募的那个人（通过了试用期）更加优秀。我们可以邀请一个人参加试用，在试用期结束后，我们就能得到这个人的真实能力。

由于岗位有限，同时最多只能有一个人处于试用期。面试一个人，需要一个小时，试用期则长达1个月。问我们最少需要多少时间才能找到最优秀的人。

假如我们每个人都邀请参加试用，那么会需要1000个月，要面到大家都退休。或者我们使用贪心策略，却不保证随机（比如HR按自己的观感将候选人从差到优进行排序），也可能会需要1000个月。

现在我们随机打乱所有的简历，并采用贪心策略，那么我们的所需的期望时间仅仅为1000个小时加上10个月，估摸是一年内可以结束。

# CF1172C

**题意**

[https://codeforces.com/contest/1172/problem/C2](https://codeforces.com/contest/1172/problem/C2)

**题解**

记f(w,i,j,k)表示初始权值为w的喜欢的图片经过k次操作后的期望权值，其中喜欢的图片权值之和为i，讨厌的图片权值之和为j。

可以推出公式：


$$
f(w,i,j,k)=\frac{w}{i+j}f(w+1,i+1,j,k-1)\\
+\frac{i-w}{i+j}f(w,i+1,j,k-1)\\
+\frac{j}{i+j}f(w,i,j-1,k-1)
$$


很显然状态过多了。但是可以证明$f(w,i,j,k)=wf(1,i,j,k)$，因此我们只需要计算形如f(1,i,j,k)的函数值。并且当i和k确认时，j也随之确认。因此我们可以将公式变为$f'(i,k)$。总共有$O(m^2)$种状态。



# ZOJ3754

一眼就可以看出是需要求期望步数，由于有环，因此需要矩阵运算。但是事实上，这样会TLE的。

我们可以简单推出递推公式：


$$
f(i)=p_0f(0)+\sum_{j=3}p_jf(i+j)+1
$$


上面f(i)表示当前值为i时，期望结束的步骤数。

很显然，当f(0)已知的情况下，上面的所有公式都是可以直接推出的，即不再存在循环依赖了。因此所有的f(i)都可以表示为关于f(0)的一阶多项式：


$$
f(i)=a_if(0)+b_i
$$


代入到之前的公式中，有：


$$
f(i)=p_0f(0)+\sum_{j=3}p_jf(i+j)+1\\
=p_0f(0)+\sum_{j=3}p_j(a_{i+j}f(0)+b_{i+j})+1\\
=f(0)(p_0+\sum_{j=3}p_ja_{i+j})+(1+\sum_{j=3}p_jb_{i+j})
$$


我们可以直接得到$a_i=p_0+\sum_{j=3}p_ja_{i+j}$，而$b_i=1+\sum_{j=3}p_jb_{i+j}$，而这里的递推公式是没有环的。直接求解即可。而$f(0)=\frac{b_i}{1-a_i}$。

# HDU4035

**题意**

[http://acm.hdu.edu.cn/showproblem.php?pid=4035](http://acm.hdu.edu.cn/showproblem.php?pid=4035)

**题解**

由于给的图是一株树，因此有特殊的优化技巧，如果不是树，这数据量肯定过不了。

记f(i)表示从第i个结点出发到离开的期望步数。很显然：


$$
f(i)=E_i\cdot 0 + K_i\cdot f(1)+(1-E_i-E_j)\frac{1}{|E|}\sum_{(i,j)\in E}(f(j)+1)
$$


下面说一下优化。挑选合适的$a_i$和$b_i$使得下面等式对所有i成立：


$$
f(i)=a_if(1)+b_i
$$


简化第一个等式可以得到：


$$
f(i)=K_i\cdot f(1)+(1-E_i-E_j)\frac{1}{|E|}\sum_{(i,j)\in E}(f(j)+1)\\
=(K_i+(1-E_i-E_j)\frac{1}{|E|}\sum_{(i,j)\in E}a_j)f(1)\\
+(1-E_i-E_j)\frac{1}{|E|}\sum_{(i,j)\in E}(b_j+1)
$$


那么可以得到$a_i$和$b_i$的递推公式


$$
a_i=K_i+(1-E_i-E_j)\frac{1}{|E|}\sum_{(i,j)\in E}a_j\\
b_i=(1-E_i-E_j)\frac{1}{|E|}\sum_{(i,j)\in E}(b_j+1
$$


由于递推公式有环，因此还是不可解。这里我们注意到，我们可以将等式进一步处理，这里以$a_i$为例：


$$
a_i=K_i+(1-E_i-E_j)\frac{1}{|E|}\sum_{(i,j)\in E}a_j\\
=K_i+(1-E_i-E_j)\frac{1}{|E|}(\sum_{(i,j)\in E\land j\neq father(i)}a_j+a_{father(i)})
$$


我们先处理叶子结点，之后逐层向上处理。很显然由于需要知道$a_{father(i)}$，每一个$a_i$都无法正常计算得到。但是当我们处理$a_{father(i)}$的时候，我们可以通过左移消除掉从孩子中带来的关于自己的部分，同时增加自己父亲的部分。而对于$a_1$，由于没有父亲，因此我们可以认为$a_{father(1)}=0$，代入就可以求出$a_1$。

对于b做同样处理即可。

# LUOGU3175

**题意**

[https://www.luogu.org/problem/P3175](https://www.luogu.org/problem/P3175)

**题解**

对于一次实验，记录$X_i$表示第i为第一次变作1的时间。记$X=(X_1,X_2,\ldots, X_n)$，那么实际上数字变作$2^n-1$的时间实际上是
$$
\max\{X\}
$$
。但是要计算这东西不太容易，我们用min-max容斥将问题转换为下面形式：


$$
\max\{X\}=\sum_{T\subseteq X}(-1)^{|T|+1}\min\{T\}
$$


其中
$$
\min\{T\}
$$
指的是T指代的二进制集合第一次改变的时间。之后利用期望的线性性质：


$$
E[\max\{X\}]\\
=E[\sum_{T\subseteq X}(-1)^{|T|+1}\min\{T\}]\\
=\sum_{T\subseteq X}(-1)^{|T|+1}E[\min\{T\}]
$$


其中
$$
E[\min\{T\}]
$$
的计算方式如下，首先设T代表的二进制掩码为m，那么这相当于问在若干次投掷硬币实验中，每次正面概率为p，求第一次投掷出硬币的期望次数。这是几何分布，因此期望时间为$1/p$。

下面考虑p该如何计算，要计算p，我们通过计算$q=1-p$得到。q等于所有$2^n-1-m$子集的概率之和。而什么时候无解呢，假如某个二进制的所有超级的概率之和为0，则无解。

这边计算子集和，超级和可以通过FWT算法得到。

总的时间复杂度为$O(2^nn)$。

# LOJ2542

**题意**

[https://loj.ac/problem/2542](https://loj.ac/problem/2542)

**题解**

对于一次实验，记随机变量$X_i$表示顶点i第一次被访问时间。记
$$
X=\{X_1,X_2,\ldots, X_n\}
$$
。那么对于任意$X$的子集$S$，要计算全部顶点都被访问至少一次的时间，应该是：
$$
\max\{S\}
$$
利用min-max容斥，化作如下形式:


$$
\max\{S\}=\sum_{T\subseteq S}(-1)^{|T|+1}\min\{T\}
$$


之后利用期望的线性性质得到：


$$
E[\max\{S\}]\\
=E[\sum_{T\subseteq S}(-1)^{|T|+1}\min\{T\}]\\
=\sum_{T\subseteq S}(-1)^{|T|+1}E[\min\{T\}]
$$


其中
$$
\min\{T\}
$$
是集合中的顶点第一次被访问的时间。

之后假设我们预先计算出了对于所有$X$的子集的首次访问时间期望，之后对于询问总共时间不会超过：
$$
O(3^n)
$$
。现在讨论如何预先计算所有子集的首次访问时间，我们可以利用可以用高斯消元在$O(n^3)$时间复杂度内计算一个子集的首次访问时间，但是这样会超时。我们需要利用树提供的拓扑无环性质，利用一次DFS直接得出期望$O(n\log_2n)$，其中$\log$的存在是因为需要计算逆元。

这样总的时间复杂度为：
$$
O(3^n+2^nn\log_2n)
$$
。马马虎虎，可以过。

