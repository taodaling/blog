---
categories: algorithm
layout: post
---

- Table
{:toc}

# 随机递增序列

假设有n个未知整数，我们需要$O(C)$的时间复杂度比较一个未知整数和一个已知整数的大小关系，但是要知道某个整数的真实值需要$O(H)$的时间复杂度，而$H$远远大于$C$，可以认为

$$
H\geq C\log_2n
$$

现在我们想找到这n个整数中最大整数的值。

当然，我们可以直接查询所有未知整数的值，得到最终结果，时间复杂度为$O(nH)$。

我们现在希望能减少时间复杂度。

有一种显然正确的策略，先取第一个数，查出其真实值，作为持有数。之后遍历后面的数，如果这个数比持有数大，将持有数替换为该数。重复这个过程，自然就能找到最大值了，其最坏时间复杂度为$O(n(C+H))=O(nH)$

注意到时间上界是来自于替换的发生，但是事实上，替换不会真的发生n次。如我们对原始的数组进行打乱，我们可以证明一个非常优秀的时间复杂度。

记$f(i)$表示已经检查过$i$个数，后面检查$n-i$个数会发生替换操作次数的期望。那么考虑一个新的数$x$，只有当$x$比我们之前检查过的$i$个数都大的情况下，才会发生替换。因此可以推出期望公式：

$$
f(i)=\frac{1}{i+1}(f(i+1)+1)+\frac{i}{i+1}f(i+1)\\
=f(i+1)+\frac{1}{i+1}
$$

我们要求的是$f(0)$，即检查$n$个数发生的替换总次数的期望，可以推出：

$$
f(0)=f(1)+\frac{1}{1}\\
=f(2)+\frac{1}{1}+\frac{1}{2}\\
\ldots\\
=f(n)+\sum_{i=1}^n\frac{1}{i}\\
=\sum_{i=1}^n\frac{1}{i}\\
\approx \ln n
$$

因此期望的时间复杂度为$O(nC+H\ln n)$

这是非常优秀的时间复杂度。

## 例子1

可以考虑这样一个问题，我们现在有1000份简历，我们需要面试1000个人，并从中找出能力最优秀的候选人。

面试能帮助我们了解应聘人是否比我们已经招募的那个人（通过了试用期）更加优秀。我们可以邀请一个人参加试用，在试用期结束后，我们就能得到这个人的真实能力。

由于岗位有限，同时最多只能有一个人处于试用期。面试一个人，需要一个小时，试用期则长达1个月。问我们最少需要多少时间才能找到最优秀的人。

假如我们每个人都邀请参加试用，那么会需要1000个月，要面到大家都退休。或者我们使用贪心策略，却不保证随机（比如HR按自己的观感将候选人从差到优进行排序），也可能会需要1000个月。

现在我们随机打乱所有的简历，并采用贪心策略，那么我们的所需的期望时间仅仅为1000个小时加上10个月，估摸是一年内可以结束。

# 一些期望计算问题

**问题1：给定n个石头，其处于一条直线上，从左到右的下标分别为$x_1,x_2,\ldots,x_n$，满足$x_1<x_2<\ldots<x_n$。现在我们每次要等概率挑选一个石头（不能选最靠右的那个），将这个石头右移直到碰撞到右边第一个石头，如果碰撞了，那么两个石头就合成了一块石头。重复上面的操作$n-1$次，问所有石头移动的总距离的期望是多少？**

考虑到期望的线性性质，我们可以独立计算第$i$个石头被选择后移动的总距离$d_i$，之后我们要求的就是$E(\sum_{i=1}^{n-1}d_i)=\sum_{i=1}^{n-1}E(d_i)$。考虑第$i$个石头，它停在$x_j$处的概率为$\frac{(j-i-1)!}{(j-i+1)!}$，特殊的停在$x_n$处的概率为$\frac{1}{n-i}$。利用这些性质我们就可以独立求出$E(d_i)$，加总就好了，这样我们的时间复杂度为$O(n^2)$。

但是这个问题实际上并不要求我们算出所有石头移动距离的期望，它要求的只是总期望而已。我们可以拆解$d_i$，记录$t_{i,j}$表示石头$i$在$x_{j-1}$与$x_j$之间通过距离的期望，那么$d_i=\sum_{j=i+1}^nt_{i,j}$。而我们知道$t_{i,j}$仅可能取两个值：$0$或$x_j-x_{j-1}$，其中$P(t_{i,j}=x_j-x_{j-1})=\frac{1}{j-i}$。因此我们重写我们要求的总距离的期望，可以得到：

$$
E(\sum_{i=1}^{n-1}d_i)\\
=E(\sum_{i=1}^{n-1}\sum_{j=i+1}^nt_{i,j})\\
=E(\sum_{j=2}^n\sum_{i=1}^{j-1}t_{i,j})\\
=\sum_{j=2}^n\sum_{i=1}^{j-1}E(t_{i,j})\\
=\sum_{j=2}^n\sum_{i=1}^{j-1}\frac{x_j-x_{j-1}}{j-i}\\
=\sum_{j=2}^n(x_j-x_{j-1})\sum_{i=1}^{j-1}\frac{1}{j-i}\\
=\sum_{j=2}^n(x_j-x_{j-1})\sum_{i=1}^{j-1}\frac{1}{i}\\
$$

注意到右边的$\sum_{i=1}^{j-1}\frac{1}{i}$我们可以线性时间内预处理出来，因此总的时间复杂度可以优化到$O(n)$。

# 一类乘积期望计算问题

**题目1：给定$n$个数，$a_1,\ldots,a_n$，以及另外一组未知变量$b_1,\ldots,b_n$，且已知$\sum_{i=1}^nb_i=m$，位置变量的每一个赋值方案都是等概率的（即总共${n+m-1\choose n-1}$种可能都是等概率的）。现在问$E\[\prod_{i=1}^n(a_i+b_i)\]$。其中$1\leq n,m\leq 10^5$。**

我们可以将期望公式展开开来，记$N=\{1,\ldots,n\}$，得到：

$$
E[\prod_{i=1}^n(a_i+b_i)]=E[\sum_{S\subseteq N}\prod_{i\notin S}a_i\prod_{i\in S}b_i]\\
=\sum_{S\subseteq N}\prod_{i\notin S}a_iE[\prod_{i\in S}b_i]
$$

注意到$E[\prod_{i\in S}b_i]$不取决与$S$，仅取决于$\|S\|$。我们可以记$f(k)=\sum_{S\subseteq N\land \|S\|=k}\prod_{i\in S}a_i$，这个可以通过生成函数在$O(n(\log_2n)^2)$时间复杂度内算出来。那么我们实际上要求的就是：

$$
\sum_{k=0}^nf(n-k)E[\prod_{i=1}^kb_i]
$$

而其中右边的期望公式可以进行化简（详细可以看我的另外一篇博客《组合数学》中的隔板法的问题1。）：

$$
E[\prod_{i=1}^kb_i]=\frac{ n+m-1\choose n+k-1 }{ n+m-1\choose n-1 } 
$$

因此结果为：

$$
\sum_{k=0}^nf(n-k)\frac{ n+m-1\choose n+k-1 }{ n+m-1\choose n-1 } 
$$

总的时间复杂度为$O(n+m+n(\log_2n)^2)$

提供一道题目：SRM763 ProductAndProduct。

**题目2：给定$n$个数，$a_1,\ldots,a_n$，之后我们随机执行$m$次独立操作，每次等概率选择一个下标$i$，并将$a_i$增加$1$。设最后得到的序列为$b_1,\ldots,b_n$，要求计算$E\[\prod_{i=1}^nb_i\]$。这里$1\leq n\leq 10^5,1\leq m\leq 10^9$。**

我们不能用题目1的方式解决这个问题，因为不同结果的概率是不同的。但是我们可以用生成函数来求解。生成函数NB。

我们要求的是：

$$
E[\prod_{i=1}^na_i+b_i]=\frac{m!}{n^m}\sum_{b_1+\ldots+b_n=m}\frac{1}{b_1!\ldots b_n!}\prod_{i=1}^n(a_i+b_i)
$$

它实际是多项式$f(x)=\frac{m!}{n^m}\prod_{i=1}^n\sum_{j\geq 0}\frac{(a_i+j)}{j!}x^j$的$x^m$的系数。下面我们来讨论多项式$f(x)$。考虑$\sum$中的项，通过泰勒展开公式进行化简：

$$
\sum_{j\geq 0}\frac{(a_i+j)}{j!}x^j=\sum_{j\geq 0}\frac{a_i}{j!}x^j+\sum_{j\geq 0}\frac{j}{j!}x^j=a_ie^x+xe^x
$$

带回到多项式中，得到：

$$
f(x)=\frac{m!}{n^m}\prod_{i=1}^n(a_ie^x+xe^x)\\
=\frac{m!}{n^m}e^{nx}\prod_{i=1}^n(a_i+x)
$$

我们可以利用多项式卷积在时间复杂度$O(n(\log_2n)^2)$时间内算出

$$
\prod_{i=1}^n(a_i+x)=\sum_{i=0}^nc_ix^i
$$

接下来我们展开$e^{nx}$：

$$
e^{nx}=\sum_{i\geq 0}\frac{n^i}{i!}x^i
$$

$f$肯定是算不了的，但是我们只需要求$f_m$就够了：

$$
f_m=\frac{m!}{n^m}\sum_{i+j=m}c_i\cdot \frac{n^j}{j!}\\
=\sum_{i+j=m}c_i\cdot \frac{(j+1)\cdot \ldots \cdot m}{n^{i}}
$$

上面这个问题可以在$O(n)$时间复杂度内求解。因此总的时间复杂度为$O(n(\log_2n)^2)$。

提供一道[题目](https://codeforces.com/contest/891/problem/E)。

# 循环概率递推

考虑一副连通图，我们在图上随机游走，图上有几个出口，问我们从各个出口离开的概率是多少。这个问题可以用马尔科夫链直接解决，建立一个概率矩阵，理论上保证了概率矩阵一定有逆，因此求逆后就可以求出从每个出口离开的概率了。这个方法适合用于图中顶点比较少的时候（比如顶点不超过$500$），因为上面的方法概率求逆的时间复杂度为$O(n^3)$。

还有一种比较经典的问题，就是有概率重置游戏状态的问题。假设有一个很长的走廊，可以分为$n+1$段，每段长度为1。从左到右记作$0,1,\ldots,n$。我们起始在第$0$段，每秒可以移动到下一段。在第$1$到$n-1$段，都有一个陷阱，陷阱一旦触发将会传送我们回到起点。第$i$段的陷阱触发概率为$p_i$，保证$0\leq p_i<1$。一旦我们抵达$n$段后就获得了胜利。问我们获得胜利的期望时间。可以记$E_i$表示处于第$i$段，胜利的期望时间，那么答案就是$E_0$。可以推出：$E_i=pE_0+(1-p)E_{i+1}+1$。可以发现这里也有循环递推，但是我们发现这里的递推公式是一个线性函数。我们将每个递推公式都表示为$E_i=a_iE_0+b_i$的形式，其中$0\leq a_i<1$。当然也就得到了$E_0=a_0E_0+b_0$，由于$0\leq a_0<1$，因此可以得出$E_0=\frac{b_0}{1-a_0}$。这里的过程可以$O(n)$完成。

最后再考虑一种也是概率重置游戏状态的问题。假设有一个游戏，我们需要在$R$秒内通关。游戏总共有$n$关（我们需要打过前一关才能打后一关），第$i$关我们以概率$p_i$在$F_i$秒内通过，以$1-p_i$的概率在$S_i$秒内通过，这里$F_i<S_i$，且$0<p_i<1$，满足$\sum_{i=1}^nF_i\leq R$。当然我们在通过每关后，可以选择进入下一关，或者重置游戏（游戏的计时恢复$0$），问我们要通关，花费的现实时间的期望是多少。这是一道[CF原题](https://codeforces.com/contest/865/problem/C)。

我们用DP的方式解决这个问题，定义$dp(i,j)$表示在第$i$关开始时，游戏计时为$j$，之后通关需要花费的现实时间的期望。那么可以推出转移公式：$dp(i,j)=\min(dp(1,0),p\cdot (dp(i+1,j+F_i)+F_i)+(1-p)(dp(i+1,j+S_i)+S_i))$。这个问题的难点就是$dp(i,j)$的递推公式中有一个$\min$函数，而非关于$dp(1,0)$的线性函数。那这玩意怎么做呢。

做法就是定义一个新的未知数$x$，记$dp_x(i,j)=\min(x,p\cdot (dp_x(i+1,j+F_i)+F_i)+(1-p)(dp_x(i+1,j+S_i)+S_i))$。记$f(x)=dp_x(1,0)$。可以发现$f$是个递增函数，且当$x=dp(1,0)$的时候，一定有$f(x)=x$。这就允许我们用二分来解决这个问题。事实上，$f$还满足当$x<dp(1,0)$时有$f(x)<x$，当$x>dp(1,0)$时有$f(x)>x$。整体的时间复杂度为$O(nR\log_2M)$，其中$M$是精度要求。

# 赌博破产问题

考虑你有$n$的本钱，你参加赌博，每轮有$p$的概率得到$1$单位钱，或以$1-p$的概率失去$1$单位钱。一旦你的钱为$0$或者达到你的预期值$S=n+m$，那么你就必须立即结束赌博，如果钱为$0$，就认为你赌博失败，否则认为赌博成功。

这个问题可以描述为一维空间中的随机游走问题，一开始我们处于点$n$，我们以$p$的概率往左移动，或者以$1-p$的概率往左移动一步。当我们抵达$S$或$0$时过程结束，到达$S$时获胜，到达$0$时失败。

现在我们考虑我们在结束时成功的概率（即移动到$S$）。记$f(i)$表示为手头有$i$本钱下成功的概率，容易发现$f(0)=0,f(S)=1$。

要计算$f(n)$，我们可以发现对于$0<i<S$，一定有$f(i)=pf(i+1)+(1-p)f(i-1)$。这为我们提供了一个递推式：

$$
f(i+1)=\frac{1}{1-p}(f(r)-pf(r-1))
$$

有递推式，但是我们还不知道$f(1)$。要计算$f(1)$，我们可以设其为$x$，则根据递推式将所有值都改写为$f(i)=a_ix+b_i$的形式，根据$a_{S}x+b_{S}=1$得出$x=\frac{1-b_S}{a_S}$。这个过程是线性的，但是如果我们发现$a_i$和$b_i$的计算时独立的，因此我们可以用矩阵快速幂的技术在$O(\log_2S)$时间复杂度内分别求出$a_S$和$b_S$。

一旦我们知道了$f(0)$与$f(1)$，我们就可以用快速幂在时间复杂度$O(\log_2n)$内求出任意一个$f(n)$。

这里特殊说一下，当$p=\frac{1}{2}$时，$f(i)=\frac{i}{S}$。

上面我们讨论了怎么计算退出时成功失败的概率，下面讲一下怎么计算退出前移动次数的期望，这里的推出可能是抵达$S$或$0$。记$g(i)$表示当前处于点$i$时，退出前期望移动次数。那么可以推出递推公式，那么特殊的$g(0)=g(S)=0$

$$
g(i)=pg(i+1)+(1-p)g(i-1)+1
$$

这玩意也是递推公式，我们可以用求$f(n)$相同的方式$O(\log_2S)$求$g(n)$。

最后说一下在已知结果为获胜的前提下，需要移动次数的期望，记$h(i)$表示处在位置$i$，已知获胜的前提下，需要移动次数的期望，那么$h(S)=0$，而$h(0)$是未定义的。有递推公式：

$$
h(i)=ph(i+1)+(1-p)h(i-1)+f(i)
$$

注意尾部的常数项时$f(i)$而非$1$，同时特殊的$h(1)=h(2)+f(1)$。(这个我也不知道什么原因，因为是有条件概率？)

提供几道题目：

- [https://codeforces.com/contest/850/problem/F](https://codeforces.com/contest/850/problem/F)

