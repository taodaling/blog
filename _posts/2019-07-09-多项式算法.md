---
categories: algorithm
layout: post
---

- Table
{:toc}
# 快速数论变换

了解快速傅里叶变换的人应该知道，快速傅里叶变换之所以能成立源于对任意正整数n，存在这样的一个单位根$w(n)$，满足四个条件：

1. $w(n)^0,w(n)^1, \ldots, w(n)^{n-1}$各不相同
2. $w(n)^n = 1$
3. $w(dn)^{dk}=w(n)^k$。
4. $w(2n)^n=-1$

在快速傅里叶变换中，我们选取$w(n)=e^{(2\pi /n)i}$作为单位根。

快速傅里叶变换会存在一定的精度损失问题，我们可以使用快速数论变换来替代。但是快速数论变换实际上还是沿用了快速傅里叶变换的整体框架，只是替换了单位根。我们需要找一个素数p，并找到它的一个原根g。可以发现当我们取$w(n)=g^{\frac{p-1}{n}}$时，可以满足上面所有条件。不是所有p都适合用于快速数论变换，我们需要找一个比较特殊的p，使得$n\|p-1$。由于n一般是2的幂次，因此我们希望$p-1$包含尽可能多的因子2，下面介绍两个常用的选择：


$$
998244353=2^{23}\cdot17 \cdot 7 +1\\
1004535809=2^{21}\cdot 479+1
$$

剩下的和快速傅里叶变换没有什么区别，直接套用就好了。

# 卷积精度溢出

快速傅里叶变换可能会遇到乘积的系数超过浮点数精度，而快速数论变换也存在系数超出模素数，导致与真实结果出现不同。

容易发现，如果两个多项式最大系数为m，而多项式的长度为n，那么卷积后结果的最大系数不会超过$m^2n$。

我们先假设所有系数都是整数（如果浮点数，那么就除去最小精度EPS，之后取整）。一种简单的思路是，我们可以将两个多项式进行处理，选择一个k，记$a%k$表示将a的系数都模上k得到的多项式，$a/k$表示将a的系数都下整除k得到的多项式。那么



$$
a\cdot b=(a/k\cdot k+a\%k)(b/k\cdot k+b\%k)\\
=a/k\cdot b/k\cdot k^2+a/k\cdot b\%k \cdot k+a\%k\cdot b/k\cdot k+a\%k\cdot b\%k
$$


这样就可以减小每一次卷积得到系数的大小。从而避免溢出问题。

还有一种方案就是将多项式拆成两个，这时候我们只需要记$a/k$表示多项式a的后k项的系数为0的多项式，而$a%k$表示多项式a仅后k项不变，其它项系数均变为0的多项式。可以得出：


$$
a\cdot b=(a/k\cdot x^k+a\%k)(b/k\cdot x^k+b\%k)\\
=a/k\cdot b/k\cdot x^{2k}+a/k\cdot b\%k \cdot x^k+a\%k\cdot b/k\cdot x^k+a\%k\cdot b\%k
$$


# 多项式求逆

给出多项式A，找到A的逆多项式B，满足$AB=1\mod x^n$。

当n为1时，问题非常简单，此时A的逆多项式一定是$1/A\[0\]$。假设我们已经找到了某个多项式C，使得$AC=1\mod x^{n/2}$。那么，可以推导出：


$$
AC=AB=1\mod x^{n/2}\\
\Rightarrow A(B-C)=0\mod x^{n/2}\\
\Rightarrow (B-C)=0\mod x^{n/2}\\
\Rightarrow (B-C)^2=0 \mod x^n
$$


最后一步需要说明下，对于$B-C$的后n项都是0，因此对于$B-C$的$x^i$的系数，若$i<n/2$，那么系数一定是$B-C$的后$n/2$项中两项的乘积的累加，一定是0，若$i\geq n/2$，那么一定是后$n/2$项和前$n/2$项的系数乘积的累和，也是0。

将二次方程展开：


$$
(B-C)^2=B^2+C^2-2BC=0\mod x^n\\
\Rightarrow B^2=2BC-C^2\mod x^n
$$


之后两端都乘上A，借助$AB=1$可知：


$$
AB^2=2ABC-AC^2\mod x^n\\
\Rightarrow B=2C-AC^2\mod x^n
$$


这样我们就得到了多项式B，并且可以发现，整个流程我们仅假设$A[0]$可逆，即一个多项式可逆当且仅当其$x^0$项的系数可逆。

# 多项式除法取模

我的天哪，多项式可以有除法了。。。

对于阶数为n的多项式$f(x)$，记$f^R(x)=x^nf(\frac{1}{x})$，换句话说$f^R(x)$是$f(x)$的系数前后交换后得到的。

接下来考虑阶数为n的多项式A和阶数为m的多项式B，以及阶数小于m的多项式R，我们希望得到如下形式等式A(x)=B(x)C(x)+R(x)。推一下公式：



$$
A(x)=B(x)C(x)+R(x)\\
\Rightarrow A(\frac{1}{x})=B(\frac{1}{x})C(\frac{1}{x})+R(\frac{1}{x})\\
\Rightarrow x^nA(\frac{1}{x})=(x^mB(\frac{1}{x}))(x^{n-m}C(\frac{1}{x}))+x^nR(\frac{1}{x})\\
\Rightarrow A^R(x)=B^R(x)C^R(x)+x^{n-m+1}R^R(x)\\
\Rightarrow A^R(x)=B^R(x)C^R(x)\mod x^{n-m+1}\\
\Rightarrow C^R(x)=A^R(x)(B^R(x))^{-1}\mod x^{n-m+1}
$$



最后的结果可以通过对多项式求逆得到。

而取模可以通过$R(x)=A(x)-B(x)C(x)$得到。

# 等差卷积

考虑计算下面多项式：


$$
H(x)=\sum_{i=0}^nx^i\sum_{j=i}^nf(j)g(j-i)
$$


它非常类似于一般卷积，只是内部是等差，而一般卷积是等和。我们定义$f'(x)=f(n-x)$。那么代入得到


$$
H'(x)=\sum_{i=0}^nx^i\sum_{j=0}^if'(j)g(i-j)
$$


很显然$H'$可以利用一般的快速卷积在$O(n\log_2n)$时间复杂度内得到，下面我们来看$H'$和$H$的关系。


$$
H'_i=\sum_{j=0}^if'(j)g(i-j)=\sum_{j=0}^if(n-j)g(i-j)
$$
这里包含了所有差为$n-i$的项的和。因此可以得到：


$$
H_i'=H_{n-i}
$$


即最终我们可以通过翻转$H'$得到$H$。

# 参考文献

- [多项式求逆litble博客](https://blog.csdn.net/litble/article/details/79828428)

- [https://www.cnblogs.com/cjyyb/p/10129563.html](https://www.cnblogs.com/cjyyb/p/10129563.html)