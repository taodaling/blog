---
categories: problems
layout: post
---

- Table
{:toc}
# 简单背包

**问题：**

有$n$个宝石，每个宝石都有自己的价值和重量，第$i$个宝石的价值为$v_i$， 重量为$w_i$。你有一个背包，背包承重为$b$，求最多能带走多少价值的宝石。

**进阶：**

对于每个承重为$1,2,\ldots, m$的背包，问分别能带走多少价值的宝石。

**题解：**

定义函数$f$，令$f(i,j)$表示仅考虑前$i$个宝石，用承重为$j$的背包最多能带走多少价值的宝石。很显然，对于满足$f(i,j)$的任意一个方案，我们有两种选择，第一种带走宝石$i$，第二种不带走宝石$i$。因此可以导出递推公式：


$$
f(i,j)=\left\{ \begin{array}{ll}
-\inf & \textrm{if $i<0\lor j<0$}\\
\max(f(i-1,j),f(i-1,j-w_i)) & \textrm{else}
\end{array} \right.
$$


总共$nm$种情况，用动态规划或记忆化搜索的时间复杂度为$O(nm)$。



# 状态压缩

**问题：**

一张$n\*m$的网格状地图上，某个网格，可能存在一扇门，门上标记一个整数$k$，表示需要钥匙$k$才能通行，钥匙散落在地图上，一个单元格最多有一把钥匙。$k$的范围为$1~10$。问从地图左上角到右下角最少步骤数，每一步最多向四个方向中一个方向移动一步，不允许越出地图边界。

**进阶：**

**题解：**

当我们处于地图的某个单元$(i,j)$时，设持有的钥匙集合为$s$，很显然$s$有$2^10$种可能，因此我们可以用$0~1023$的整数来表示，总共$2^10$种状态。

我们可以定义函数$f$，令$f(i,j,s)$表示从左上角到$(i,j)$时状态为$s$的最小步骤数。

之后我们可以在图上跑动态规划解决。图的大小为$nm2^10$。



# 简单公式求最优

**问题：**

假设有一个序列$a_1,a_2,\ldots,a_n$，要求找到这样的三个下标$i<j<k$，使得公式$a_i+a_k-2a_j$最大。

**进阶：**

**题解：**

从前往后遍历序列，维护三个公式的最大值，$y_1=a_i$，$y_2=a_i-2a_j$，$y_3=a_i-2a_j+a_k$。当我们处理$a_t$时，其有可能完全不参与三个公式，有可能作为$a_i$加入，有可能作为$a_j$加入，有可能作为$a_k$加入。因此我们要做的是
$$
y_3=\max(y_3,y_2+a_k)\\
y_2=\max(y_2,y_1-2a_k)\\
y_1=\max(y_1,a_k)\\
$$


# 减少一个维度

**问题：**

给出一个长度为$n$的字符串s，和两个s的子串a,b。其中$\mid s\mid<10^6$，而$\mid a\mid,\mid b\mid<10^3$。要求我们对$s$中的字符或者着红色或者着蓝色或者不着色，要求红色字符组成的子串正好等于$a$，蓝色字符组成的子串正好等于$b$。问是否存在这样的一种着色方案。

**进阶：**

**题解：**

很容易想到一个动态规划公式。定义$f(i,j,k)$，表示s长度为i的前缀，a的长度为j的前缀，b的长度为k的前缀是否存在着色方案。但是这个公式总共的状态数为$O(\mid s\mid \mid a\mid \mid b\mid)$。

我们可以定义另外一个函数$g(i,j)$表示s长度为$i$的前缀，a的长度为$j$的前缀，最多能包含$b$的前缀的长度。这样时间复杂度就被优化为$O(\mid s\mid \mid a\mid)$

看到从$f$到$g$的优化，我们实际上优化了一个变量。这个变量我们可以任选一个，因此如果我们选择变量为s，即定义一个函数$h(i,j)$，表示a的长度为$i$的前缀，b的长度为$j$的前缀，能够满足着色要求的s最短的前缀长度。这时候时间复杂度为$O(\mid a\mid \mid b\mid)$

# Codeforces 1146G

**问题:**

见链接[https://codeforces.com/contest/1146/problem/G](https://codeforces.com/contest/1146/problem/G)

**题解:**

令$dp(i,j,k)$表示仅考虑地点i..j，建立最高的屋子的高度不超过k时能获得的最大收益，其中惩罚条款仅考虑那些完全限于i..j内部的条款。要计算$dp(i,j,k)$，我们可以记m为房屋i..j中最高的那座，m可以通过枚举得到。之后如果$m<k$，那么很显然$dp(i,j,k)=dp(i,j,k-1)$。现在仅考虑$m=k$的情况。可以推出公式为：


$$
dp(i,j,k)=\min_m(dp(i,j,k-1),dp(i,m-1,k)+dp(m+1,j,k)+k^2-penalty)
$$



# Codeforces 1146H

**问题:**

见链接[https://codeforces.com/contest/1146/problem/H](https://codeforces.com/contest/1146/problem/H)

**题解:**

记$dp(i,j,k)$表示以顶点i开始结束，长度为k的凸包的数量。为了组成凸包，我们可以将一开始的所有线段按照斜率进行排序。之后我们可以遍历每条线段，并用线段对动态规划公式做补充，这样可以保证得到的折线的联结一定是凸包。

最后统计$\sum_idp(i,i,5)$即可。



